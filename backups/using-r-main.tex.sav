\documentclass[paper=a4,headsepline,BCOR=12mm,DIV=11,twoside,open=right,%
titlepage,headings=small,fontsize=10pt,index=totoc,bibliography=totoc,%
captions=tableheading,captions=nooneline]{scrbook}\usepackage{knitr}

%\usepackage[utf8]{inputenc}
\usepackage{color}

\usepackage{polyglossia}
\setdefaultlanguage[variant = british, ordinalmonthday = false]{english}

\usepackage{gitinfo2} % remember to setup Git hooks

\usepackage{hologo}

\usepackage{csquotes}

\usepackage{graphicx}
\DeclareGraphicsExtensions{.jpg,.pdf,.png}

\usepackage{animate}

\usepackage{microtype}
\usepackage[style=authoryear-comp,giveninits,sortcites,maxcitenames=2,%
    mincitenames=1,maxbibnames=10,minbibnames=10,backref,uniquename=mininit,%
    uniquelist=minyear,sortgiveninits=true,backend=biber]{biblatex}%,refsection=chapter

\usepackage[unicode,hyperindex,bookmarks,pdfview=FitB,%backref,
            pdftitle={Learn R ...as you learnt your mother tongue},%
            pdfkeywords={R, statistics, data analysis, plotting},%
            pdfsubject={R},%
            pdfauthor={Pedro J. Aphalo}%
            ]{hyperref}

\hypersetup{colorlinks,breaklinks,
             urlcolor=blue,
             linkcolor=blue,
             citecolor=blue,
             filecolor=blue,
             menucolor=blue}

\usepackage{framed}

\usepackage{abbrev}
\usepackage{usingr}

\usepackage{imakeidx}

%%% Adjust graphic design

% New float "example" and corresponding "list of examples"
%\DeclareNewTOC[type=example,types=examples,float,counterwithin=chapter]{loe}
\DeclareNewTOC[name=Box,listname=List of Text Boxes, type=example,types=examples,float,counterwithin=chapter,%
]{lotxb}

% changing the style of float captions
\addtokomafont{caption}{\sffamily\small}
\setkomafont{captionlabel}{\sffamily\bfseries}
\setcapindent{0em}

% finetuning tocs
\makeatletter
\renewcommand*\l@figure{\@dottedtocline{1}{0em}{2.6em}}
\renewcommand*\l@table{\@dottedtocline{1}{0em}{2.6em}}
\renewcommand*\l@example{\@dottedtocline{1}{0em}{2.3em}}
\renewcommand{\@pnumwidth}{2.66em}
\makeatother

% add pdf bookmarks to tocs
\makeatletter
\BeforeTOCHead{%
  \cleardoublepage
    \edef\@tempa{%
      \noexpand\pdfbookmark[0]{\list@fname}{\@currext}%
    }\@tempa
}

\setcounter{topnumber}{3}
\setcounter{bottomnumber}{3}
\setcounter{totalnumber}{4}
\renewcommand{\topfraction}{0.90}
\renewcommand{\bottomfraction}{0.90}
\renewcommand{\textfraction}{0.10}
\renewcommand{\floatpagefraction}{0.70}
\renewcommand{\dbltopfraction}{0.90}
\renewcommand{\dblfloatpagefraction}{0.70}

\addbibresource{rbooks.bib}
\addbibresource{references.bib}

\makeindex
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}

% customize chapter format:
%\KOMAoption{headings}{twolinechapter}
\renewcommand*\chapterformat{\thechapter\autodot\hspace{1em}}

% customize dictum format:
\setkomafont{dictumtext}{\itshape\small}
\setkomafont{dictumauthor}{\normalfont}
\renewcommand*\dictumwidth{0.7\linewidth}
\renewcommand*\dictumauthorformat[1]{--- #1}
%\renewcommand*\dictumrule{}

\extratitle{\vspace*{2\baselineskip}%
             {\Huge\textsf{\textbf{Learn R}\\ \textsl{\huge\ldots as you learnt your mother tongue}}}}

\title{\Huge{\fontseries{ub}\sffamily Learn R\\{\Large\ldots as you learnt your mother tongue}}}

\subtitle{Git hash: \gitAbbrevHash; Git date: \gitAuthorIsoDate}

\author{Pedro J. Aphalo}

\date{Helsinki, \today}

\publishers{Draft, 95\% done\\Available through \href{https://leanpub.com/learnr}{Leanpub}}

\uppertitleback{\copyright\ 2001--2017 by Pedro J. Aphalo\\
Licensed under one of the \href{http://creativecommons.org/licenses/}{Creative Commons licenses} as indicated, or when not explicitly indicated, under the \href{http://creativecommons.org/licenses/by-sa/4.0/}{CC BY-SA 4.0 license}.}

\lowertitleback{Typeset with \href{http://www.latex-project.org/}{\hologo{XeLaTeX}}\ in Lucida Bright and \textsf{Lucida Sans} using the KOMA-Script book class.\\
The manuscript was written using \href{http://www.r-project.org/}{R} with package knitr. The manuscript was edited in \href{http://www.winedt.com/}{WinEdt} and \href{http://www.rstudio.com/}{RStudio}.
The source files for the whole book are available at \url{https://bitbucket.org/aphalo/using-r}.}

\frontmatter

% knitr setup














% \thispagestyle{empty}
% \titleLL
% \clearpage

\maketitle

%\frontmatter
%\begin{titlingpage}
%  \maketitle
%\titleLL
%\end{titlingpage}

\tableofcontents

%\listoftables

%\listoffigures

%\mainmatter

\chapter*{Preface}

\dictum[R. P. Boas (1981) Can we make mathematics intelligible?, \emph{American Mathematical Monthly} \textbf{88:} 727-731.]{"Suppose that you want to teach the `cat' concept to a very young child. Do you explain that a cat is a relatively small, primarily carnivorous mammal with retractible claws, a distinctive sonic output, etc.? I'll bet not. You probably show the kid a lot of different cats, saying `kitty' each time, until it gets the idea. To put it more generally, generalizations are best made by abstraction from experience."}


% Such pauses are not a miss use of our time. To learn a natural language we need to interact with other speakers, we need feedback. In the case of R, we can get feedback both from the outcomes from our utterances to the computer, and from other R users.}

This book covers different aspects of the use of \Rpgrm. It is meant to be used as a tutorial complementing a reference book about \R, or the documentation that accompanies R and the many packages used in the examples. Explanations are rather short and terse, so as to encourage the development of a routine of exploration. This is not an arbitrary decision, this is the normal \emph{modus operandi} of most of us who use R regularly for a variety of different problems.

I do not discuss here statistics, just \Rpgrm as a tool and language for data manipulation and display. The idea is for you to learn the \Rpgrm language like children learn a language: they work-out what the rules are, simply by listening to people speak and trying to utter what they want to tell their parents. I do give some explanations and comments, but the idea of these notes is mainly for you to use the numerous examples to find-out by yourself the overall patterns and coding philosophy behind the \Rpgrm language. Instead of parents being the sound board for your first utterances in \langname{R}, the computer will play this role. You should look and try to repeat the examples, and then try your own hand and see how the computer responds, does it understand you or not?

When teaching I tend to lean towards challenging students rather than telling a simplified story. I do the same here, because it is what I prefer as a student, and how I learn best myself. Not everybody learns best with the same approach, for me the most limiting factor is for what I listen to, or read, to be in a way or another challenging or entertaining enough to keep my thoughts focused. This I achieve best when making an effort to understand the contents or to follow the thread or plot of a story. So, be warned, reading this book will be about exploring a new world, this book aims to be a travel guide, neither a traveler's account, nor a cookbook of R recipes.

Do not expect to ever know everything about \Rpgrm! \Rpgrm in a broad sense is vast because its capabilities can be expanded with independently developed packages. Currently there are more than ten thousand packages available for free in the Comprehensive R Archive Network (CRAN), the main, but not only public repository for R packages. You just need to learn to use what you need to use and to have an idea of what else is available, so that you know where to look for packages when your needs change in the future. And if what you need does not exist, then take the plunge, and write your very own package to share with the world (or not). Being \Rpgrm very popular there is nowadays lots of information available, plus a helpful and open minded on-line community willing to help with those difficult problems for which Goggle will not be of help.

How to read this book? My idea is that you will run all the code examples and try as many other variations as needed until you are sure to understand the basic `rules' of the \Rpgrm language and how each function or command described works. In \Rpgrm for each function, data set, etc.\ there is a help page available. In addition, if you use a front-end like \RStudio, auto-completion is available as well as balloon help on the arguments accepted by functions. For scripts, there is syntax checking of the source code before its execution: \emph{possible} mistakes and even formatting style problems are highlighted in the editor window. Error messages tend to be terse in \Rpgrm, and may require some lateral thinking and/or `experimentation' to understand the real cause behind problems. When you are not sure to understand how some command works, it is useful in many cases to try simple examples for which you know the correct answer and see if you can reproduce them in \Rpgrm.

As with any computer languages, in addition to learning the grammar of the language, learning the commonly used writing styles and idioms is extremely important. Computer programs should be readable and easy to understand to humans, in addition to being valid. One aspect of this consistency. I have tried to be consistent, and to use a clear style that does not diverge much from current usual practice. With time you may develop to some extent a personal style, and this is usually o.k. However, when writing computer code, as for any other text intended for humans to read, strive to stick to a consistent writing style and formatting as they go a long way in making your intentions clear.

As I wrote above there are many different ways of doing thing in R, and many of the packages that are most popular nowadays did not exist when I started using R. One could write many different R books with similar content and still use substantially different ways of achieving the same results. I limit myself to packages that are currently popular or that I consider elegantly designed. I have in particular tried to limit myself to packages with similar design philosophies, especially in relation to their interfaces. What is elegant design, and in particular what is a friendly user interface depends strongly on each user's preferences and previous experience. Consequently, the contents of the book is strongly biased by my own preferences. Once again, I encourage readers to take this book as a travel guide as a starting point, and to explore also the very many packages, styles and approaches which I have not described.

I will appreciate suggestions for further examples, notification of errors and unclear sections and also any larger contributions. Many of the examples here have been collected from diverse sources over many years and because of this not all sources are acknowledged. If you recognize any example as yours or someone else's please let me know so that I can add a proper acknowledgement. I warmly thank the students that over the years have asked the questions and posed the problems that have helped me write this text and correct the mistakes and voids of previous versions. I have also received help on on-line forums and in person from numerous people, learnt from archived e-mail list messages, blog posts, books, articles, tutorials, webinars, and by struggling to solve some new problems on my own. In many ways this text owes much more to people who are not authors than to myself. However, as I am the one who has written this version and decided what to include and exclude, as author, I take full responsibility for any errors and inaccuracies.

I have been using \Rpgrm since around 1998 or 1999, but I am still constantly learning new things about \Rpgrm itself and \Rpgrm packages. With time it has replaced in my work as a researcher and teacher several other pieces of software: \pgrmname{SPSS}, \pgrmname{Systat}, \pgrmname{Origin}, \pgrmname{Excel}, and it has become a central piece of the tool set I use for producing lecture slides, notes, books and even web pages. This is to say that it is the most useful piece of software and programming language I have ever learnt to use. Of course, in time it will be replaced by something better, but at the moment it is the ``hot'' thing to learn for anybody with a need to analyse and display data.

\begin{playground}
\noindent%
\textbf{Approach this book like a child learning to speak:} Do not struggle, just play! If going gets difficult and frustrating, take a break! If you get a new insight, take a break to enjoy the victory!
\end{playground}

\newpage

\begin{framed}
\noindent\Large
\textbf{Icons used to mark different content.} Throughout the book text boxes marked with icons present different types of information. First of all, we have \emph{playground} boxes indicated with \playicon\ which are open-ended exercises---ideas and pieces of R code to play with at the R console. A few of these will require more time to grasp, and are indicated with \advplayicon. Boxes providing general information, usually not directly related to \langname{R} as a language, are indicated with \infoicon. Some boxes highlighted with \ilAttention\ give important bits of information that must be remembered when using \langname{R}---i.e.\ explain some unusual feature of the language. Finally, some boxes indicated by \ilAdvanced\ give in depth explanations, that may require you to spend time on, which en general can be skipped on first reading, but to which you should return at a later, and peaceful, time with more time and a cup of coffee or tea.
\end{framed}
\newpage

\begin{infobox}
\noindent
\textbf{Status as of 2016-11-23.} I have updated the manuscript to track package updates since the previous version uploaded six months ago, and added several examples of the new functionality added to packages \ggpmisc, \ggrepel, and \ggplot. I have written new sections on packages \viridis, \pkgname{gganimate}, \pkgname{ggstance}, \pkgname{ggbiplot}, \pkgname{ggforce}, \pkgname{ggtern} and \pkgname{ggalt}. Some of these sections are to be expanded, and additional sections are planned for other recently released packages.

With respect to the chapter \textit{Storing and manipulating data with R} I have put it on hold, except for the introduction, until I can see a soon to be published book covering the same subject. Hadley Wickham has named the set of tools developed by him and his collaborators as \textit{tidyverse} to be described in the book titled \textit{R for Data Science} by Grolemund and Wickham (O'Reilly).

An important update to \ggplot was released last week, and it includes changes to the behavior of some existing functions, specially faceting has become extensible through other packages. Several of the new facilities are described in the updated text and code included in this book and this pdf has been generated with up-to-date version of \ggplot and packages as available today from CRAN, except for \pkgname{ggtern} which was downloaded from Bitbucket minutes ago.

The present update adds about 100 pages to the previous versions. I expect to upload a new update to this manuscript in one or two months time.

\textbf{Status as of 2017-01-17.} Added ``playground'' exercises to the chapter describing \ggplot, and converted some of the examples earlier part of the main text into these playground items. Added icons to help readers quickly distinguish playground sections (\textcolor{blue}{\noticestd{"0055}}), information sections (\textcolor{blue}{\modpicts{"003D}}), warnings about things one needs to be specially aware of (\colorbox{yellow}{\typicons{"E136}}) and boxes with more advanced content that may require longer time/more effort to grasp (\typicons{"E04E}). Added to the sections \code{scales} and examples in the \ggplot chapter details about the use of colors in R and \ggplot2. Removed some redundant examples, and updated the section on \code{plotmath}. Added terms to the alphabetical index. Increased line-spacing to avoid uneven spacing with inline code bits.

\textbf{Status as of 2017-02-09.} Wrote section on ggplot2 themes, and on using system- and Google fonts in ggpplots with the help of package \pkgname{showtext}. Expanded section on \ggplot's \code{annotation}, and revised some sections in the ``R scripts and Programming'' chapter. Started writing the data chapter. Wrote draft on writing and reading text files. Several other smaller edits to text and a few new examples.

\textbf{Status as of 2017-02-14.} Wrote sections on reading and writing MS-Excel files, files from statistical programs such as SPSS, SyStat, etc., and NetCDF files. Also wrote sections on using URLs to directly read data, and on reading HTML and XML files directly, as well on using JSON to retrieve measured/logged data from IoT (internet of things) and similar intelligent physical sensors, micro-controller boards and sensor hubs with network access.

\textbf{Status as of 2017-03-25.} Revised and expanded the chapter on plotting maps, adding a section on the manipulation and plotting of image data. Revised and expanded the chapter on extensions to \pkgname{ggplot2}, so that there are no longer empty sections. Wrote short chapter ``If and when R needs help''. Revised and expanded the ``Introduction'' chapter. Added index entries, and additional citations to literature.

\textbf{Status as of 2017-04-04.} Revised and expanded the chapter on using \Rpgrm as a calculator. Revised and expanded the ``Scripts'' chapter. Minor edits to ``Functions'' chapter. Continued writing chapter on data, writing a section on R's native apply functions and added preliminary text for a pipes and tees section. Write intro to `tidyverse' and grammar of data manipulation. Added index entries, and a few additional citations to the literature. Spell checking.

\textbf{Status as of 2017-04-08.} Completed writing first draft of chapter on data, writing all the previously missing sections on the ``grammar of data manipulation''. Wrote two extended examples in the same chapter. Add table listing several extensions to \pkgname{ggplot2} not described in the book.

\textbf{Status as of 2017-04-09.} Revised chapters on data, plotting, more plotting and maps and raster images, correcting some spelling mistakes, adding some explanatory text and indexing all functions and operators used.

\end{infobox}

%\chapter*{Learning like a child}
\mainmatter


\chapter{Introduction}\label{chap:introduction}

\dictum[Ursula K. le Guin]{The creative adult is the child who has survived.}\vskip2ex

\section{R}

\subsection{What is R?}

Most people think of R as a computer program. R is indeed a computer program---a piece of software---, but it is also a computer language, implemented in the R program. Does this make a difference? Yes, until recently we had only one mainstream implementation of R, the program R. In the last couple of years another implementation has started to gain popularity, Microsoft R. These are not the only two implementations, but others are not in widespread use.

One could think of R, as a dialect of the S language. S was created and implemented before R. S evolved into S-Plus. As S and S-Plus are commercial programs, variations in the language appeared only between versions. R started as a poor man's home-brewed implementation of S, for use in teaching. Initially R, the program, implemented a subset of the S language. The R program evolved until only some relatively small differences between S and R remained, and these differences were intentional---thought of as improvements. As R overtook S-Plus in popularity, some of the new features in R made their way back into S. R is sometimes called Gnu S.

What makes R different from SPSS, SAS, etc., is that it is based on a complete computer programming language designed from scratch for data analysis and visualization. This may look unimportant for someone not actually needing or willing to write software for data analysis. However, in reality it makes a huge difference because R is extensible. By this it is meant that new functionality can be easily added, and shared, and this new functionality is to the user indistinguishable from that built-in into R. It other words, instead of having to switch between different pieces of software to do different types of analyses or plots, one can usually find an R package that will do the job. For those routinely doing similar analyses the ability to write a short program, sometimes just a handful of lines of code, will allow automation of routine analyses. For those willing to spend time programming, they have to door open to building the tools they need if they do not already exist.

However, the most import advantage of using R is that it makes it easy to do data analyses in a way that ensures that they can be exactly repeated. In other words, the biggest advantage of using R, as a language, is not in communicating with the computer, but in communicating to other people what has been done, in a way that is unambiguous. Of course, other people may want to run the same commands in another computer, but still it means that a translation from a set of instructions to the computer into text readable to humans---say the materials and methods section of a paper---and back is avoided.

\subsection{R as a computer program}

The R code is open-source, it is available for anybody to inspect, modify and use. A small fraction of users will directly contribute improvements to the R program itself, but it is possible, and those contributions are important in making R reliable. The executable, the R program we actually use, can be built for different operating systems and computer hardware. The developers make an important effort to keep the results obtained from calculations done on all the different builds and computer architectures as consistent as possible.

R does not have a graphical user interface (GUI), or menus from which to start different types of analyses. One types the commands at the R console, or saves the commands into a text file, and uses the file as a `script' or list of commands to be run. When we work at the console typing in commands one by one, we say that we use R interactively. When we run script we would say that we run a ``batch job''. These are the two options that R by itself provides, however, we can use a front-end program on top of R. The simplest option is to use a text editor like Emacs to edit the scripts and then run the scripts in R. With some editors like Emacs, rather good integration is possible, but nowadays there are also some Integrated Development Environments for R, currently being RStudio the most popular by a wide margin.

\subsubsection{Using R interactively}

Typing commands at the R console is useful when one is playing around, aimlessly exploring things, but once we want to keep track of what we are doing, there are better ways of using R. However, the different ways of using R are not exclusive, so most users will use the R console to test individual commands, plot data during the first stages of exploring them, at the console. As soon as we know how we want to plot or analyse the data, it is best to start using scripts. This is not enforced in any way by R, but using scripts, or as we will below literate scripts to produce reports is what really brings to fruition the most important advantages of using R. In Figure \ref{fig:intro:console} we can see how the R console looks under MS-Windows. The text in red has been type in by the user---except for the prompt \code{$>$}---, and the blue text is what R has displayed in response. It is essentially a dialogue between user and R.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/R-console-capture}
  \caption[Screen capture of the R console]{Screen capture of the R console being used interactively.}\label{fig:intro:console}
\end{figure}

\subsubsection{Using R as a ``batch job''}

To run a script we need first to prepare a script in a text editor. Figure \ref{fig:intro:script} shows the console immediately after running the script file shown in the lower window. As before, red text, the command \code{source("my-script.R")}, was typed by the user, and the blue text in the console is what was displayed by R as a result of this action.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/R-console-script}
  \caption[Script sourced at the R console]{Screen capture of the R console and editor just after running a script. The upper window shows the R console, and the lower window the script file in an editor window. }\label{fig:intro:script}
\end{figure}

A true ``batch job'' is not run at the R console but at the operating system command prompt, or shell. The shell is the console of the operating system---Linux, Unix, OS X, or MS-Windows. Figure \ref{fig:intro:shell} shows how running an script at the Windows commands prompt looks. In normal use, a script run at the operating system prompt does time-consuming calculations and the output is saved to a file. One may use this approach on a server, say, to leave the batch job running over-night.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/windows-cmd-script}
  \caption[Script at the Windows cmd promt]{Screen capture Windows 10 command console just after running the same script. Here we use \code{Rscript} to run the script, the exact syntax will depend on the operating system in use. In this case R prints the results at the operating system console or shell, rather than in its own R console.}\label{fig:intro:shell}
\end{figure}

\subsubsection{Where do IDEs fit?}

Integrated Development Environments (IDEs) were initially created for computer program development. They are programs that the user interacts with, from within which the different tools needed can be used in a coordinated way. They usually include a dedicated editor capable of displaying the output from different tools in a useful way, and also in many cases can do syntax highlighting, and even report some mistakes, related to the programming language in use while the user types. One could describe such editor as the equivalent as a word processor, that can check the program code for spelling and syntax errors, and has a built-in thesaurus for the computer language. In the case of RStudio, the main, but not only language supported is R. The screen of IDEs usually displays several panes or windows simultaneously. From within the IDE one has access to the R console, an editor, a file-system browser, and access to several tools. Although RStudio supports very well the development of large scripts and packages, it is also the best possible way of using R at the console as it has the R help system very well integrated. Figure \ref{fig:intro:rstudio} shows the window display by RStudio under Windows after running the same script as shown above at the R console and at the operating system command prompt. We can see in this figure how RStudio is really a layer between the user and an unmodified R executable. The script was sourced by pressing the ``Source'' button at the top of the editor pane. RStudio in response to this generated the code needed to source the file and ``entered'' at the console, the same console, where we would type ourselves any R commands.

\begin{figure}
  \centering
  \includegraphics[width=0.99\textwidth]{figures/Rstudio-script}
  \caption[Script in Rstudio]{The RStudio interface just after running the same script. Here we used the ``Source'' button to run the script. In this case R prints the results to the R console in the lower left pane.}\label{fig:intro:rstudio}
\end{figure}

The version of RStudio that one uses locally, runs with almost identical user interface on most modern operating systems, such as Linux, Unix, OS X, MS-Windows and a few others. There is also a server version that runs on Linux, and that can be used remotely through any web browser. The user interface is still the same.

\subsection{R as a language}

\langname{R} is a computer language designed for data analysis and data visualization, however, in contrast to some other scripting languages, it is from the point of view of computer programming a complete language---it is not missing any important feature. As mentioned above, R started as a free and open-source implementation of the S-language \autocite{Becker1984,Becker1988}. We will described the features of the R language on later chapters. Here I mention, that it does have some features that makes it different from other programming languages. For example, it does not have the strict type checks of \pgrmname{Pascal}, nor  \pgrmname{C++}. It also has operators that can take vectors and matrices as operands allowing a lot more concise program statements for such operations than other languages. Writing programs, specially reliable and fast code, requires familiarity with some of these idiosyncracies of the R language. For those using R interactively, or writing short scripts, these features make life a lot easier.

\begin{explainbox}
Some languages have been standardised, and their grammar has been formally defined. R, in contrast is not standardized, and there is no formal grammar definition. So, the R language is defined by the behaviour of the R program.
\end{explainbox}

\pgrmname{R}\index{R!design} was initially designed for interactive use in teaching, the \pgrmname{R} program uses an interpreter instead of a compiler.

\begin{explainbox}
\textbf{Interpreters and compilers}\index{compiler}\index{interpreter}\index{byte compiler} Computer programs and scripts are nowadays almost always written in a high level language that is readable to humans, and that relies on a grammar much more complex than that understood by the hardware processor chip in the computer or device. Consequently one or more translation steps are needed. An interpreter, translates user code at the time of execution, and consequently parts of the code that are executed repeatedly are translated multiple times. A native compiler translates the user code into machine code in a separate step, and the compiled machine code can be stored and executed itself as many times as needed. On the other hand, compiled code can be executed only on a given hardware (processor, or processors from a given family). A byte-code compiler, translates user code into an intermediate representation, which cannot be directly executed by any hardware, and which is independent of the hardware architecture, but easier/faster to translate into machine code. This second interpreter is called a ``virtual machine'', as it is not dependent on a real hardware processor architecture.

An interpreter adds flexibility and makes interactive use possible, but results in slower execution compared to compiled executables. Nowadays, byte compiling is part of the \pgrmname{R} program, and used by default in some situations or under user control. Just-in-time (JIT) compiling is a relatively new feature in \pgrmname{R}, and consists in compiling on-the-fly code that is repeatedly evaluated within a single run of a script.

Functions or subroutines that have been compiled to machine code can be called from within \pgrmname{R}, but currently not written in the \langname{R} language itself, as no native compiler exists for the R language. It is common to call from within \pgrmname{R} code, compiled functions or use whole libraries coded in languages such a \langname{C}, \langname{C++} and \langname{FORTRAN} when maximum execution speed is needed. The calls are normally done from within an \pgrmname{R} package, so that they appear to the user not different any other R function. Functions and libraries written in other interpreted and/or byte-compiled languages like \langname{Java} and \langname{Python} can also be called from \pgrmname{R}.

In addition, \pgrmname{R} exposes a programming interface (API) and many \pgrmname{R} functions can be called from within programs or scripts written in other languages such a \langname{Python} and \langname{Java}, also database systems and work sheets. This flexibility is one of the reasons behind \pgrmname{R}'s popularity.
\end{explainbox}

\section{Packages and repositories}

The most elegant way of adding new features or capabilities is through packages. This is without doubt the best mechanism when these extensions to R need to be shared. However, in most situations it is the best mechanism for managing code that will be reused even by a single person over time. R packages have strict rules about their contents, file structure, and documentation, which makes it possible among other things for the package documentation to be merged into R's help system when a package is loaded. With a few exceptions, packages can be written so that they will work on any computer where R runs.

Packages can be shared as source or binary package files, sent for example through e-mail. However, for sharing them widely, the best is to submit them to repository. The largest public repository of R packages is called CRAN, an acronym for Comprehensive R Archive Network. Packages available through CRAN are guaranteed to work, in the sense of not failing any tests built into the package and not crash or fail. They are tested daily, as they may depend on other packages that may change as they are updated. In January 2017, the number of packages available through CRAN passed the 10\,000 mark.

\section{Reproducible data analysis}

One requirement for reproducible data analysis, is a reliable record of what commands have been run on which data. Such a record is specially difficult to keep when issuing commands through menus and dialogue boxes in a graphical user interface. When working interactively at the R console, it is a bit easier, but still copying and pasting is error prone.

A further requirement is to be able to match the output of the R commands to the output. If the script generates the output to separate files, then the user will need to take care that the script saved or shared as record of the data analysis was the one actually used for obtaining the reported results and conclusions. This is another error prone stage in the report of a data analysis. To solve this problem an approach was developed, inspired in what is called \emph{literate programming}. The idea is running the script will produce a document that includes the script, the results of running the scripts and any explanatory text needed to understand and interpret the analysis.

Although a system capable of producing such reports, called Sweave, has been available for a couple decades, it was rather limited and not supported by an IDE, making its use tedious. A more recently developed system called \pkgname{knitr} together by its integration into RStudio has made the use of this type of reports very easy. The most recent development are Notebooks produced within RStudio. This very new feature, can produce the readable report of running the script, including the code used interspersed with the results within the viewable file. However, this newest approach goes even further, in the actual source script used to generate the report is embedded in the HTML file of the report. This means that anyone who gets access to the output of the analysis in human readable form also gets access to the code used to generate report, in a format that can be immediately executed as long as the data is available.

Because of these recent developments, R is an ideal language to use when the goal of reproducibility is important. During recent years the problem of the lack of reproducibility in scientific research has been broadly discussed and analysed. One on the problems faced when attempting to reproduce experimental work, is reproducing the data analysis. R together with these modern tools can help in avoiding one of the sources of lack of reproducibility.

How powerful are these tools? and how flexible? They are powerful and flexible enough to write whole books, such as this very book you are now reading, produced with R, knitr and \LaTeX. All pages in the book are generated directly, all figures are generated by R and included automatically, except for the three figures in this chapter that have been manually captured from the computer screen. Why am I using this approach? First because I want to make sure that every bit of code as you will see printed, runs without error. In addition I want to make sure that the output that you will see below every line or chunk of R language code is exactly what R returns. Furthermore, it saves a lot of work for me as author, and can just update R and all the packages used to their latest version, and build the book again, to keep it up to date and free of errors.

\section{R, editors and IDEs}

I recommend you to use as an editor or IDE (integrated development environment) \RStudio. \RStudio is user friendly, actively maintained, free, open-source and available both in desktop and server versions. The desktop version runs on Windows, Linux, and OS X and other Unixes. \Rpgrm itself also runs under all these operating systems and a few more.

For\index{IDE for R}\index{editor for R scripts} running the examples in the handbook, you would need only to have \pgrmname{R} installed. That would be enough as long as you also have a text editor available. This is possible, but does not give a very smooth work flow for data analyses that are beyond the very simple. The next stage is to use a text editor which integrates to some extent with R, but still this is not ideal, specially for writing packages or long scripts. Currently the best option is to use the integrated development environment (IDE) called \pgrmname{RStudio}. This is an editor, but tightly integrated with R. Its advantages are especially noticeable in the case of errors and `debugging' and the integration of help feature like automatic completion. During the development of packages, I use \pgrmname{RStudio} exclusively. For writing this book I have used both RStudio and the text editor WinEdt which also has some support for R together with excellent support for \LaTeX. When working on a large project or collaborating with other data analysts or researchers, one big advantage of a system based on plain text files, is that the same files can be edited with different programs as needed or wished.

\subsection{RStudio}

\pgrmname{RStudio} is an integrated development environment (IDE). The difference between an IDE and an editor is that an IDE integrates additional tools that facilitate the interaction with R. RStudio highlights the R code according to the syntax, offers auto-completion while typing, highlights invalid code on the fly. When a script is run, if an error is triggered, it automatically find the location of the error. \pgrmname{RStudio} also supports the concept of projects allowing saving of settings separately. It also integrates support for file version control (see next section).

\pgrmname{RStudio} exists in two versions with identical user interface: a desktop version and a server version. The server version can be used remotely through a web browser. It can be run in the 'cloud', for example, as an AWS instance (Amazon Web Services) quite easily and cheaply, or on one's own server hardware. \pgrmname{RStudio} is under active development, and constantly improved (visit \url{http://www.rstudio.org/} for an up-to-date description and download and installation instructions.

Two books \autocite{vanderLoo2012,Hillebrand2015} describe and teach how to use \pgrmname{RStudio} without going in depth into data analysis or statistics, however, as \pgrmname{RStudio} is under very active development new features are not described in these books. You will find tutorials and up-to-date cheat sheets at \url{http://www.rstudio.org/}.

\section{Finding additional information}

When searching for answers, asking for advice or reading books you will be confronted with different ways of doing the same tasks. Do not allow this overwhelm you, in most cases it will not matter as many computations can be done in \Rpgrm, as in any language, in several different ways, still obtaining the same result. The different approaches may differ mainly in two aspects: 1) how readable to humans are the instructions given to the computer as part of a script or program, and 2) how fast the code will run. Unless performance is an important bottleneck in your work, just concentrate on writing code that is easy to understand to you and to others, and consequently easy to check and reuse. Of course do always check any code you write for mistakes, preferably using actual numerical test cases for any complex calculation or even relatively simple scripts. Testing and validation are extremely important steps in data analysis, so get into this habit while reading this book. Testing how every function works as I will challenge you to do in this book, is at the core of any robust data analysis or computing programming. When developing R packages, including a good coverage of test cases as part of the package itself simplifies code maintenance enormously.

\subsection{R's built-in help}

To\index{R!help} access help pages through the command prompt we use function \texttt{help()} or a question mark. Every object exported by an R package (functions, methods, classes, data) is documented. Sometimes a single help page documents several R objects. Usually at the end of the help pages some us examples are given.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{help}\hlstd{(}\hlstr{"sum"}\hlstd{)}
\hlopt{?}\hlstd{sum}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{playground}
Look at help for some other functions like \code{mean()}, \code{var()}, \code{plot()} and, why not, \code{help()} itself!
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{help}\hlstd{(help)}
\end{alltt}
\end{kframe}
\end{knitrout}
\end{playground}

In addition to help pages, the \pgrmname{R}'s distribution includes useful manuals as PDF or HTML files. This can be accessed most easily through the Help menu in \pgrmname{RStudio} or \pgrmname{RGUI}. Extension packages, provide help pages for the functions and data they make available. When a package is loaded into an \pgrmname{R} session, its help pages are added to the native help of \pgrmname{R}. In addition to these individual help pages, each package, provides an index of its corresponding help pages, for users to browse. Many packages, also provide \emph{vignettes} such as User Guides or articles describing the algorithms used.

\subsection{Obtaining help from on-line forums}

\subsubsection{Netiquette}
In\index{netiquette}\index{network etiquette} most internet forums, a certain behaviour is expected from those asking and answering questions. Some types of miss-behavior, like use of offensive or inappropriate language, will usually result in the user being banned writing rights in a forum. Occasional minor miss-behaviour, will usually result in the original question not being answered and instead the problem highlighted in the reply.

\begin{itemize}
  \item Do your homework: first search for existing answers to your question, both on-line and in the documentation. (Do mention that you attempted this without success when you post your question.)
  \item Provide a clear explanation of the problem, and all the relevant information. Say if it concerns R, the version, operating system, and any packages loaded and their versions.
  \item If at all possible provide a simplified and short, but self-contained, code example that exemplifies the problem.
  \item Be polite.
  \item Contribute to the forum by answering other users' questions when you know the answer.
\end{itemize}

\subsubsection{StackOverflow}

Nowadays, StackOverflow (\url{http://stackoverflow.com/})\index{StackOverflow} is the best questions and answers support site for \pgrmname{R}. In most cases, searching for existing questions and their answers, will be all what you need to do. If asking a question, make sure that it is really a new question. If there is some question that looks similar, make clear how your question is different.

StackOverflow has a user-rights system based on reputation, and questions and answers can be up- and down-voted. Those with the most up-votes are listed at the top of searches. If the questions or answers you write are up-voted after you accumulate enough reputation you acquire badges, and rights, such as editing other users' questions and answers or later on, even deleting wrong answers or off-topic questions from the system. This sounds complicated, but works extremely well at ensuring that the base of questions and answers is relevant and correct, without relying on a single or ad-hoc \emph{moderators}.

\section{Other tools}

\subsection{Revision control: Git and Subversion}

Revision control systems\index{revision control}\index{Git}\index{Subversion} help by keeping track of the history of software development, data analysis, or even manuscript writing. They make it possible for several programmers, data analysts, authors and or editors to work on the same files in parallel and then merge their edits. They also allow easy transfer of whole `projects' between computers. \pgrmname{Git} is very popular, and Github (\url{https://github.com/}) and Bitbucket (\url{https://bitbucket.org/}) are popular hosts for \pgrmname{Git} repositories. \pgrmname{Git} itself is free software, was designed by Linus Tordvals of Linux fame, and can be also run locally, or as one's own private server, either as an AWS instance or on other hosting services, or on your own hardware.

The books `Git: Version Control for Everyone' \autocite{Somasundaram2013} and `Pragmatic Guide to Git' \autocite{Swicegood2010} are good introductions to revision control with \pgrmname{Git}. Free introductory videos and \emph{cheatsheets} are available at \url{https://git-scm.com/doc}.

\subsection{C, C++ and FORTRAN compilers}

Although\index{c@\textsf{C++}}\index{c!compiler} R is an interpreted language, a compiler may need to be installed for compiling R itself, and/or packages containing functions or libraries written in  \langname{C}, \langname{C++} or  \langname{FORTRAN}. On OS X and MS-Windows, the normal practice is to install binary packages (available already compiled from repositories such as CRAM). In other systems like Linux distributions and Unix it is the normal practice to install packages from sources, that may require compilation at the time of installation. With suitable build tools (e.g.\ \pgrmname{RTools} for MS-Windows, and X-code for OS X) source packages can be installed and developed in any of the operating systems on which R runs.

\subsection{\hologo{LaTeX}}

\hologo{LaTeX}\index{latex@\hologo{LaTeX}} is built on top of \hologo{TeX}\index{tex@\hologo{TeX}}. \hologo{TeX} code and features were `frozen' (only bugs are fixed) long ago. There are currently a few `improved' derivatives: \hologo{pdfTeX}\index{pdftex@\hologo{pdfTeX}}, \hologo{XeTeX}\index{xetex@\hologo{XeTeX}}, and \hologo{LuaTeX}\index{luatex@\hologo{LuaTeX}}. Currently the most popular \hologo{TeX} in western countries is \hologo{pdfTeX} which can directly output PDF files. \hologo{XeTeX} can handle text both written from left to right and right to left, even in the same document and supports additional font formats, and is the most popular \hologo{TeX} engine in China and other Asian countries. Both \hologo{XeLaTeX} and \hologo{LuaTeX} are rapidly becoming popular also for typesetting texts in variants of Latin and Greek alphabets as these new \hologo{TeX} engines natively support large character sets and modern font formats such as TTF (True Type) and OTF (Open Type).

\hologo{LaTeX} is needed only for building from sources packages that include documentation using this text markup language. The present handbook is written using \pgrmname {R} and \hologo{XeLaTeX}, and the source files are available from a public \pgrmname{Git} repository at Bitbucket (\url{https://bitbucket.org/aphalo/using-r}).

\subsection{Markdown}

\langname{Markdown} is a simple markup language, which although offering somehow less flexibility than \hologo{LaTeX}, it is much easier to learn and text files using this markup language, can be easily converted to various output formats such as HTML and XTML in addition to PDF. \pgrmname{RStudio} supports editing markdown and the variants \langname{R Markdown} and \langname{Bookdown}. Documentation on \langname{Rmarkdown} is available on-line at \url{http://rmarkdown.rstudio.com/} and on \langname{Bookdown} at \url{https://bookdown.org/}.



















\chapter{Further reading about R}\label{chap:R:readings}

\dictum[Arthur C. Clarke]{Before you become too entranced with gorgeous gadgets and mesmerizing video displays, let me remind you that information is not knowledge, knowledge is not wisdom, and wisdom is not foresight. Each grows out of the other, and we need them all.}\vskip2ex

\section{Introductory texts}

\cite{Dalgaard2008,Zuur2009,Teetor2011,Peng2017,Paradis2005,Peng2016}

\section{Texts on specific aspects}

\cite{Chang2013,Fox2002,Fox2010,Faraway2004,Faraway2006,Everitt2011,Wickham2017}

\section{Advanced texts}

\cite{Xie2013,Chambers2016,Wickham2015,Wickham2014advanced,Wickham2016,Pinheiro2000,Murrell2011,Matloff2011,Ihaka1996,Venables2000}

\backmatter

\printbibliography

\printindex

\end{document}

\appendix

\chapter{Build information}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{Sys.info}\hlstd{()}
\end{alltt}
\begin{verbatim}
##        sysname        release        version
##      "Windows"       "10 x64"  "build 14393"
##       nodename        machine          login
##        "MUSTI"       "x86-64"       "aphalo"
##           user effective_user
##       "aphalo"       "aphalo"
\end{verbatim}
\end{kframe}
\end{knitrout}



\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\begin{verbatim}
## R version 3.3.3 (2017-03-06)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 10 x64 (build 14393)
##
## locale:
## [1] LC_COLLATE=English_United Kingdom.1252
## [2] LC_CTYPE=English_United Kingdom.1252
## [3] LC_MONETARY=English_United Kingdom.1252
## [4] LC_NUMERIC=C
## [5] LC_TIME=English_United Kingdom.1252
##
## attached base packages:
## [1] tools     stats     graphics  grDevices
## [5] utils     datasets  base
##
## other attached packages:
## [1] svglite_1.2.0 stringr_1.2.0 knitr_1.15.1
##
## loaded via a namespace (and not attached):
## [1] magrittr_1.5  Rcpp_0.12.10  gdtools_0.1.4
## [4] stringi_1.1.3 highr_0.6     methods_3.3.3
## [7] evaluate_0.10
\end{verbatim}
\end{kframe}
\end{knitrout}

%

\end{document}


