% !Rnw root = using-r.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
@

\chapter[Extensions to ggplot]{Extensions to \ggplot}\label{chap:R:more:ggplotting}

\dictum[Edward Tufte]{What this means is that we shouldn't abbreviate the truth but rather get a new method of presentation.}

\section{Aims of this chapter}

In this chapter I describe packages that add additional functionality or \emph{graphical designs} of plots to package \pkgname{ggplot2}. Several new packages were written after \pkgname{ggplot2} version 2.0.0 was released, because this version for the first time made it straightforward to write these extensions. To keep up-to-date with the release of new extensions I recommend to regularly check the site `ggplot2 Extensions' (maintained by Daniel Emaasit) at \url{https://www.ggplot2-exts.org/}.

In contrast with previous chapters, I expect readers to first browse through the whole chapter looking to get an idea of what is possible and cherry pick the sections they find useful and worth of detailed study. Some of the packages are generally useful, but others are more specialized. I have tried to cover a wide array of plot types, but, I have described in more depth packages that I have written myself, or that I am more familiar with---i.e.\ the space dedicated to each package description is not to be taken as a measure of their usefulness for your own work.

\begin{warningbox}
  In this chapter we use mostly the modernized data frames of package \pkgname{tibble}. The main reason is that the \Rfunction{tibble()} constructor does not by default convert character variables into factors as the \Rfunction{data.frame()} constructor does. The format used for printing is also improved. It is possible to use \Rfunction{data.frame()} instead of \Rfunction{tibble()} in the examples below, but in some cases you will need to add \code{stringsAsFactors = FALSE} to the call.
\end{warningbox}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(tibble)
library(ggplot2)
library(showtext)
library(viridis)
library(pals)
library(ggrepel)
library(ggforce)
library(ggpmisc)
library(ggseas)
library(gganimate)
library(ggstance)
library(ggbiplot)
library(ggalt)
library(ggExtra)
# library(ggfortify) # loaded later
library(ggnetwork)
library(geomnet)
# library(ggradar)
library(ggsci)
library(ggthemes)
library(xts)
library(MASS)
@

We set a font larger size than the default
<<>>=
theme_set(theme_grey(14))
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\section[`showtext']{\pkgname{showtext}}\label{sec:plot:fonts}

<<>>=
citation(package = "showtext")
@

Package \pkgname{showtext}\index{plots!text in}\index{plots!fonts} allows portable use of different system fonts or fonts from Google in plots created with ggplot.

A font with Chinese characters is included in the package. This example is borrowed from the package vignette, but modified to use default fonts, of which \code{"wqy-microhei"} is a Chinese font included by package \pkgname{showtext}.

<<showtext-0, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, family = "wqy-microhei", size = 12,
             label = "\u4F60\u597D\uFF0C\u4E16\u754C") +
    annotate("text", 1, 0.9, label = 'Chinese for "Hello, world!"',
             family = "sans", fontface = "italic", size = 8)
@

Next we load some system fonts, the same we are using for the text of this book. Within code chunks when using \pkgname{knitr} we can enable \code{showtext} with chunk option \code{fig.showtext = TRUE} as done here (but not visible). In a script or at the console we can use \Rfunction{showtext.auto()}, or \Rfunction{showtext.begin()} and \Rfunction{showtext.end()}. As explained in the package vignette, using \code{showtext} can increase the size of the PDF files created, but on the other hand, it makes embedding of fonts unnecessary.

Function \Rfunction{font.families()} lists the fonts known to R, and function \Rfunction{font.add()} can be used to make \emph{system fonts} visible to R. We set families, and indicate the font names for each \emph{face}.

<<showtext-1>>=
font.families()

font.add(family = "Lucida.Sans",
         regular = "LucidaSansOT.otf",
         italic = "LucidaSansOT-Italic.otf",
         bold = "LucidaSansOT-Demi.otf",
         bolditalic = "LucidaSansOT-DemiItalic.otf")

font.add(family = "Lucida.Bright",
         regular = "LucidaBrightOT.otf",
         italic = "LucidaBrightOT-Italic.otf",
         bold = "LucidaBrightOT-Demi.otf",
         bolditalic = "LucidaBrightOT-DemiItalic.otf")

font.families()
@

We can then select these fonts in the usual way.

<<showtext-1a, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, label = 'Lucida Bright Demi "Hello, world!"',
             family = "Lucida.Bright", fontface = "bold", size = 6) +
    annotate("text", 1, 0.9, label = 'Lucida Sans Italic "Hello, world!"',
             family = "Lucida.Sans", fontface = "italic", size = 6)
@

<<showtext-2, fig.showtext=TRUE>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust=1.5, family = "Lucida.Sans", fontface = "italic") +
  geom_point()
@

<<showtext-3, fig.showtext=TRUE>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust=1.5, family = "Lucida.Bright") +
  geom_point()
@

The examples that follow, using function \Rfunction{font.add.google()} to add Google fonts, are more portable. This is so because as long as internet access is available, fonts can be downloaded if not available locally. You can browse the available fonts at \url{https://fonts.google.com/}. The names used in the statements below are those under which the fonts are listed.

<<showtext-4, cache = FALSE>>=
## Loading Google fonts (http://www.google.com/fonts)
font.add.google(name = "Permanent Marker", family = "Marker")
font.add.google(name = "Courgette")
font.add.google(name = "Lato")
@

<<showtext-5, fig.showtext=TRUE>>=
ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
    theme(axis.title = element_blank(), axis.ticks = element_blank(),
          axis.text = element_blank()) +
    annotate("text", 1, 1.1, label = 'Courgette "Hello, world!"',
             family = "Courgette", size = 6) +
    annotate("text", 1, 0.9, label = 'Permanent Marker "Hello, world!"',
             family = "Marker", size = 6)
@

In all the examples above we used \Rfunction{geom\_text()}, but \Rfunction{geom\_label()} can be used similarly. In the case of the title, axis-labels, tick-labels, and similar components the use of fonts is controlled through the theme. Here we change the base family used. Please, see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes} for examples of how to set the \code{family} for individual elements of the plot.

<<showtext-6, fig.showtext=TRUE>>=
font.add.google(name = "Lora", regular.wt = 400, bold.wt = 700)
font.families()

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(vjust = -1.2,
            family = "Lora",
            fontface = "bold",
            size = 8) +
  geom_point() +
  theme_classic(base_size = 15, base_family = "Lora")
@

\begin{warningbox}
Be aware that in \emph{geometries} the equivalent of \code{face} in theme text elements is called \code{fontface}, while the character string values they accept are the same.
\end{warningbox}

\section[`viridis']{\viridis}\label{sec:plot:viridis}

<<>>=
citation(package = "viridis")
@

Package \viridis defines color palettes\index{plots!color palettes} and fill\index{plots!scales!fill} and color\index{plots!scales!color} scales with colour selected based on human perception, with special consideration of visibility for those with different kinds of color blindness and well as in grey-scale reproduction.


<<viridis-00>>=
set.seed(56231)
my.data <- tibble(x = rnorm(500),
             y = c(rnorm(250, -1, 1), rnorm(250, 1, 1)),
             group = factor(rep(c("A", "B"), c(250, 250))) )
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

Using \Rfunction{scale\_fill\_viridis()} replaces the default palette.

<<viridis-01>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis()
@

Function \Rfunction{scale\_fill\_viridis()} supports several different palettes, which can be selected through an argument passed to parameter \code{option}.

<<viridis-02>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "magma")
@

<<viridis-03>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "inferno")
@

<<viridis-04>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "plasma")
@

<<viridis-05>>=
ggplot(my.data, aes(x, y)) +
  geom_bin2d(bins = 8) +
  facet_wrap(~group) +
  scale_fill_viridis()
@

<<viridis-06>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 8) +
  facet_wrap(~group) +
  scale_fill_viridis()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`pals']{\pkgname{pals}}\label{sec:plot:pals}
\index{plots!color palettes}\index{color palettes}
<<>>=
citation(package = "pals")
@

Package \pkgname{pals}\index{plots!color palettes}\index{color palettes}\index{color maps} fulfils a very specific role: it provides definitions for palettes and color maps, and also palette evaluation tools. Being a specialized package, we describe it briefly and recommend readers to read the vignette and other documentation included with the package.

We modify some of the examples from the previous section to show how to use the palettes and colormaps defined in this package.

<<pals-00>>=
set.seed(56231)
my.data <- tibble(x = rnorm(500),
             y = c(rnorm(250, -1, 1), rnorm(250, 1, 1)),
             group = factor(rep(c("A", "B"), c(250, 250))) )
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

First we simply reproduce the first example obtaining the same plot as by use of \Rfunction{scale\_fill\_viridis()}.

<<pals-01>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_gradientn(colours = viridis(100), guide = "colourbar")
@

The biggest advantage is that we can in the same way use any of the very numerous colormaps and palettes, and choose how smooth a color map we use.

<<pals-02>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_gradientn(colours = viridis(10), guide = "colourbar")
@

We can compare different colormaps with \Rfunction{pal.bands()}. In this example we compare those included in package \pkgname{viridis} with some of the other palettes defined in package \pkgname{pals}.

<<pals-03>>=
pal.bands(viridis, magma, inferno, plasma, coolwarm, tol.rainbow, parula)
@

How does the luminance of the red, green and blue colour channels vary along the palette or color map gradient? We can see this with \Rfunction{pal.channels()}.

<<pals-04>>=
pal.channels(viridis, main = "viridis")
@

How would \code{viridis} look in monochrome, and to persons with different kinds of color blindness? We can see this with \Rfunction{pal.safe()}.

<<pals-05>>=
pal.safe(viridis, main = "viridis")
@

A brief example with a discrete palette follows using \Rfunction{tol()}.

<<pals-10>>=
ggplot(data = mtcars,
    aes(x = disp, y = mpg, color = factor(cyl))) +
    geom_point() +
    scale_color_manual(values = tol(n = 3))
@

Parameter \code{n} gives the number of discrete values in the palette. Discrete palettes have a maximum value for \code{n}, in the case of tol, 12 discrete steps.

<<pals-11>>=
pal.bands(tol(n = 3), tol(n = 6), tol())
@

\begin{playground}
Play with the argument passed to \code{n} to test what happens when the number of values in the scale is smaller or larger than the number of levels of the factor mapped to the color \emph{aesthetic}.
\end{playground}

Is this palette safe?

<<pals-12>>=
pal.safe(tol(n = 3))
@

\begin{playground}
Explore the available palettes until you find a nice one that is also safe with three steps. Be aware that color maps, like \Rfunction{viridis()} can be used to define a discrete color scale using \Rfunction{scale\_color\_manual()} in exactly the same way as palettes like \Rfunction{tol()}. Colormaps, however, may be perceived as gradients, rather than un-ordered discrete categories, so care is needed.
\end{playground}

\section[`gganimate']{\pkgname{gganimate}}\label{sec:plot:gganimate}
\index{plots!animation}
<<>>=
citation(package = "gganimate")
@

Package \pkgname{gganimate}\index{plots!animation} allows the use of package \pkgname{animation} in ggplots with a syntax consistent with the grammar of graphics. It adds a new aesthetic \code{frame}, which can be used to map \emph{groups} of data to \emph{frames} in the animation.

Use of the package is extremely easy, but installation can be somehow tricky because of system requirements. Just, make sure to have \pgrmname{ImageMagick} installed and included in the search \code{PATH}.

We modify an example from section \ref{sec:simple:points:lines} on page \ref{sec:simple:points:lines}. We add the \code{frame} aesthetic to the earlier figure.
<<gganimate-1>>=
p <- ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl), frame  = cyl)) +
  geom_point()
@

Now we can print \code{p} as a normal plot, with \Rfunction{print()}, here called automatically.

<<gganimate-2>>=
p
@

Or display an animation with \Rfunction{gganimate()} (Renamed from \Rfunction{gg\_animate()} in package version > 0.1.0). The animation will look differently depending on the output format, and the program used for viewing it. For example, in this PDF files, the animation will work when viewed with Adobe Viewer or Adobe Acrobat but not in Sumatra PDF viewer. We add \code{title\_frame = FALSE} as a title does not seem useful in this simple animation.

<<gganimate-3, fig.show='animate'>>=
gganimate(p, title_frame = FALSE)
@

Or save it to a file.

<<gganimate-4, eval = FALSE>>=
gganimate(p, "p-animation.gif")
@

Cumulative animations are also supported. We here use the same example with three frames, but this type of animation is particularly effective for time series data. To achieve this we only need to add \code{cumulative = TRUE} to the aesthetics mappings.

<<gganimate-1a>>=
p <- ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl),
           frame  = cyl, cumulative = TRUE)) +
  geom_point()
@

Now we can print \code{p} as a normal plot,

<<gganimate-2a>>=
p
@

Or display an animation with \Rfunction{gganimate()}. The animation will look differently depending on the output format, and the program used for viewing it. For example, in this PDF files, the animation will work when viewed with Adobe Viewer or Adobe Acrobat but in Sumatra PDF viewer.

<<gganimate-3a, fig.show='animate'>>=
gganimate(p, title_frame = FALSE)
@

\section[`ggstance']{\pkgname{ggstance}}\label{sec:plot:ggstance}
\index{plots!horizontal geometries}
\index{plots!horizontal statistics}
\index{plots!horizontal positions}
\index{plots!geometries!barh}
\index{plots!geometries!histogramh}
\index{plots!geometries!linerangeh}
\index{plots!geometries!pointrangeh}
\index{plots!geometries!errorbarh}
\index{plots!geometries!crossbarh}
\index{plots!geometries!boxploth}
\index{plots!geometries!violinh}
\index{plots!statistics!binh}
\index{plots!statistics!boxploth}
\index{plots!statistics!counth}
\index{plots!statistics!xdensity}
\index{plots!positions!dodgev}
\index{plots!positions!nudgev}
\index{plots!positions!fillv}
\index{plots!positions!stackv}
\index{plots!positions!jitterdodgev}
<<>>=
citation(package = "ggstance")
@

Package \pkgname{ggstance} defines horizontal versions of common ggplot \emph{geometries}, \emph{statistics} and \emph{positions}. Although \ggplot defines \code{coord\_flip}, \pkgname{ggstance} provides a more intuitive user interface and more consistent plot formatting.

\sloppy
Currently the package defines \textbf{horizontal} \emph{geoms} \Rfunction{geom\_barh()}, \Rfunction{geom\_histogramh()}, \Rfunction{geom\_linerangeh()}, \Rfunction{geom\_pointrangeh()}, \Rfunction{geom\_errorbarh()}, \Rfunction{geom\_crossbarh()}, \Rfunction{geom\_boxploth()}, and \Rfunction{geom\_violinh()}. It also defines
\textbf{horizontal} \emph{stats} \Rfunction{stat\_binh()}, \Rfunction{stat\_boxploth()}, \Rfunction{stat\_counth()}, and \Rfunction{stat\_xdensity()} and \textbf{vertical} \emph{positions} \code{position\_dodgev}, \code{position\_nudgev}, \code{position\_fillv}, \code{position\_stackv}, and \code{position\_jitterdodgev}.

We will give give only a couple of examples, as their use has no surprises. First we make horizontal versions of the histogram plots shown in section \ref{sec:histogram} on page \pageref{sec:histogram}.

<<>>=
set.seed(12345)
my.data <- tibble(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

\index{plots!histogram!horizontal}
<<>>=
ggplot(my.data, aes(y = x)) +
  geom_histogramh(bins = 15)
@

<<>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "dodgev")
@

<<>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "stackv")
@

<<>>=
ggplot(my.data, aes(y = y, fill = group)) +
  geom_histogramh(bins = 15, position = "identity", alpha = 0.5) +
  theme_bw(16)
@

Now we make an horizontal version of the boxplot shown in section \ref{sec:boxplot} on page \pageref{sec:boxplot}.
\index{plots!box and whiskers plot!horizontal}

<<>>=
ggplot(my.data, aes(y, group)) +
  geom_boxploth()
@

\section[`ggbiplot']{\pkgname{ggbiplot}}\label{sec:plot:ggbiplot}
\index{plots!principal components}
<<>>=
citation(package = "ggbiplot")
@

Package \pkgname{ggbiplot}\index{plots!principal components} defines two functions, \Rfunction{ggscreeplot()} and \Rfunction{ggbiplot()}. These functions make it easy to nicely print the results from principal components analysis done with \Rfunction{prcomp()}.

For the time being we reproduce an example from the package README.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<ggbiplot-1>>=
data(wine)
wine.pca <- prcomp(wine, scale. = TRUE)
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
  groups = wine.class, ellipse = TRUE, circle = TRUE) +
  scale_color_discrete(name = '') +
  theme(legend.direction = 'horizontal', legend.position = 'top')
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`ggalt']{\pkgname{ggalt}}\label{sec:plot:ggalt}
\index{plots!lollipop plot}
\index{plots!dumbell plot}
\index{plots!step ribbon plot}
\index{plots!scales!fill}
\index{plots!formatters!byte}
\index{plots!geometries!lollipop}
\index{plots!geometries!dumbbell}
\index{plots!geometries!step ribbon}
\index{plots!geometries!stateface}
\index{plots!geometries!encircle}
\index{plots!geometries!step ribbon}
<<>>=
citation(package = "ggalt")
@

Package \pkgname{ggalt} defines \emph{geoms} \Rfunction{geom\_xspline()}, \Rfunction{geom\_bkde()}, \Rfunction{geom\_bkde2d()}, \Rfunction{geom\_stateface()}, \Rfunction{geom\_encircle()}, \Rfunction{geom\_lollipop()}, \Rfunction{geom\_dumbbell()}, and \Rfunction{geom\_stepribbon()}; \emph{stats} \Rfunction{stat\_xspline()}, \Rfunction{stat\_bkde()}, \Rfunction{stat\_bkde2d()}, and \Rfunction{stat\_ash()}; \emph{scale} \Rfunction{scale\_fill\_pokemon()}; \emph{formatter} \Rfunction{byte\_format()}.

The highlights are use of functions from package 'KernSmooth' for density estimation, the provision of \emph{X-splines} and for formatting ``bytes'' in the usual way used when describing computer memory.

First\index{plots!statistics!x-spline}\index{plots!geometries!x-spline}\index{plots!smooth curves}
 example is the use of \emph{x-splines} which are very flexible splines that are smooth (have a continuous first derivative). They can be tuned from interpolation (passing through every observation) to being rather ``stiff'' smoothers.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggalt-1>>=
set.seed(1816)
dat <- tibble(x=1:10,
                  y=c(sample(15:30, 10)))
@

<<ggalt-2>>=
ggplot(dat, aes(x, y)) +
  geom_point() +
  geom_xspline()
@

The "flexibility" of the spline can be adjusted by passing an \code{numeric} argument to parameter \code{spline\_shape}.

<<ggalt-3>>=
ggplot(dat, aes(x, y)) +
  geom_point() +
  geom_xspline(spline_shape=0.4)
@

We also redo some of the density\index{plots!density plot!1 dimension}
\index{plots!density plot!2 dimensions}
 plot examples from \ref{sec:plot:density} on page \pageref{sec:plot:density}.

<<ggalt-4>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_bkde(alpha = 0.5)
@

<<ggalt-5>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_bkde2d()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggalt-6>>=
ggplot(my.data, aes(x, y)) +
    geom_bkde2d() +
    facet_wrap(~group)
@

We here use a scale from package \pkgname{viridis} described in section \ref{sec:plot:viridis} on page \pageref{sec:plot:viridis}.

<<ggalt-7>>=
ggplot(my.data, aes(x, y)) +
    stat_bkde2d(aes(fill = ..level..), geom = "polygon") +
    facet_wrap(~group) +
    scale_fill_viridis()
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[`ggExtra']{\pkgname{ggExtra}}\label{sec:plot:ggExtra}

Sometimes it is useful to add marginal plots\index{plots!marginal}\index{marginal plots}\index{marginal histograms}\index{marginal density plots} to a \Rclass{ggplot}. Package \pkgname{ggExtra} provides this functionality through an easy to use interface.

<<>>=
citation(package = "ggExtra")
@

<<ggextra-00>>=
set.seed(12345)
    my.data <-
    data.frame(x = rnorm(200),
    y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
    group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<ggextra-01>>=
p01 <- ggplot(my.data, aes(x, y)) +
            geom_point()
@

<<ggextra-02>>=
ggMarginal(p01)
@

<<ggextra-03>>=
ggMarginal(p01, type = "histogram", margins = "x", size = 3)
@

\begin{playground}
Read the documentation for \Rfunction{ggMarginal()} and play by changing the aesthetics used for the lines and bars on the margins.
\end{playground}

\begin{infobox}
At the time of writing, \Rfunction{ggMarginal()} does not support grouping or facets. Both of these features would be very useful quite frequently, but this needs to be done manually, using the facilities of package \pkgname{gridExtra} to combine and align ggplots created individually. Grouping is ignored. Facets in the plot passed as argument trigger fatal errors when \Rfunction{ggMargins()} is exectuted.

<<ggextra-11>>=
p02 <- ggplot(my.data, aes(x, y, color = group)) +
            geom_point()
@

<<ggextra-12>>=
ggMarginal(p02, margins = "x")
@

\end{infobox}

\section[`ggfortify']{\pkgname{ggfortify}}\label{sec:plot:ggfortify}

<<>>=
# interferes with 'ggbiplot'
library(ggfortify)
@

<<>>=
citation(package = "ggfortify")
@

Package \pkgname{fortify}\index{plots!fitted models} re-organizes the output from different model fitting functions into an easier to handle and more consistent format that is especially useful when collecting the results from different fits. Package \pkgname{ggfortify} extends this idea to encompass the creation of diagnostic and other plots from model fits using \pkgname{ggplot2}. The most important method to remember is \Rfunction{autoplot()} for which many different specializations are provided. As the returned objects are of class \code{"ggplot"}, it is easy to add additional layers and graphical elements to them.

We start with a linear model as example. We return to the regression example used in Chapter \ref{chap:R:functions}, page \pageref{xmpl:fun:lm:fm1}.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<ggfortify-01>>=
fm1 <- lm(dist ~ speed, data=cars)
@

<<ggfortify-02>>=
autoplot(fm1)
@

And here the example used for ANOVA on page \pageref{xmpl:fun:lm:fm4}.

<<ggfortify-03>>=
fm4 <- lm(count ~ spray, data = InsectSprays)
@

<<ggfortify-04>>=
autoplot(fm4)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

There is also an \Rfunction{autoplot()} especialization for time series data.

<<ggfortify-11>>=
autoplot(lynx)
@

Please, see section \ref{sec:plot:ggpmisc} for an alternative approach, slightly less automatic, but based on a specialization of the \Rfunction{ggplot()} method.

\section[`ggnetwork']{\pkgname{ggnetwork}}\label{sec:plot:ggnetwork}

<<>>=
citation(package = "ggnetwork")
@

Package \pkgname{ggnetwork}\index{plots!network graphs}\index{network graphs} provides methods and functions to plot network graphs with \ggplot, which are a rather specialized type of plots. This package contains a very nice vignette with many nice examples, so in this section I will only provide some examples to motivate the readers to explore the package documentation and use the package. This package allows very flexible control of the graphical design.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<ggnetwork-01>>=
data(blood, package = "geomnet")
@

Using mostly defaults, the plot is not visually attractive. For the layout to be deterministic, we need to set the seed used by the pseudorandom number generator. To assemble the plot we add three layers of data with \Rfunction{geom\_edges()}, \Rfunction{geom\_nodes()} and \Rfunction{geom\_nodetext()}. We use \Rfunction{theme\_blank()} as axes and their labels play no function in a plot like this.

<<ggnetwork-02>>=
set.seed(12345)
ggplot(ggnetwork(network::network(blood$edges[, 1:2]),
       layout = "circle"),
       aes(x, y, xend = xend, yend = yend)) +
    geom_edges() +
    geom_nodes() +
    geom_nodetext(aes(label = vertex.names)) +
    theme_blank()
@

Some tweaking of the \emph{aesthetics} leads to a nicer plot.

<<ggnetwork-03>>=
set.seed(12345)
ggplot(ggnetwork(network::network(blood$edges[, 1:2]),
       layout = "circle", arrow.gap = 0.06),
       aes(x, y, xend = xend, yend = yend)) +
    geom_edges(color = "grey30",
               arrow = arrow(length = unit(6, "pt"), type = "open")) +
    geom_nodes(size = 16, color = "darkred") +
    geom_nodetext(aes(label = vertex.names), color = "white") +
    theme_blank()
@

\begin{playground}
How does the layout change if you change the argument passed to \Rfunction{set.seed()}? And what happens with the layout if you run the plotting statement more than once, without calling \Rfunction{set.seed()}?
\end{playground}

\begin{playground}
What happens if you change the order of the \code{geom}s in the code above? Experiment by editing and running the code to find the answer, or if you think you know the answer, to check whether you guess was right or wrong.
\end{playground}

\begin{playground}
Change the graphic design of the plot in steps, by changing: 1) the shape of the nodes, 2) the color of the nodes, 3) the size of the nodes and the size of the text, 4) the type of arrows and their size, 5) the font used in nodes to italic.
\end{playground}

\begin{infobox}
This is not the only package supporting the plotting of network graphs with package \ggplot. Packages \pkgname{GGally} and \pkgname{geomnet} support network graphs. Package \pkgname{ggCompNet} compares the three methods, both for performance and by giving examples of the visual design.
\end{infobox}

\section[`geomnet']{\pkgname{geomnet}}\label{sec:plot:geomnet}

<<>>=
citation(package = "geomnet")
@

Package \pkgname{geomnet}\index{plots!network graphs}\index{network graphs} provides methods and functions to plot network graphs with \ggplot, which are a rather specialized type of plots.

<<geomnet-01>>=
data(blood, package = "geomnet")
@

Using mostly defaults, the plot is very simple, and lacks labels. As above, for the layout to be deterministic, we need to set the seed. In the case of \pkgname{geomnet}, new \emph{aesthetics} \code{from\_id} and \code{to\_id} are defined, only one layer is needed, added with \Rfunction{geom\_net()}. We use here \Rfunction{theme\_net()}, also exported by this package.

<<geomnet-02>>=
set.seed(12345)
ggplot(data = blood$edges, aes(from_id = from, to_id = to)) +
  geom_net() +
  theme_net()
@

Some tweaking of the \emph{aesthetics} leads to a nicer plot, equivalent to the second example in the previous section.

<<geomnet-03>>=
set.seed(12345)
ggplot(data = blood$edges, aes(from_id = from, to_id = to)) +
  geom_net(colour = "darkred", layout.alg = "circle", labelon = TRUE, size = 16,
           directed = TRUE, vjust = 0.5, labelcolour = "white",
           arrow = arrow(length = unit(6, "pt"), type = "open"),
           linewidth = 0.5, arrowgap = 0.06,
           selfloops = FALSE, ecolour = "grey30") +
  theme_net()
@

\begin{playground}
Change the graphic design of the plot in steps, by changing: 1) the shape of the nodes, 2) the color of the nodes, 3) the size of the nodes and the size of the text, 4) the type of arrows and their size, 5) the font used in nodes to italic.
\end{playground}

%\section[ggradar]{\pkgname{ggradar}}\label{sec:plot:ggradar}
%
%<<>>=
%citation(package = "ggradar")
%@
%
%Package \pkgname{ggradar} allows the creation of radar plots with \pkgname{ggplot2}. However, its user interface does not follow the grammar of graphics paradigm.


\section[`ggforce']{\pkgname{ggforce}}\label{sec:plot:ggforce}

<<>>=
citation(package = "ggforce")
@

Package \pkgname{ggforce} includes an assortment of useful extensions to \pkgname{ggplot2}.

\subsection{Geoms and stats}
\index{plots!sina plot}\index{plots!geometries!sina}
Sina plots are a new type of plots resembling violin plots (described in section \ref{sec:plot:violin} on page \pageref{sec:plot:violin}), where actual observations are plotted as a cloud spreading widely as the density increases. Both a \emph{geometry} and a \emph{statistics} are defined.

<<>>=
set.seed(12345)
my.data <-
  data.frame(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

Sina plots can obtained with \Rfunction{geom\_sina()}.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_sina()
@

<<>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_sina()
@

The \emph{geometries} \Rfunction{geom\_sina()} and \Rfunction{geom\_violin()} can be combined to create attractive and informative plots. As with any \Rclass{ggplot} varying the order of the layers and their transparency (\code{alpha}) can be used to obtain plots where one or the other \emph{geometry} is highlighted.

<<>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_sina(alpha = 0.33)
@

\index{plots!arcs, curves and circles}\index{plots!Bezier curves}\index{plots!b-splines}%
\index{plots!geometries!circle}\index{plots!geometries!arc}\index{plots!geometries!arcbar}%
\index{plots!geometries!bezier}\index{plots!geometries!bspline}

Several \emph{geometries} for plotting arcs, curves and circles also provided: \Rfunction{geom\_circle()}, \Rfunction{geom\_arc()}, \Rfunction{geom\_arcbar()}, \Rfunction{geom\_bezier()}, \Rfunction{geom\_bspline()}.

coming soon.

\index{plots!geometries!link}\index{plots!geometries!link2}\index{plots!interpolation}
\emph{Geometries} similar to \Rfunction{geom\_path()} and \Rfunction{geom\_segment()}, called \Rfunction{geom\_link()} and \Rfunction{geom\_link2()} add interpolation of \emph{aesthetics} along the segment or path between each pair of observations/points.

coming soon.

\subsection{Transformations}
\index{plots!transformations!reverser}
\code{trans\_reverser} can be used to reverse any monotonic transformation.
\index{plots!transformations!power}\index{plots!transformations!radial}
New transformations \Rfunction{power\_trans()} and \Rfunction{radial\_trans()}

coming soon.

\subsection{Theme}
\index{plots!themes!no axes}

\Rfunction{theme\_no\_axes()} is not that useful for a sina plot, but could be used to advantage for raster images or maps. It differs from \Rfunction{theme\_blank()} and \Rfunction{theme\_null()} in the plot being framed and having a white plotting area.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_sina() +
  theme_no_axes()
@

\subsection{Paginated facetting}
\index{plots!facets!pagination}
\index{plots!facets!zooming}
\Rfunction{facet\_grid\_paginate()}, \Rfunction{facet\_wrap\_paginate()} and \Rfunction{facet\_zoom()} add pagination to usual faceting, allowing one to split large faceted plots into pages, and zooming into individual panel in a facetted plot.

coming soon.

\section[`ggpmisc']{\ggpmisc}\label{sec:plot:ggpmisc}

<<>>=
citation(package = "ggpmisc")
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

\sloppy
Package \ggpmisc is a package developed by myself as a result of questions from work mates and in Stackoverflow, or functionality that I have needed in my own research or for teaching. It provides new stats for everyday use: \Rfunction{stat\_peaks()}, \Rfunction{stat\_valleys()}, \Rfunction{stat\_poly\_eq()}, \Rfunction{stat\_fit\_glance()}, \Rfunction{stat\_fit\_deviations()}, and \Rfunction{stat\_fit\_augment()}. A function for converting time-series data to a data frame that can be easily plotted with `ggplot2'. It also provides some debugging tools that echo the data received as input: \Rfunction{stat\_debug\_group()}, \Rfunction{stat\_debug\_panel()}, and \Rfunction{geom\_debug()}, and \Rfunction{geom\_null()} that does not plot its input.

\subsection{Plotting time-series}
\index{plots!time series}
\index{time series!conversion into data frame}
\index{time series!conversion into tibble}
Instead of creating a new statistics or geometry for plotting time series we provide a function that can be used to convert time series objects into data frames suitable for plotting with \ggplot. A single function \Rfunction{try\_tibble()} (also available as \\Rfunction{try\_data\_frame()}) accepts time series objects saved with different packages as well as R's native \code{ts} objects. The \textit{magic} is done mainly by package \xts to which we add a wrapper to obtain a data frame. By default the time variable is given name \code{time} and that with observations, the ``name'' of the data argument passed. In the usual case of passing a time series object, its name is used for the variable.

We exemplify this with some of the time series data included in R. In the first example we use the default format for time.

<<>>=
ggplot(try_tibble(austres), aes(time, austres)) +
  geom_line()
@

In the second example we use ``decimal years'' in numeric format for expressing `time'.

<<>>=
ggplot(try_tibble(lynx, as.numeric = TRUE),
       aes(x = time, y = lynx)) +
  geom_line()
@

Here we use dates rounded to the month.

<<>>=
ggplot(try_tibble(AirPassengers, "month"),
       aes(time, AirPassengers)) +
  geom_line()
@

Multivariate time series are also supported.

Plotting can be automated even further for \code{"ts"} and \code{"xts"} with the specialized \Rclass{ggplot} methods defined by package \pkgname{ggpmisc}. The same parameters as in \

<<>>=
ggplot(AirPassengers) +
  geom_line()
@

These methods default to using ``decimal time'' for \code{time} as not all \emph{statistics} (i.e.\ from package \pkgname{ggseas}) work correctly with \code{POSIXct}. Passing \code{FALSE} as argument \code{as.numeric} results in \code{time} being returned as a datetime variable. This allows use of \ggplot's time scales.

<<>>=
ggplot(AirPassengers, as.numeric = FALSE) +
  scale_x_datetime(date_breaks = "1 year", date_labels = "%Y") +
  geom_line()
@

\subsection{Peaks and valleys}
\index{plots!statistics!peaks@peaks}
\index{plots!statistics!valleys@valleys}
Peaks and valleys are local (or global) maxima and minima. These stats return the $x$ and $y$ values at the peaks or valleys plus suitable labels, and default aesthetics that make easy their use with several different geoms, including \Rfunction{geom\_point()}, \Rfunction{geom\_text()}, \Rfunction{geom\_label()}, \Rfunction{geom\_vline()}, \Rfunction{geom\_hline()} and \Rfunction{geom\_rug()}, and also with geoms defined by package \ggrepel. Some examples follow.

There are many cases, for example in physics and chemistry, but also when plotting time-series data when we need to automatically locate and label local maxima (peaks) or local minima (valleys) in curves. The statistics presented here are useful only for dense data as they do not fit a peak function but instead simply search for the local maxima or minima in the observed data. However, they allow flexible generation of labels on both $x$ and $y$ peak or valley coordinates.

We use as example the same time series as above. In the next several examples we demonstrate some of this flexibility.

<<>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
               vjust = 1.5, x.label.fmt = "%4.0f") +
  ylim(-100, 7300)
@

<<>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  ylim(NA, 7300)

@

<<>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue")
@

<<>>=
ggplot(lynx) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             hjust = -0.1, label.fmt = "%4.0f",
             angle = 90, size = 2.5,
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
             hjust = -0.1, label.fmt = "%4.0f",
             angle = 90, size = 2.5,
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  ylim(NA, 10000)
@

Using POSIXct for `time` but supplying a format string, to show only the month corresponding to each peak or valley. Any format string accepted by \Rfunction{strftime()} can be used.

<<>>=
ggplot(AirPassengers, as.numeric = FALSE) + geom_line() +
  stat_peaks(colour = "red", span = 9) +
  stat_peaks(geom = "text", span = 9, colour = "red", hjust = -0.5,
             angle = 90, x.label.fmt = "%b") +
  stat_valleys(colour = "blue", span = 9) +
  stat_valleys(geom = "text", span = 9, colour = "blue", hjust = 1.5,
               angle = 90, x.label.fmt = "%b") +
  scale_x_datetime(date_breaks = "1 year", date_labels = "%Y") +
  ylim(-50, 700)
@

Rotating the labels.

<<>>=
ggplot(lynx, as.numeric = FALSE) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", angle = 66,
             hjust = -0.1, x.label.fmt = "%Y") +
  ylim(NA, 7800)
@

Of course, if one finds use for it, the peaks and/or valleys can be plotted on their own. Here we plot an "envelope" using \Rfunction{geom\_line()}.

<<>>=
ggplot(AirPassengers) +
  geom_line() +
  stat_peaks(geom = "line", span = 9, linetype = "dashed") +
  stat_valleys(geom = "line", span = 9, linetype = "dashed")
@

\subsection{Equations as text or labels in plots}
\index{plots!fitted curves!equation annotation}
\index{plots!annotations!fitted model labels}
<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

How to add a label with a polynomial equation including coefficient estimates from a model fit seems to be a frequently asked question in Stackoverflow. The parameter estimates are extracted automatically from a fit object corresponding to each \textit{group} or panel in a plot and other aesthetics for the group respected. An aesthetic is provided for this, and only this. Such a statistics needs to be used together with another geom or stat like geom smooth to add the fitted line. A different approach, discussed in Stackoverflow, is to write a statistics that does both the plotting of the polynomial and adds the equation label. Package \ggpmisc defines \Rfunction{stat\_poly\_eq()} using the first approach which follows the `rule' of using one function in the code for a single action. In this case there is a drawback that the users is responsible for ensuring that the model used for the label and the label are the same, and in addition that the same model is fitted twice to the data.

We first generate some artificial data.

<<>>=
set.seed(4321)
# generate artificial data
x <- 1:100
y <- (x + x^2 + x^3) +
  rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data <- tibble(x, y,
                  group = rep(c("A", "B"), 50),
                  y2 = y * c(0.5,2))
@

\subsubsection{Linear models}

This section shows examples of linear models with one independent variables, including different polynomials.
We first give an example using default arguments.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(formula = formula, parse = TRUE)
@

The default \emph{geometry} used by the \emph{statistic} is \Rfunction{geom\_text()} but it is possible to use \Rfunction{geom\_label()} instead when the intention is to have a color background for the label. The default background \code{fill} is white but this can also changed in the usual way by mapping the \code{fill} \emph{aesthetic}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label", formula = formula, parse = TRUE)
@

It is also possible to create a semi-transparent text background by use of the \code{alpha} \emph{aesthetic}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label", alpha = 0.3, formula = formula, parse = TRUE)
@

The \Rfunction{geom\_label\_repel()} accepts the same arguments as \Rfunction{geom\_label()} for controlling the format of the box and border. We give a simple example here. For other examples see page \pageref{par:plot:label}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(geom = "label",
               label.size = NA,
               label.r = unit(0, "lines"),
               color = "white",
               fill = "grey10",
               formula = formula, parse = TRUE) +
  theme_bw()
@

The remaining examples in this section use the default \Rfunction{geom\_text()} but can be modified to use \Rfunction{geom\_label()} as shown above.

\Rfunction{stat\_poly\_eq()} makes available five different labels in the returned data frame. $R^2$, $R_\mathrm{adj}^2$, AIC, BIC and the polynomial equation. $R^2$ is used by default, but \Rfunction{aes()} can be used to select a different one.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..adj.rr.label..),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
  ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..AIC.label..),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

Within \Rfunction{aes()} it is possible to \textit{compute} new labels based on those returned plus ``arbitrary'' text. The supplied labels are meant to be \textit{parsed} into R expressions, so any text added should be valid for a string that will be parsed. Here we need to \emph{scape} the quotation marks. See section \ref{sec:plot:plotmath} starting on page \pageref{sec:plot:plotmath} for details on parsing character strings into expressions.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste(..eq.label..,
                                 ..adj.rr.label..,
                                 sep = "*\",\"~~")),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste("atop(", ..AIC.label.., ",",
                                       ..BIC.label.., ")",

                                       sep = "")),
               formula = formula, parse = TRUE)
@

Two examples of removing or changing the \textit{lhs} and/or the \textit{rhs} of the equation. (Be aware that the equals sign must be always enclosed in backticks in a string that will be parsed.)

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(hat(y))~`=`~",
formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  labs(x = expression(italic(z)), y = expression(italic(h)) ) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(h)~`=`~",
               eq.x.rhs = "~italic(z)",
               formula = formula, parse = TRUE)
@

As any valid R expression can be used, Greek letters are also supported, as well as the inclusion in the label of variable transformations used in the model formula.

<<>>=
formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(my.data, aes(x, log10(y + 1e6))) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "plain(log)[10](italic(y)+10^6)~`=`~",
               formula = formula, parse = TRUE)
@

Example of a polynomial of fifth order.

<<>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
formula <- y ~ poly(x, 5, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@


<<>>=
opts_chunk$set(opts_fig_narrow)
@

Intercept forced to zero---line through the origin.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3) - 1
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

We give some additional examples to demonstrate how other components of the \Rclass{ggplot}
object affect the behaviour of this statistic.

Facets work as expected either with fixed or free scales. Although bellow we
had to adjust the size of the font used for the equation.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), # size = 2.8,
               formula = formula, parse = TRUE) +
  facet_wrap(~group)
@

Grouping, in this example using colour aesthetic also works as expected.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE) +
  theme_bw() +
  theme(legend.position = "top")
@

\subsubsection{Other types of models}

Another statistic, \Rfunction{stat\_fit\_glance()} allows lots of flexibility, but at the moment there is no equivalently flexible version of \Rfunction{stat\_smooth()}.

We give an example with a linear model, showing a P-value (a frequent request for which I do not find much use).

We use \Rfunction{geom\_debug()} to find out what values \Rfunction{stat\_glance()} returns for our linear model, and add labels with P-values for the fits.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(aes(label = paste('italic(P)~`=`~', signif(..p.value.., 3), sep = "")),
                  parse = TRUE,
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

We use \Rfunction{geom\_debug()} to find out what values \Rfunction{stat\_glance()} returns for our resistant linear model fitted with \Rfunction{rlm()} from package \pkgname{MASS}.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  method = "rlm",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(aes(label = paste('AIC~`=`~', signif(..AIC.., 3),
                      "~~", 'BIC~`=`~', signif(..BIC.., 3), sep = "")),
                  parse = TRUE,
                  method = "rlm",
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

In a similar way one can generate labels for any fit supported by package \pkgname{broom}.

\subsection{Highlighting deviations from fitted line}
\index{plots!fitted curves!deviations}
\index{plots!fitted curves!residuals}
First an example using default arguments for \Rfunction{stat\_fit\_deviations()}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula)
@

And setting some to the \emph{aesthetics} to non-default values.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula, color = "red",
                      arrow = arrow(length = unit(0.015, "npc"),
                                   ends = "both")) +
  geom_point()
@

Grouping is respected. Here \code{colour} is mapped to the variable \code{group}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula) +
  geom_point()
@

\subsection{Plotting residuals from linear fit}
\index{plots!fitted curves!residuals}

We can plot the residuals by themselves with \Rfunction{stat\_fit\_residuals()}.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = formula)
@

\subsection{Filtering observations based on local density}\label{sec:dens:filter}
\index{plots!filter observations by density}
Statistics \Rfunction{stat\_dens2d\_filter()} works best with clouds of observations, so we generate some random data.

<<>>=
set.seed(1234)
nrow <- 200
my.2d.data <- tibble(
    x = rnorm(nrow),
    y = rnorm(nrow) + rep(c(-1, +1), rep(nrow / 2, 2)),
    group = rep(c("A", "B"), rep(nrow / 2, 2))
   )
@

In most recipes in the section we use \Rfunction{stat\_dens2d\_filter()} to highlight observations with the \code{color} aesthetic. Other aesthetics can also be used.

By default 1/10 of the observations are kept from regions of lowest density.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red")
@

Here we change the fraction to 1/3.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.fraction = 1/3)
@

We can also set a maximum number of observations to keep.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.number = 3)
@

We can also keep the observations from the densest areas instead of the from the sparsest.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE)
@

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE) +
  facet_grid(~group)
@

In addition to \Rfunction{stat\_dens2d\_filter()} there is \Rfunction{stat\_dens2d\_filter\_g()}. The difference is in that the first one computes the density on a plot-panel basis while the second one does it on a group basis. This makes a difference only when observations are grouped based on another aesthetic within each panel.

<<>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter(shape = 1, size = 3)
@

<<>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter_g(shape = 1, size = 3)
@

A related stat \Rfunction{stat\_dens2d\_label()}, also defined in package \ggpmisc is described in section \ref{sec:repel:dens} on page \pageref{sec:repel:dens}.

\subsection{Learning and/or debugging}
\index{plots!debugging}
\index{plots!statistics!debug}
\index{plots!geometries!debug}
A very simple stat named \Rfunction{stat\_debug()} can save the work of adding print statements to the code of stats to get information about what data is being passed to the \Rfunction{compute\_group()} function. Because the code of this function is stored in a \code{ggproto} object, at the moment it is impossible to directly set breakpoints in it. This \Rfunction{stat\_debug()} may also help users diagnose problems with the mapping of aesthetics in their code or just get a better idea of how the internals of \ggplot work.

<<>>=
ggplot(lynx) + geom_line() +
  stat_debug_group()
@

<<>>=
ggplot(lynx,
       aes(time, lynx,
           color = ifelse(time >= 1900, "XX", "XIX"))) +
  geom_line() +
  stat_debug_group() +
  labs(color = "century")
@

By means of \Rfunction{geom\_debug()} it is possible to "print" to the console the data returned by a ggplot \emph{statistic}.

<<>>=
ggplot(mpg, aes(class, hwy, color = class)) +
  geom_point(alpha = 0.2) +
  stat_summary(fun.data = mean_se, size = 0.6)
@

<<>>=
ggplot(mpg, aes(class, hwy, color = class)) +
  geom_debug() +
  stat_summary(fun.data = mean_se,
               geom = "debug", summary.fun = as_tibble, summary.fun.args = list())
@

\section[`ggrepel']{\ggrepel}\label{sec:plot:ggrepel}
\index{plots!text in}
\index{plots!geometries!repulsive text}
\index{plots!geometries!repulsive label}
<<ggrepel-0>>=
citation(package = "ggrepel")
@

Package \ggrepel is under development by Kamil Slowikowski. It does a single
thing, relocates text labels so that they do not overlap. This is achieved through
two geometries that work similarly to those provided by \ggplot except for the
relocation. This is incredibly useful both when labeling peaks and valleys and when
labeling points in scatter-plots. This is a significant problem in bioinformatics
plots and in maps.

\subsection{New geoms}

Package \ggrepel provides two new geoms: \Rfunction{geom\_text\_repel()} and \Rfunction{geom\_label\_repel()}. They are used similarly to \Rfunction{geom\_text()} and \Rfunction{geom\_label()} but the text or labels ``repel'' each other so that they rarely overlap unless the plot is very crowded. The vignette \emph{ggrepel Usage Examples} provides very nice examples of the power and flexibility of these geoms. The algorithm used for avoiding overlaps through repulsion is iterative, and can be slow when the number of labels or observations are in the thousands.

I reproduce here some simple examples from the \ggrepel vignette.

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

Just using defaults, we avoid overlaps among text items on the plot. \Rfunction{geom\_text\_repel()} has some parameters matching those in \Rfunction{geom\_text()}, but those related to manual positioning are missing except for \code{angle}. Several new parameters control both the appearance of text and the function of the repulsion algorithm.

<<ggrepel-01>>=
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(color = 'red') +
  geom_text_repel(aes(label = rownames(mtcars)))
@

The chunk below shows how to change the appearance of labels. \Rfunction{geom\_label\_repel()} is comparable to \Rfunction{geom\_label()}, but with repulsion.

<<ggrepel-02>>=
set.seed(42)
ggplot(mtcars) +
  geom_point(aes(wt, mpg), size = 5, color = 'grey') +
  geom_label_repel(
  aes(wt, mpg, fill = factor(cyl), label = rownames(mtcars)),
      fontface = 'bold', color = 'white',
      box.padding = unit(0.25, "lines"),
      point.padding = unit(0.5, "lines")) +
  theme(legend.position = "top")
@

As with \Rfunction{geom\_label()} we can change the width of the border line, or remove it completely as in the example below, by means of an argument passed through parameter \code{label.size} which defaults to 0.25. Although 0 as argument still results in a thin border line, \code{NA} removes it altogether.

<<ggrepel-03>>=
set.seed(42)
ggplot(mtcars) +
  geom_point(aes(wt, mpg), size = 5, color = 'grey') +
  geom_label_repel(
  aes(wt, mpg, fill = factor(cyl), label = rownames(mtcars)),
      fontface = 'bold', color = 'white',
      box.padding = unit(0.25, "lines"),
      point.padding = unit(0.5, "lines"),
      label.size = NA) +
  theme(legend.position = "top")
@

The parameters \code{nudge\_x} and \code{nudge\_y} allow strengthening or weakening the repulsion force, or favouring a certain direction. We also need to expand the x-axis high limit to make space for the labels.

<<>>=
opts_chunk$set(opts_fig_wide)
@

<<ggrepel-04>>=
set.seed(42)
ggplot(Orange, aes(age, circumference, color = Tree)) +
  geom_line() +
  expand_limits(x = max(Orange$age) * 1.1) +
  geom_text_repel(data = subset(Orange, age == max(age)),
                  aes(label = paste("Tree", Tree)),
                  size = 5,
                  nudge_x = 65,
                  segment.color = NA) +
  theme(legend.position = "none") +
  labs(x = "Age (days)", y = "Circumference (mm)")
@

We can combine \Rfunction{stat\_peaks()} from package \ggpmisc with the use of repulsive text to avoid overlaps between text items. We use \code{nudge\_y = 500} to push the text upwards.

<<ggrepel-05>>=
ggplot(lynx) +
  geom_line() +
  stat_peaks(geom = "text_repel", nudge_y = 500)
@

\subsection{Selectively plotting repulsive labels}\label{sec:repel:dens}
\index{plots!advanced examples!selected repulsive text}
To repel text or labels so that they do not overlap unlabelled observations, one can set the labels to an empty character string \code{""}. Setting labels to \code{NA} skips the observation completely, as is the usual behavior in \ggplot2 geoms, and can result in text or labels overlapping those observations. Labels can be set manually to \code{""}, but in those cases where all observations have labels in the data, but we would like to plot only those in low density regions, this can be automated. Geoms \code{geom\_text\_repel} and \Rfunction{geom\_label\_repel()} from package \ggrepel can be used together with \Rfunction{stat\_dens2d\_label()} from package \ggpmisc.

To demonstrate this we first generate suitable data and labels.

<<ggrepel-10>>=
# Make random labels
random_string <- function(len = 6) {
paste(sample(letters, len, replace = TRUE), collapse = "")
}
@

<<ggrepel-11>>=
# Make random data.
set.seed(1001)
myl.data <- tibble(
  x = rnorm(100),
  y = rnorm(100),
  group = rep(c("A", "B"), c(50, 50)),
  lab = replicate(100, { random_string() })
)
head(myl.data)
@

The first example uses defaults.

<<ggrepel-12>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel")
@

The fraction of observations can be plotted, as well as the maximum number can be both set through parameters, as shown in section \ref{sec:dens:filter} on page \pageref{sec:dens:filter}.

Something to be aware of when rotating labels is that repulsion is always based on bounding box that does not rotate, which for long labels and angles that are not multiples of 90 degrees, reserves too much space and leaves gaps between segments and text. Compare the next two figures.

<<ggrepel-13>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel", angle = 90)
@

<<ggrepel-14>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "text_repel", angle = 45)
@

Labels cannot be rotated.

<<ggrepel-15>>=
ggplot(data = myl.data, aes(x, y, label = lab, color = group)) +
  geom_point() +
  stat_dens2d_labels(geom = "label_repel")
@

\section['tidyquant']{\pkgname{tidyquant}}\label{sec:plot:tidyquant}
\index{plots!time series!moving average}
\index{plots!time series!tibble}
<<>>=
citation(package = "tidyquant")
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

The focus of this extension to \pkgname{ggplot2} is the conversion of time series data into tidy tibbles. It also defines additional \emph{geometries} for plotting moving averages with \ggplot. Package \pkgname{tidyquant} defines six \emph{geometries}, several mutators for time series stored as tibbles are also exported. Furthermore it integrates with packages used for the analysis of financial time series: \pkgname{xts}, \pkgname{zoo}, \pkgname{quantmod}, and \pkgname{TTR}. Financial analysis falls outside the scope of this book, so we give no examples of the use of this package.

\section['ggseas']{\pkgname{ggseas}}\label{sec:plot:ggseas}
\index{plots!time series!seasonal decomposition}
<<>>=
citation(package = "ggseas")
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

The focus of this extension to \pkgname{ggplot2} is the seasonal decomposition of time series done on the fly while creating a ggplot. Package \pkgname{ggseas} defines five \emph{statistics}, \Rfunction{stat\_index()}, \Rfunction{stat\_decomp()}, \Rfunction{stat\_rollapplyr()}, \Rfunction{stat\_stl()}, and \Rfunction{stat\_seas()}. By default they all use \Rfunction{geom\_line()}. This package also defines function
\Rfunction{tsdf()} that needs to be used to convert time series to data frames to pass as \code{data} argument to \Rfunction{ggplot()}.

Index referenced to the first two observations in the series. Here we use \Rfunction{ggplot()} method for class \code{"ts"} from our package \pkgname{ggpmisc}. Functions \\Rfunction{try\_tibble()} from \pkgname{ggpmisc} and \Rfunction{tsdf()} from \pkgname{ggseas} can be also used.

<<>>=
ggplot(lynx) +
       stat_index(index.ref = 1:2) +
       expand_limits(y = 0)
@

<<>>=
ggplot(AirPassengers) +
       stat_index(index.ref = 1:10) +
       expand_limits(y = 0)
@

Rolling average.

We use a with of 9, which seems to be approximately the length of the cycle.

<<>>=
ggplot(lynx) +
       geom_line() +
       stat_rollapplyr(width = 9, align = "center", color = "blue") +
       expand_limits(y = 0)
@

For monthly data on air travel, it is clear that a width of 12 observations (months) is best.

<<>>=
ggplot(AirPassengers) +
       geom_line() +
       stat_rollapplyr(width = 12, align = "center", color = "blue") +
       expand_limits(y = 0)
@

Seasonal decomposition.

<<>>=
ggplot(AirPassengers) +
       geom_line() +
       stat_seas(colour = "blue") +
       stat_stl(s.window = 7, color = "red") +
       expand_limits(y = 0)
@

Using function \Rfunction{tsdf()} from package \pkgname{ggseas}.

<<>>=
ggplot(tsdf(AirPassengers),
       aes(x, y)) +
       geom_line() +
       stat_seas(colour = "blue") +
       stat_stl(s.window = 7, color = "red") +
       expand_limits(y = 0)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section['ggsci']{\pkgname{ggsci}}\label{sec:plot:ggsci}

\index{plots!additional colour palettes}
<<>>=
citation(package = "ggsci")
@

I list here package \pkgname{ggsci} as it provides several \emph{color palettes} (and color maps) that some users may like or find useful. They attempt to reproduce the those used by several publications, films, etc. Although visually attractive, several of them are not safe, in the sense discussed in section \ref{sec:plot:pals} on page \pageref{sec:plot:pals}. For each palette, the package exports a corresponding \emph{statistic} for use with package \ggplot.

Here is one example, using package \pkgname{pals}, to test if it is ``safe''.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggsci-01>>=
pal.safe(pal_uchicago(), n = 9)
@

A few of the discrete palettes as bands, setting \code{n} to 8, which the largest value supported by the smallest of these palettes.

<<ggsci-02>>=
pal.bands(pal_npg(),
          pal_aaas(),
          pal_nejm(),
          pal_lancet(),
          pal_igv(),
          pal_simpsons(),
          n = 8)
@

And a plot using a palette mimicking the one used by Nature Publishing Group (NPG).

<<ggsci-03>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  scale_color_npg() +
  theme_classic()
@

\section['ggthemes']{\pkgname{ggthemes}}\label{sec:plot:ggthemes}
\index{plots!themes}

<<>>=
citation(package = "ggthemes")
@

Package \pkgname{ggthemes} as one can infer from its name, provides definitions of several \emph{themes} for use with package \ggplot. They vary from formal to informal graphic designs, mostly attempting to follow the recommendations and examples of designers like Tufte \autocite{Tufte1983}, or reproduce design used by well known publications or the default output of some frequently used computer programs.

We first save one of the plots earlier used as example, and later print it using different themes.

<<ggthemes-01>>=
p05 <- ggplot(data = Orange,
              aes(x = age, y = circumference, color = Tree)) +
           geom_line()
@

A \Rfunction{theme\_tufte()} obeying Tufte's recommendation of maximizing the information to ink ratio.

<<ggthemes-02>>=
p05 + theme_tufte()
@

A \Rfunction{theme\_economist()} like The Economist.

<<ggthemes-03>>=
p05 + theme_economist()
@

A \Rfunction{theme\_gdocs()} like Google docs.

<<ggthemes-04>>=
p05 + theme_gdocs()
@

\section['ggtern']{\pkgname{ggtern}}\label{sec:plot:ggtern}
\index{plots!ternary plots}
\index{plots!coordinates!ternary}
<<>>=
citation(package = "ggtern")
@

Package \pkgname{ggtern} provides facilities for making ternary plots, frequently used in soil science and in geology, and in sensory physiology and color science for representing trichromic vision (red-green-blue for humans). They are based on a special system of coordinates with three axes on a single plane.

\begin{warningbox}
  Package \pkgname{ggtern} redefines some functions exported by \ggplot and currently easily conflicts with other extensions to \ggplot. One rarely would like to use functions from this and other packages extending \ggplot in the same figure, but using them in the same document could be necessary. In such cases one may need to call the original definitions explicitly, for example \code{ggplot2::ggplot()} instead of simply \Rfunction{ggplot()} which after loading \pkgname{ggtern} no longer refers to the original definition. Because of this problems we load this package here, near the end of the chapter.
\end{warningbox}

<<>>=
library(ggtern)
@

In this example of the use of \Rfunction{ggtern()}, we use colors pre-defined in R and make a ternary plot of the red, green and blue components of these colors.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
colours <- c("red", "green", "yellow", "white",
             "orange", "purple", "seagreen", "pink")
rgb.values <- col2rgb(colours)
color.data <- data.frame(colour=colours,
                        R=rgb.values[1, ],
                        G=rgb.values[2, ],
                        B=rgb.values[3, ])
ggtern(data=color.data,
       aes(x=R, y=G, z=B, label=colour, fill=colour)) +
       geom_point(shape=23, size=3) +
  geom_text(hjust=-0.2) +
  labs(x = "R", y="G", z="B") + scale_fill_identity() +
  theme_nomask()
@

In the example above we need to use \Rfunction{theme\_nomask()} to avoid clipping of symbols drawn on the edges of the triangular plotting area.

\begin{playground}
Test how the plot changes if you remove  `\code{+ theme\_nomask()}' from the code chunk above.
\end{playground}

\section[Other extensions to `ggplot2']{Other extensions to \pkgname{ggplot2}}

In this section I list some specialized or very recently released extensions to \pkgname{ggplot2} (Table \ref{tab:ggplot:extensions}). The table below will hopefully temp you to explore those suitable for the data analysis tasks you deal with. There is a package under development, already released through CRAN, called \code{ggvis}. This package is not and extension to \pkgname{ggplot2}, but instead a new implementation of the grammar of graphics, with a focus on the creation of interactive plots.

\begin{table}
  \caption[Additional packages extending `ggplot2']{Additional packages extending \pkgname{ggplot2} whose use is not described in this book. All these packages are available at CRAN.}\label{tab:ggplot:extensions}
  \centering
\begin{tabular}{ll}
  \toprule
  Package & Title \\
  \midrule
  \pkgname{ggspectra} & Extensions \ldots\ for Radiation Spectra \\
  \pkgname{ggspatial} & Spatial data framework \ldots \\
  \pkgname{ggsignif} & Significance Bars \ldots \\
  \pkgname{ggsn} & North Symbols and Scale Bars for Maps \ldots \\
  \pkgname{ggmosaic} & Mosaic Plots \ldots\\
  \pkgname{ggimage} & Use image [map image to shape \emph{aesthetic}] \\
  \pkgname{cowplot} & Streamlined Plot Theme and Plot Annotations \ldots \\
  \pkgname{hrbrthemes} & Additional Themes, Theme Components and Utilities \ldots \\
  \pkgname{ggedit} & Interactive \ldots Layer and Theme Aesthetic Editor \\
  \pkgname{ggparallel} & \ldots\ Parallel Coordinate Plots for Categorical Data\\
  \pkgname{ggraph} & \ldots\ Grammar of Graphics for Graphs and Networks\\
  \pkgname{gglogo} & Geom for Logo Sequence Plots \\
  \pkgname{ggiraph} & Make \ldots Graphics Interactive \\
  \pkgname{ggiraphExtra} & Make Interactive \ldots \\
  \bottomrule
\end{tabular}
\end{table}

\section{Extended examples}

\subsection{Anscombe's example revisited}\label{sec:plotex:anscombe}
\index{plots!advanced examples!Anscombe's linear regression plots|(}
<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

To make the example self contained we repeat the code from chapter \ref{chap:R:plotting}, page \pageref{sec:plot:anscombe}.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- tibble(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

<<>>=
ggplot(my.anscombe, aes(x = x, y = y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  stat_poly_eq(formula = y ~ x, parse = TRUE,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@
\index{plots!advanced examples!Anscombe's linear regression plots|)}

\subsection{Heatmaps}\label{sec:plotex:heatmaps}
\index{plots!advanced examples!heatmap plot}


\subsection{Volcano plots}\label{sec:plotex:volcano}
\index{plots!advanced examples!volcano plot}


\subsection{Quadrat plots}\label{sec:plotex:quadrat}
\index{plots!advanced examples!quadrat plot}

<<>>=
try(detach(package:ggfortify))
try(detach(package:MASS))
try(detach(package:xts))
try(detach(package:ggthemes))
try(detach(package:ggsci))
#try(detach(package:ggradar))
try(detach(package:geomnet))
try(detach(package:ggnetwork))
try(detach(package:ggExtra))
try(detach(package:ggalt))
try(detach(package:ggbiplot))
try(detach(package:ggstance))
try(detach(package:gganimate))
try(detach(package:ggseas))
try(detach(package:ggpmisc))
try(detach(package:ggforce))
try(detach(package:ggrepel))
try(detach(package:pals))
try(detach(package:viridis))
try(detach(package:showtext))
try(detach(package:ggplot2))
try(detach(package:tibble))
@

