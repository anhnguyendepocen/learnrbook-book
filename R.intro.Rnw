% !Rnw root = using-r.main.Rnw

<<echo=FALSE, include=FALSE>>=
# opts_chunk$set(opts_fig_wide)
opts_knit$set(unnamed.chunk.label = 'intro-chunk')
opts_knit$set(concordance=TRUE)
@

\chapter{Introduction}\label{chap:introduction}

\begin{VF}
The creative adult is the child who has survived.

\VA{Ursula K. le Guin}{}
\end{VF}

%\dictum[Ursula K. le Guin]{The creative adult is the child who has survived.}\vskip2ex

\section{R}

\subsection{What is R?}

Most people think of R as a computer program. R is indeed a computer program---a piece of software---, but it is also a computer language, implemented in the R program. Does this make a difference? Yes, until recently we had only one mainstream implementation of R, the program R. In the last couple of years another implementation has started to gain popularity, Microsoft R. These are not the only two implementations, but others are not in widespread use. In other words, the R language can be used not only in the R program.

Being \Rpgrm a command line application in its simplest incarnation, it can be used on what nowadays are frugal computing resources, equivalent to a personal computer of a couple of decades ago. \Rpgrm can run even on the Raspberry Pi, a Linux micro-controller board with the processing power of a modest smartphone. At the other end of the spectrum on really powerful servers, \pgrmname{R} can be used for the analysis of big data sets with millions of observations. How powerful a computer you will need will depend on the size of the data sets you want to analyze, and on how patient you are, together your ability to write `good' code.

One could think of R, as a dialect of the S language. S was created and implemented before R. S evolved into S-Plus. As S and S-Plus are commercial programs, variations in the language appeared only between versions. R started as a poor man's home-brewed implementation of S, for use in teaching. Initially R, the program, implemented a subset of the S language. The R program evolved until only some relatively small differences between S and R remained, and these differences were intentional---thought of as improvements. As R overtook S-Plus in popularity, some of the new features in R made their way back into S. R is sometimes called Gnu S.

What makes R different from SPSS, SAS, etc., is that it was designed as a computer programming language. This may look unimportant for someone not actually needing or willing to write software for data analysis. However, in reality it makes a huge difference because R is extensible. By this we mean that new functionality can be easily added, and shared, and this new functionality is to the user indistinguishable from that built-in into R. It other words, instead of having to switch between different pieces of software to do different types of analyses or plots, one can usually find an R package that will provide the tools do the job within R. For those routinely doing similar analyses the ability to write a short program, sometimes just a handful of lines of code, will allow automation of routine analyses. For those willing to spend time programming, they have to door open to building the tools they need if they do not already exist.

However, the most import advantage of using R is that it makes it easy to do data analyses in a way that ensures that they can be exactly repeated. In other words, the biggest advantage of using R, as a language, is not in communicating with the computer, but in communicating to other people what has been done, in a way that is unambiguous. Of course, other people may want to run the same commands in another computer, but still it means that a translation from a set of instructions to the computer into text readable to humans---say the materials and methods section of a paper---and back is avoided.

\subsection{R as a language}

\langname{R} is a computer language designed for data analysis and data visualization, however, in contrast to some other scripting languages, it is from the point of view of computer programming a complete language---it is not missing any important feature.

As mentioned above, R started as a free and open-source implementation of the S-language \autocite{Becker1984,Becker1988}. We will described the features of the \Rlang language on later chapters. Here I mention, that it does have some features that makes it different from other programming languages. For example, it does not have the strict type checks of \pgrmname{Pascal}, nor  \pgrmname{C++}. It also has operators that can take vectors and matrices as operands allowing a lot more concise program statements for such operations than other languages. Writing programs, specially reliable and fast code, requires familiarity with some of these idiosyncracies of the R language. For those using R interactively, or writing short scripts, these idiosyncratic features make life a lot easier.

\begin{explainbox}
Some languages have been standardised, and their grammar has been formally defined. R, in contrast is not standardized, and there is no formal grammar definition. So, the R language is defined by the behaviour of the R program.
\end{explainbox}

\pgrmname{R}\index{R!design} was initially designed for interactive use in teaching, the \pgrmname{R} program uses an interpreter instead of a compiler.

\subsection{R as a computer program}

The R program itself is open-source, the source code is available for anybody to inspect, modify and use. A small fraction of users will directly contribute improvements to the R program itself, but it is possible, and those contributions are important in making R reliable. The executable, the R program we actually use, can be built for different operating systems and computer hardware. The members of the R developing team make an important effort to keep the results obtained from calculations done on all the different builds and computer architectures as consistent as possible.

The R program does not have a graphical user interface (GUI), or menus from which to start different types of analyses. The user types the commands at the R console, or saves the commands into a text file, and uses the file as a `script' or list of commands to be run. When we work at the console typing in commands one by one, we say that we use R interactively. When we run script we would say that we run a ``batch job''. These are the two options that R by itself provides, however, it is common to use a front-end program ``in-between'' users and R itself. The simplest option is to use a text editor like Emacs to edit the scripts and then run the scripts in R from within the editor. With some editors like Emacs, rather good integration is possible. However, nowadays there are also Integrated Development Environments available for R, of which, RStudio is
the most popular by a wide margin.

\subsubsection{Using R interactively}

Typing commands at the R console is useful when one is playing around, aimlessly exploring things, but once we want to keep track of what we are doing, there are better ways of using R. However, the different ways of using R are not exclusive, so most users will use the R console to test individual commands, plot data during the first stages of exploring them, at the console. As soon as we know how we want to plot or analyse the data, it is best to start using scripts. This is not enforced in any way by R, but using plain scripts or ``literate'' scripts to produce reports is what really brings to fruition the most important advantages of using R. In Figure \ref{fig:intro:console} we can see how the R console looks under MS-Windows. The text in red has been typed in by the user---except for the prompt \code{$>$}---, and the text in blue is what R has displayed in response. It is essentially a dialogue between user and R.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/R-console-capture}
  \caption[Screen capture of the R console]{Screen capture of the R console being used interactively. Commands entered by the user is displayed in red, while the result returned by R is displayed in blue.}\label{fig:intro:console}
\end{figure}

\subsubsection{Using R as a ``batch job''}

To run a script we need first to prepare a script in a text editor. Figure \ref{fig:intro:script} shows the console immediately after running the script file shown in the lower window. As before, red text, the command \code{source("my-script.R")}, was typed by the user, and the blue text in the console is what was displayed by R as a result of this action.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/R-console-script}
  \caption[Script sourced at the R console]{Screen capture of the R console and editor just after running a script. The upper window shows the R console, and the lower window the script file in an editor window. }\label{fig:intro:script}
\end{figure}

A true ``batch job'' is not run at the R console but at the operating system command prompt, or shell. The shell is the console of the operating system---Linux, Unix, OS X, or MS-Windows. Figure \ref{fig:intro:shell} shows how running an script at the Windows commands prompt looks. In normal use, a script run at the operating system prompt does time-consuming calculations and the output is saved to a file. One may use this approach on a server, say, to leave the batch job running over-night.

\begin{figure}
  \centering
  \includegraphics[width=0.85\textwidth]{figures/windows-cmd-script}
  \caption[Script at the Windows cmd promt]{Screen capture Windows 10 command console just after running the same script. Here we use \code{Rscript} to run the script, the exact syntax will depend on the operating system in use. In this case R prints the results at the operating system console or shell, rather than in its own R console.}\label{fig:intro:shell}
\end{figure}

\subsubsection{Editors and IDEs}

Integrated Development Environments (IDEs) were initially created for computer program development. They are programs that the user interacts with, from within which the different tools needed can be used in a coordinated way. They usually include a dedicated editor capable of displaying the output from different tools in a useful way, and also in many cases can do syntax highlighting, and even report some mistakes, related to the programming language in use while the user types. One could describe such editor as the equivalent as a word processor, that can check the program code for spelling and syntax errors, and has a built-in thesaurus for the computer language. In the case of RStudio, the main, but not only language supported is \Rlang. The main window of IDEs usually displays several panes simultaneously. From within the IDE one has access to the R console, an editor, a file-system browser, and access to several tools. Although RStudio supports very well the development of large scripts and packages, it is also the best possible way of using R at the console as it has the R help system very well integrated. Figure \ref{fig:intro:rstudio} shows the window displayed by RStudio under Windows after running the same script as shown above at the R console and at the operating system command prompt. We can see in this figure how RStudio is really a layer between the user and an unmodified R executable. The script was sourced by pressing the ``Source'' button at the top of the editor pane. RStudio in response to this generated the code needed to source the file and ``entered'' it at the console, the same console, where we would type ourselves any R commands.

\begin{figure}
  \centering
  \includegraphics[width=0.99\textwidth]{figures/Rstudio-script}
  \caption[Script in Rstudio]{The RStudio interface just after running the same script. Here we used the ``Source'' button to run the script. In this case R prints the results to the R console in the lower left pane.}\label{fig:intro:rstudio}
\end{figure}

When a script is run, if an error is triggered, it automatically finds the location of the error. \RStudio also supports the concept of projects allowing saving of settings per project. Some features are beyond what you need for everyday data analysis and aimed at package development, such as integration of debugging, traceback on errors, profiling and bench marking of code so as to analyse and improve performance. It also integrates support for file version control, which is not only useful for package development, but also for keeping track of the progress or collaboration in the analysis of data.

The version of RStudio that one uses locally, i.e.\ installed in your own computer, runs with almost identical user interface on most modern operating systems, such as Linux, Unix, OS X, and MS-Windows. There is also a server version that runs on Linux, and that can be used remotely through any web browser. The user interface is still the same.

\RStudio is under active development, and constantly improved. Visit \url{http://www.rstudio.org/} for an up-to-date description and download and installation instructions. Two books \autocite{vanderLoo2012,Hillebrand2015} describe and teach how to use \RStudio without going in depth into data analysis or statistics, however, as \RStudio is under very active development several recently added important features are not described in these books. You will find tutorials and up-to-date cheat sheets at \url{http://www.rstudio.org/}.

\section{Packages and repositories}

The most elegant way of adding new features or capabilities to \Rlang is through packages. This is without doubt the best mechanism when these extensions to R need to be shared. However, in most situations it is also the best mechanism for managing code that will be reused even by a single person over time. R packages have strict rules about their contents, file structure, and documentation, which makes it possible among other things for the package documentation to be merged into R's help system when a package is loaded. With a few exceptions, packages can be written so that they will work on any computer where R runs.

Packages can be shared as source or binary package files, sent for example through e-mail. However, for sharing packages widely, best is to submit them to a repository. The largest public repository of R packages is called CRAN, an acronym for Comprehensive R Archive Network. Packages available through CRAN are guaranteed to work, in the sense of not failing any tests built into the package and not crashing or aborting prematurely. They are tested daily, as they may depend on other packages whose code will change when updated. In January 2017, the number of packages available through CRAN passed the 10\,000 mark.

\section{Reproducible data analysis}

One requirement for reproducible data analysis, is a reliable record of what commands have been run on which data. Such a record is specially difficult to keep when issuing commands through menus and dialogue boxes in a graphical user interface. When working interactively at the R console, it is a bit easier, but still copying and pasting is error prone.

A further requirement is to be able to match the output of the R commands to the output. If the script generates the output to separate files, then the user will need to take care that the script saved or shared as record of the data analysis was the one actually used for obtaining the reported results and conclusions. This is another error prone stage in the report of a data analysis. To solve this problem an approach was developed, inspired in what is called \emph{literate programming} \autocite{Knuth1984a}. The idea is that running the script will produce a document that includes the script, the results of running the scripts and any explanatory text needed to understand and interpret the analysis.

Although a system capable of producing such reports, called \pkgname{Sweave} \autocite{Leisch2002}, has been available for a couple decades, it was rather limited and not supported by an IDE, making its use rather tedious. A more recently developed system called \pkgname{knitr} \autocite{Xie2013} together with its integration into RStudio has made the use of this type of reports very easy. The most recent development are Notebooks produced within RStudio. This very new feature, can produce the readable report of running the script, including the code used interspersed with the results within the viewable file. However, this newer approach goes even further: the actual source script used to generate the report is embedded in the HTML file of the report. This means that anyone who gets access to the output of the analysis in human readable form also gets access to the code used to generate the report, in computer executable format.

Because of these recent developments, R is an ideal language to use when the goal of reproducibility is important. During recent years the problem of the lack of reproducibility in scientific research has been broadly discussed and analysed \autocite{Gandrud2015}. One on the problems faced when attempting to reproduce experimental work, is reproducing the data analysis. R together with these modern tools can help in avoiding this source of lack of reproducibility.

How powerful are these tools? and how flexible? They are powerful and flexible enough to write whole books, such as this very book you are now reading, produced with R, knitr and \LaTeX. All pages in the book are generated directly, all figures are generated by R and included automatically, except for the figures in this chapter that have been manually captured from the computer screen. Why am I using this approach? First because I want to make sure that every bit of code as you will see printed, runs without error. In addition I want to make sure that the output that you will see below every line or chunk of R language code is exactly what R returns. Furthermore, it saves a lot of work for me as author, as I can just update R and all the packages used to their latest version, and build the book again, to keep it up to date and free of errors.

Although the use of these tools is important, they are outside the scope of this book. Still when writing code, using a consistent style for formatting and indentation, carefully choosing variable names, and adding textual explanations in comments when needed, helps very much with readability for humans. I have tried to be as consistent as possible throughout the whole book in this respect, with only small personal deviations from the usual style.

\section{Finding additional information}

When searching for answers, asking for advice or reading books you will be confronted with different ways of doing the same tasks. Do not allow this overwhelm you, in most cases it will not matter as many computations can be done in \Rpgrm, as in any language, in several different ways, still obtaining the same result. The different approaches may differ mainly in two aspects: 1) how readable to humans are the instructions given to the computer as part of a script or program, and 2) how fast the code runs. Unless performance is an important bottleneck in your work, just concentrate on writing code that is easy to understand to you and to others, and consequently easy to check and reuse. Of course do always check any code you write for mistakes, preferably using actual numerical test cases for any complex calculation or even relatively simple scripts. Testing and validation are extremely important steps in data analysis, so get into this habit while reading this book. Testing how every function works as I will challenge you to do in this book, is at the core of any robust data analysis or computing programming. When developing R packages, including a good coverage of test cases as part of the package itself simplifies code maintenance enormously, helps in maintaining consistency of behaviour across versions.

\subsection{R's built-in help}

To\index{R!help} access help pages through the command prompt we use function \texttt{help()} or a question mark. Every object exported by an R package (functions, methods, classes, data) is documented. Sometimes a single help page documents several R objects. Usually at the end of the help pages, some examples are given, which tend to help very much in learning how to use the functions described. For example one can search for a help page at the R console.

<<help-1, eval=FALSE>>=
help("sum")
?sum
@

\begin{playground}
Look at help for some other functions like \code{mean()}, \code{var()}, \code{plot()} and, why not, \code{help()} itself!
<<eval=FALSE>>=
help(help)
@
\end{playground}

When using \RStudio there are several easier ways of navigating to a help page, for example with the cursor on the name of a function in the editor or console, pressing the F1 key, opens the corresponding help page in the help pane. Letting the cursor hover for a few seconds over the name of a function at the R console will open ``bubble help'' for it. If the function is defined in a script or another file open in the editor pane one can directly navigate from the line where the function is called to where it is defined. In RStudio one can also search for help through the graphical interface.

In addition to help pages, the \pgrmname{R}'s distribution includes useful manuals as PDF or HTML files. This can be accessed most easily through the Help menu in \RStudio or \pgrmname{RGUI}. Extension packages, provide help pages for the functions and data they export. When a package is loaded into an \pgrmname{R} session, its help pages are added to the native help of \pgrmname{R}. In addition to these individual help pages, each package, provides an index of its corresponding help pages, for users to browse. Many packages, also provide \emph{vignettes} such as User Guides or articles describing the algorithms used.

There are some web sites that give access to R documentation through a web server. These sites can be very convenient when exploring whether a certain package could be useful for a certain problem, as they allow browsing and searching the documentation without need of installing the packages. Some package maintainers have web sites with additional documentation for their own packages. The DESCRIPTION or README of packages provide contact information for the maintainer, links to web sites, and instructions on how to report bugs.

\subsection{Obtaining help from on-line forums}

\subsubsection{Netiquette}
In\index{netiquette}\index{network etiquette} most internet forums, a certain behaviour is expected from those asking and answering questions. Some types of miss-behavior, like use of offensive or inappropriate language, will usually result in the user being banned writing rights in a forum. Occasional minor miss-behaviour, will usually result in the original question not being answered and instead the problem highlighted in the reply.

\begin{itemize}
  \item Do your homework: first search for existing answers to your question, both on-line and in the documentation. (Do mention that you attempted this without success when you post your question.)
  \item Provide a clear explanation of the problem, and all the relevant information. Say if it concerns R, the version, operating system, and any packages loaded and their versions.
  \item If at all possible provide a simplified and short, but self-contained, code example that reproduces the problem (sometimes called \emph{reprex}).
  \item Be polite.
  \item Contribute to the forum by answering other users' questions when you know the answer.
\end{itemize}

\begin{explainbox}
 How to prepare a reproducible example (reprex).
\end{explainbox}

\subsubsection{StackOverflow}

Nowadays, StackOverflow (\url{http://stackoverflow.com/})\index{StackOverflow} is the best questions and answers (Q\,\&\,A)support site for \pgrmname{R}. In most cases, searching for existing questions and their answers, will be all what you need to do. If asking a question, make sure that it is really a new question. If there is some question that looks similar, make clear how your question is different.

StackOverflow has a user-rights system based on reputation, and questions and answers can be up- and down-voted. Those with the most up-votes are listed at the top of searches. If the questions or answers you write are up-voted after you accumulate enough reputation you acquire badges, and rights, such as editing other users' questions and answers or later on, even deleting wrong answers or off-topic questions from the system. This sounds complicated, but works extremely well at ensuring that the base of questions and answers is relevant and correct, without relying on a single or ad-hoc \emph{moderators}.

\section{What is needed to run the examples on this book?}

The book is written with the expectation that you will run most of the code examples and try as many other variations as needed until you are sure to understand the basic `rules' of the \Rpgrm language and how each function or command described works. In \Rpgrm for each function, data set, etc.\ there is a help page available. Error messages tend to be terse in \Rpgrm, and may require some lateral thinking and/or `experimentation' to understand the real cause behind problems. When you are not sure to understand how some command works, it is useful in many cases to try simple examples for which you know the correct answer and see if you can reproduce them with \Rpgrm. Because of this, this book also includes some code examples that trigger errors. To test your understanding of how a code statement or function works, it is good to try your hand at testing its limits, testing which variations of a piece code are valid or not.

I recommend you to use as an editor or IDE (integrated development environment) \RStudio. \RStudio is user friendly, actively maintained, free, open-source and available both in desktop and server versions. The desktop version runs on Windows, Linux, and OS X and other Unixes. For\index{IDE for R}\index{editor for R scripts} running the examples in the handbook, you would need only to have \pgrmname{R} installed. That would be enough as long as you also have a text editor available. This is possible, but does not give a very smooth work flow for data analyses that are beyond the very simple. The next stage is to use a text editor which integrates to some extent with R, but still this is not ideal, specially for writing packages or long scripts for data analysis. Currently, by far the best option is to use \RStudio.

Of course when choosing which editor to use, personal preferences and previous familiarity play an important.
Currently, for the development of packages, I use \RStudio exclusively. For writing this book I have used both RStudio and the text editor WinEdt which also has some support for R together with excellent support for \LaTeX. When working on a large project or collaborating with other data analysts or researchers, one big advantage of a system based on plain text files, is that the same files can be edited with different programs as needed or wished by the different persons involved in a project.

When I started using R, nearly two decades ago, I was using other editors, using the operating system shell a lot more, and struggling with debugging as no IDE was available. The only reasonably good integration with an editor was for Emacs, which was widely available only under Unix-like systems. Given this past experience, I encourage you to use an IDE for R. \RStudio is nowadays very popular, but if you do not like it, need a different set of features, such as integration with \pgrmname{ImageJ}, or are already familiar with the \pgrmname{Eclipse} IDE, you may like try the \pgrmname{Bio7} IDE, available from \url{http://bio7.org}.

The examples make use of several freely available packages, with can be obtained installed from CRAN. One of them \pkgname{learnrbook} also available through CRAN, contains data sets and files specific to this book. The \pkgname{learnrbook} package also contains installation instructions and saved lists of the names of all other packages used in the book. Instructions on installing R, Git, RStudio, compilers and other tools are available on-line. In many cases the IT staff at your employer or school will know how to install them, or they may be even included in the default computer setup. In addition a web site supporting the book is available at: \url{http://www.learnr-book.info}.

\section{Working at the R console}
\index{console}
The examples in the book use only the console window for user input. Menu-driven programs are not necessarily bad, they are just unsuitable when there is a need to set very many options and choose from many different actions. They are also difficult to maintain when extensibility is desired, and when independently developed modules of very different characteristics need to be integrated. Textual languages also have the advantage, to be dealt in later chapters, that command sequences can be stored in human- and computer readable text files. Such files constitute a record of all the steps used and in most cases makes it trivial to reproduce the same steps at a later time. Scripts are also a very simple and handy way of communicating to others how to do a given data analysis.

In the console you can type commands at the \code{>} prompt.
When you end a line by pressing the return key, if the line can be interpreted as an R command, the result will be printed at the console, followed by a new \code{>} prompt.
If the command is incomplete a \code{+} continuation prompt will be shown, and you will be able to type-in the rest of the command. For example if the whole calculation that you would like to do is $1 + 2 + 3$, if you enter in the console \code{1 + 2 +} in one line, you will get a continuation prompt where you will be able to type \code{3}. However, if you type \code{1 + 2}, the result will be calculated, and printed.

When working at the command prompt, most results are printed by default, but in other cases you may need to use the function \Rfunction{print()} explicitly. Most examples in the book rely on automatic printing of output. To effectively learn from this book, you will need to work your way through the code examples. This book's approach is that of a travel-guide, it aims at helping you find your own way in the world of R. Your travels in the world of \Rlang will start on the next page. Enjoy them!

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
knitter_diag()
R_diag()
other_diag()
@

