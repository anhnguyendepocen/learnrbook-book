% !Rnw root = appendix.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
play.eval <- FALSE
@

\chapter[Plots with ggpplot]{Plots with \ggplot}\label{chap:R:plotting}

\section{Packages used in this chapter}

<<>>=
citation(package = "ggplot2")
@

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(ggplot2)
library(scales)
library(tikzDevice)
@



We set a font of larger size than the default
<<>>=
theme_set(theme_grey(14))
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \pkgname{Lattice} and \ggplot. There are additional packages that add extra functionality to these packages.

In the examples in this chapter we describe the of use package \ggplot. We start with an introduction to the `grammar of graphics' and \ggplot. There is ample literature on the use of \ggplot, including the very good reference documentation at \url{http://docs.ggplot2.org/}. The \ggplot book \autocite{Wickham2016} is the authoritative reference, as it is authored by the developer of \ggplot. The book `R Graphics Cookbook' \autocite{Chang2013} is very useful as a reference as it contains many worked out examples. Much of the literature available at this time is for older versions of \ggplot but we here describe version 2.2.0, and highlight the most important incompatibilities that need to be taken into account when using versions of \ggplot earlier than 2.2.0. There is no comprehensive text on packages extending \ggplot so I will describe some of them in later chapters. In the present chapter we describe the functions and methods defined in package \ggplot, in chapter \ref{chap:R:more:ggplotting} on page \pageref{chap:R:more:ggplotting} we describe extensions to \ggplot defined in other packages, except for those related to plotting data onto maps and other images, described in chapter \ref{chap:R:maps} on page \pageref{chap:R:maps}. Consistent with the title of this book, we use a tutorial style, interspersing exercises to motivate learning using a hands-on approach and playful exploration of a wide range of possible uses of the \emph{grammar of graphics}.

\section{Grammar of graphics}

What separates \ggplot from base-R and trellis/lattice plotting functions is the use of a grammar of graphics (the reason behind `gg' in the name of the package). What is meant by grammar in this case is that plots are assembled piece by piece from different `nouns' and `verbs'. Instead of using a single function with many arguments, plots are assembled by combining different elements with operators \code{+} and \verb|%+%|. Furthermore, the construction is mostly semantic-based and to a large extent how the plot looks when is printed, displayed or exported to a bitmap or vector graphics file is controlled by themes.

\subsection{Mapping}

When we design a plot, we need to map data variables to aesthetics (or graphic `properties'). Most plots will have an $x$ dimension, which is considered an aesthetic, and a variable containing numbers mapped to it. The position on a 2D plot of say a point will be determined by $x$ and $y$ aesthetics, while in a 3D plot, three aesthetics need to be mapped $x$, $y$ and $z$. Many aesthetics are not related to coordinates, they are properties, like color, size, shape, line type or even rotation angle, which add an additional dimension on which to represent the values of variables and/or constants.

\subsection{Geometries}

Geometries describe the graphics representation of the data: for example, \texttt{geom\_point}, plots a `point' or symbol for each observation, while \texttt{geom\_line}, draws line segments between successive observations. Some geometries rely on statistics, but most `geoms' default to the identity statistics.

\subsection{Statistics}

Statistics are `words' that represent calculation of summaries or some other operation on the values from the data, and these summary values can be plotted with a geometry. For example \texttt{stat\_smooth} fits a smoother, and \texttt{stat\_summary} applies a summary function. Statistics are applied automatically by group when data has been grouped by mapping additional aesthetics such as color to a factor.

\subsection{Scales}

Scales give the relationship between data values and the aesthetic values to be actually plotted. Mapping a variable to the `color' aesthetic only tells that different values stored in the mapped variable will be represented by different colors. A scale, such as \texttt{scale\_color\_continuous} will determine which color in the plot corresponds to which value in the variable. Scales are used both for continuous variables, such as numbers, and categorical ones such as factors.

\subsection{Coordinate systems}

The most frequently used coordinate system when plotting data is the cartesian system, which is the default for most \emph{geometries}. In the cartesian system, $x$ and $y$ are represented as distances on two orthogonal (at 90$^\circ$) axes. In the polar system of coordinates, angles around a central point are used instead of distances on a straight line. However, package \pkgname{ggtern} adds a ternary system of coordinates, to allow the extension of the grammar to allow the construction of ternary plots.

\subsection{Themes}

How the plots look when displayed or printed can be altered by means of themes. A plot can be saved without adding a theme and then printed or displayed using different themes. Also individual theme elements can be changed, and whole new themes defined. This adds a lot of flexibility and helps in the separation of the data representation aspects from those related to the graphical design.

As discussed above the grammar of graphics is based on aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, \code{coordinate} systems and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geometry.

As the workings and use of the grammar are easier to show by example than to explain with words, after this short introduction we will focus on examples showing how to produce graphs of increasing complexity.

\section{Scatter plots}\label{sec:plot:scatter}\label{sec:simple:points:lines}

In the examples that follow we will use the \code{mtcars} data set included in R. To learn more about this data set, type \code{help("mtcars")} at the R command prompt.

Data variables must be `mapped' to \textit{aesthetics} to appear as in a plot. Variables to be represented in a plot can be either continuous (numeric) or discrete (categorical, factor). Variable \code{cyl} is encoded in the \code{mtcars} data frame as numeric values. Even though only three values are present, a continuous color scale is used by default. In the example below, \code{x}, \code{y} and \code{color} are \emph{aesthetics}. In this example they are all mapped to variables contained in the data frame \code{mtcars}. To build a scatter plot, we use the \code{"point"} geometry as in a scatter plot each individual observation is represented by a \emph{point} or symbol in the plot.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = cyl)) +
  geom_point()
@

\begin{playground}
Try a different mapping: \code{disp} $\rightarrow$ \code{color}, \code{cyl} $\rightarrow$ \code{x}. Continue by using \code{help(mtcars)} and/or \code{names(mtcars)} to see what variables are available, and then try the combinations that trigger your curiosity.
\end{playground}

Some scales exist in two `flavours', one suitable for continuous variables and another for discrete variables. We can convert \code{cyl} into a factor `on-the-fly' to force the use of a discrete color scale.
If we \emph{map} the \code{color} aesthetic to \code{factor(cyl)}, points get colors according to the levels of the factor, and by default a \code{guide} or \emph{key} for the mapping is also added.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point()
@

\begin{playground}
Try a different mapping: \code{mpg} $\rightarrow$ \code{color}, \code{cyl} $\rightarrow$ \code{y}. Invent your own mappings taking into account which variables are continuous and which ones categorical.
\end{playground}

Using an aesthetic, involves the mapping of values in the data to aesthetic values such as colours. The mapping is defined by means of \emph{scales}. If we now consider the \code{color} aesthetic in the previous statement, a default discrete color scale was used when \code{factor(cyl)} was mapped to the aesthetic, while a continuous color scale was used when \code{mpg} was mapped to it.

In the case of the discrete scale three different colours taken from a default palette were used. If we would like to use a different set of three colours for the three values of the factor, but still have them assigned automatically to each \emph{point} in the plot, we can select a different colour palette by passing an argument to the corresponding scale function.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point() +
  scale_color_brewer(type = "qual", palette = 2)
@

\begin{playground}
Try the different palettes available through the brewer scale. You can play directly with the palettes using function \code{brewer\_pal()} from package \pkgname{scales} together with \code{show\_col()}).
<<eval=play.eval>>=
show_col(brewer_pal()(3))
show_col(brewer_pal(type = "qual", palette = 2, direction = 1)(3))
@
Once you have found a suitable palette for these data, redo the plot above with the chosen palette.
\end{playground}

Neither the data, nor the aesthetics mappings or geometries are different than in earlier code; to alter how the plot looks we have changed only the palette used by the color aesthetic. Conceptually it is still exactly the same plot we earlier created. This is a very important point to understand, because it is extremely useful in practice. Plots are assembled piece by piece and it is even possible to replace elements in an existing plot.

\begin{warningbox}
Within \code{aes()} the aesthetics are interpreted as being a function of the values in the data---i.e.\ to be mapped. If given outside \code{aes()} they are interpreted as constant values, which apply to one \emph{geometry} if given within the call to \code{geom\_xxx} but outside \code{aes()}. The aesthetics and data given as \code{ggplot()}'s arguments become the defaults for all the geoms, but geoms also accept aesthetics and data as arguments, which when supplied locally override the whole-plot defaults. In the example below, we override the default colour of the points.
\end{warningbox}

If we \emph{set} the \code{color} aesthetic to a constant value, \code{"red"}, all points are plotted in red.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point(color = "red")
@

\begin{playground}
Does the code chunk below produces exactly the same plot as that above this box? Consider how the two mappings differ, and make sure that you understand the reasons behind the difference or lack of difference in output by trying different variations of these examples
<<play.eval>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point(color = "red")
@
\end{playground}

As with any R function it is possible to pass arguments by position to \code{aes} when
mapping variables to \emph{aesthetics} but this
makes the code more difficult to read and less tolerant to possible changes to the
definitions of functions. It is not
recommended to use this terse style in scripts or package coding. However, it can
be used by experienced users at the command prompt usually without problems.

Mapping passing arguments by \emph{name} to \code{aes}.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
  geom_point()
@

\begin{playground}
If we swap the order of the arguments do we still obtain the same plot?
<<eval=play.eval>>=
ggplot(data = mtcars, aes(y = mpg, x = disp)) +
  geom_point()
@
\end{playground}

Mapping passing arguments by \emph{position} to \code{aes}.

<<>>=
ggplot(mtcars, aes(disp, mpg)) +
  geom_point()
@

\begin{playground}
If we swap the order of the arguments do we obtain a different plot?
<<eval=play.eval>>=
ggplot(mtcars, aes(mpg, disp)) +
  geom_point()
@
\end{playground}

When not relying on colors, the most common way of distinguishing groups of observations in scatter plots is to use the \code{shape} of the points as an \emph{aesthetic}. We need to change a single ``word'' in the code statement to achieve this different mapping.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point()
@

We can use \code{scale\_shape\_manual} to choose each shape to be used. We set three ``open'' shapes that we will see later are very useful as they obey both \code{color} and \code{fill} \emph{aesthetics}.\label{chunk:filled:symbols}

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point() +
  scale_shape_manual(values = c(21, 22, 23))
@

It is also possible to use character strings as shapes. The character is centred on the position of the observation. Conceptually using \code{character} values for \code{shape} is different to using \code{geom\_text} as in the later case there is much more flexibility as character strings and expressions are allowed in addition to single characters. Also positioning with respect to the coordinates of the observations can be adjusted through justification. While \code{geom\_text} is usually used for annotations, the present example treats the character string as a symbol. (This also opens the door to the use as shapes of symbols defined in special fonts.)

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point(size = 2.5) +
  scale_shape_manual(values = c("4", "6", "8"), guide = FALSE)
@

\begin{playground}
What do you expect to be the result of the following statement?

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point(size = 4) +
  scale_shape_manual(values = c("c4", "c6", "c8"), guide = FALSE)
@
\end{playground}

As seen earlier one variable can be mapped to more than one aesthetic allowing redundant aesthetics. This may seem wasteful, but it is extremely useful as it allows one to produce figures that even when produced in color, can still be read if reproduced as monochrome images.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          color = factor(cyl))) +
  geom_point()
@

\begin{playground}
Here we map \code{fill} and \code{shape} to \code{cyl}. What do you expect this variation of the statement above to produce?

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          fill = factor(cyl))) +
  geom_point()
@

Hint: Do all shapes obey the \code{fill} aesthetic? (Having a look at page \pageref{chunk:filled:symbols} may be of help.)
\end{playground}


We can create a ``bubble'' plot by mapping the \code{size} \emph{aesthetic} to a continuous variable. In this case, one has to think what is visually more meaningful. Although the radius of the shape is frequently mapped, due to how human perception works, mapping a variable to the area of the shape is more useful by being perceptually closer to a linear mapping. For this example we add a new variable to the plot. The weight of the car in tons and map it to the area of the points.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size_area() +
  geom_point()
@

\begin{playground}
If we use a radius-based scale the ``impression'' is different.

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size() +
  geom_point()
@

Make the plot, look at it carefully. Check the numerical values of some of the weights, and assess if your perception of the plot matches the numbers behind it.
\end{playground}

As a final example of how to combine different aesthetics, we use in a single plot several of the different mappings described in earlier examples.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          fill = factor(cyl),
                          size = wt)) +
  geom_point(alpha = 0.33, color = "black") +
  scale_size_area() +
  scale_shape_manual(values = c(21, 22, 23))
@

\begin{playground}
Play with the code in the chunk above. Remove or change each of the mappings and the scale, display the new plot and compare it to the one above. Continue playing with the code until you are sure you understand what each individual element in the code statement creates or controls which graphical element in the plot itself.
\end{playground}

Data assigned to an \emph{aesthetic} can be the `result of a computation'. In other words, the values to be plotted do not need to be stored in the data frame passed as argument to \code{data}, the first formal parameter of \code{ggplot()}

Here we plot the ratio of miles-per-gallon, \code{mpg}, and the engine displacement (volume), \code{disp}. Instead of mapping as above \code{disp} to the $x$ \emph{aesthetic}, we map \code{factor(cyl)} to $x$. In contrast to the continuous variable \code{disp} we earlier used, now we use a factor, so a discrete (categorical) scale is used by default for $x$.

<<>>=
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg / disp)) +
  geom_point()
@

\begin{playground}
What will happen if we replace \code{factor(cyl)} with \code{cyl} in the statement above? How do you expect the plot to change? First think carefully what you can expect, and then run the edited code.
\end{playground}

Although \code{factor(cyl)} is mapped to $x$, we can map it in addition to  \code{color}. This may be useful when desiring to keep the design consistent across plots, for example this one and those above.

<<>>=
ggplot() +
  aes(x = factor(cyl), y = mpg / disp,
      colour = factor(cyl)) +
  geom_point(data = mtcars)
@

We can set the labels for the different aesthetics, and give a title (\verb!\n! means `new line' and can be used to continue a label in the next line). In this case, if two aesthetics are linked to the same variable, the labels supplied should be identical, otherwise two separate \emph{keys} will be produced.

<<>>=
ggplot(data = mtcars,
       aes(x=disp, y=hp, colour=factor(cyl),
           shape=factor(cyl))) +
  geom_point() +
  labs(x="Engine displacement)",
       y="Gross horsepower",
       colour="Number of\ncylinders",
       shape="Number of\ncylinders")
@

\begin{playground}
Play with the code statement above. Edit the character strings. Move the \verb|\n| around. How would you write a string so that quotation marks can be included as part of the title of the plot? Experiment, and google, if needed, until you get this to work.
\end{playground}

Please, see section \ref{sec:plot:labs} on page \pageref{sec:plot:labs} for more an extended description of the use of \code{labs}.

\section{Line plots}

For line plots we use \code{geom\_line}. The \code{size} of a line is its thickness, and as we had \code{shape} for points, we have \code{linetype} for lines. In a line plot observations in successive rows of the data frame, or the subset corresponding to a group, are joined by straight lines. We use a different data set included in R, Orange, with data on the growth of five orange trees. See the help page for \code{Orange} for details.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line()
@

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, linetype = Tree)) +
  geom_line()
@

Much of what was described above for scatter plots can be adapted to line plots.

\section{Plotting functions}\label{sec:plot:function}

In addition to plotting data from a data frame with variables to map to $x$ and $y$ \emph{aesthetics}, it is possible to have only a variable mapped to $x$ and use \code{stat\_function} to generate the values to be mapped to $y$ using a function. This avoids the need to generate data beforehand (the number of data points to be generated can be also set).

We start with the Normal distribution function.

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
@

Using a list we can even pass by name additional arguments to a function.

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

\begin{playground}
1) Edit the code above so as to plot in the same figure three curves, either for three different values for \code{mean} or for three different values for \code{sd}.

2) Edit the code above to use a different function, say \code{df}, the F distribution, adjusting the argument(s) passed through \code{args} accordingly.
\end{playground}

Of course, user-defined functions (not shown), and anonymous functions (below) can also be used.

<<>>=
ggplot(data.frame(x = 0:1), aes(x = x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

\begin{playground}
Edit the code above to use a different function, such as $e^{x + k}$, adjusting the argument(s) passed through \code{args} accordingly. Do this by means of an anonymous function, and by means of an equivalent named function defined by your code.
\end{playground}

\begin{explainbox}
In some cases we may want to tweak some aspects of the plot to better match the properties of the mathematical function. Here we use a predefined function for which the default $x$-axis breaks (tick positions) are not the best. We first show how the plot looks using defaults.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin)
@

Next we change the $x$-axis scale to better match the sine function and the use of radians as angular units.

<<>>=
ggplot(data.frame(x = c(0, 2 * pi)), aes(x = x)) +
  stat_function(fun = sin) +
  scale_x_continuous(
    breaks = c(0, 0.5, 1, 1.5, 2) * pi,
    labels = c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)")
@

There are three things in the above code that you need to understand: the use of the R built-in numeric constant \code{pi}, the use of argument `recycling' to avoid having to type \code{pi} many times, and the use of R \emph{expressions} to construct suitable tick labels for the $x$ axis. Do also consider why \code{pi} is interpreted differently within \code{expression} than within the numeric statements.

The use of \code{expression} is explained in detail in section \ref{sec:plot:plotmath}, an the use of \code{scales} in section \ref{sec:plot:scales}.

\end{explainbox}

\section{Plotting text and maths}\label{sec:plot:text}

We can use \code{geom\_text} or \code{geom\_label} to add text labels to observations. For \code{geom\_text}, the aesthetic \code{label} provides the text to be plotted and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{color} and \code{size} aesthetics can be also used for the text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of 0.5 for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the label left or down, and positive values right or up. A value of 1 or 0 sets the text so that its edge is at the supplied coordinate. Values outside the range $0\ldots 1$ shift the text even further away, however, based on the length of the string. In the case of \code{geom\_label} the text is enclosed in a rectangle, which obeys the \code{fill} \emph{aesthetic}. However, it does not support rotation with \code{angle}.

<<>>=
my.data <-
  data.frame(x = 1:5, 
             y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust=1.5, color = "blue") + 
  geom_point()
@

\begin{playground}
Modify the examples above to use \code{geom\_label} instead of \code{geom\_text} using in addition the \code{fill} aesthetic.
\end{playground}

You should be aware that R and ggplot2 support the use of UNICODE, such as UTF8 character encoding in strings. If your editor or IDE supports their use, then you can type Greek letters and simple maths symbols directly, and they will show correctly in labels. This is not fully portable, as even if the character positions are standardized for many languages, most UNICODE  
In the next example we use \code{paste()} (which uses recycling here) to add a space at the end of each label.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = paste(c("a", "ab", "abc", "abcd", "abcde"), " "))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust=1, color = "blue") + geom_point()
@

\begin{playground}
Justification values outside the range $0\ldots 1$ are allowed, but are relative to the width of the label. As the labels are of different length, using any value other than zero or one results in uneven positioning of the labels with respect to points.
Edit the code above using \code{hjust} set to 1.5 instead of to 1, without pasting a space character to the labels. Is the plot obtained ``tidy'' enough for publication? and for data exploration?
\end{playground}

Plotting expressions (mathematical expressions) involves mapping to the \code{label} aesthetic character strings that can be parsed as expressions, and setting \code{parse = TRUE}.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label=paste("alpha[", 1:5, "]", sep = ""))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

Plotting maths and other alphabets using R expressions is discussed in section \ref{sec:plot:plotmath} on page \pageref{sec:plot:plotmath}.

\begin{explainbox}
In the examples above we plotted text and expressions present in the data frame passed as argument for \code{data}. It is also possible to build suitable labels on-the-fly within \code{aes} when setting the mapping for \code{label}. Here we use \code{geom\_text} and expressions for the example, but the same two approaches can be use to ``build'' character strings to be used directly without parsing.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5))

ggplot(my.data, aes(x,
                    y,
                    label = paste("alpha[", x, "]", sep = ""))) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

\begin{playground}
What are the advantages and disadvantages of each approach in relation to easy with which a script in which several figures using the same ``labels'' are produced, in relation to consistency across figures? In contrast, which approach would you prefer if different figures in the same script used different variations of labels constructed from the same variables in the data?
\end{playground}

\end{explainbox}

\section{Axis- and key labels, titles, subtitles and captions}\label{sec:plot:titles}

I describe this in the same section, and immediately after the section on plotting text labels, as they are added to plots using similar approaches. Be aware that the default justification of plot titles has changed in \ggplot version 2.2.0 from centered to left justified. At the same time, support for subtitles and captions was added.

The most flexible approach is to use \code{labs} as it allows the user to set the text or expressions to be used for these different elements.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  labs(title = "Growth of orange trees",
       subtitle = "Starting from 1968-12-31",
       caption = "see Draper, N. R. and Smith, H. (1998)",
       x = "Time (d)",
       y = "Stem circumference (mm)",
       color = "Tree\nnumber")
@

There are in addition to \code{labs} convenience functions for setting the axis labels, \code{xlab} and \code{ylab}.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  xlab("Time (d)") +
  ylab("Stem circumference (mm)")
@

An additional convenience function, \code{ggtitle} can be used to add a title and optionally a subtitle.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  ggtitle("Growth of orange trees",
          subtitle = "Starting from 1968-12-31")
@

\begin{playground}
Make an empty plot (\code{ggplot()}) and add to it as title an expression producing $y = b_0 + b_1 x + b_2 x^2$. (Hint: have a look at the examples for the use of expressions as labels in section \ref{sec:plot:text} on page \pageref{sec:plot:text} and the \code{plotmath} demo in R.)
\end{playground}

Function \code{update\_labels} allows the replacement of labels in an existing plot.

<<>>=
p <-
    ggplot(data = mtcars,
           aes(x=disp, y=hp, colour=factor(cyl),
               shape=factor(cyl))) +
      geom_point() +
      labs(x="Engine displacement)",
           y="Gross horsepower",
           color="Number of\ncylinders",
           shape="Number of\ncylinders")

update_labels(p, list(x = "Cilindrada",
                      y = "Potencia bruta (caballos de fuerza)",
                      color = "no. de\ncilindros",
                      shape = "no. de\ncilindros"))
@

The labels used in keys and axis tick-labels for factor levels can be changed through the different \emph{scales} as described in section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}.

\begin{explainbox}
Sometimes we would like to include in the title or as an annotation in the plot, the name of the argument passed to \code{ggplot}'s \code{data} parameter. To obtain the name of an object as a character string, the usual R ``slang'' is \code{deparse(substitute(x))} where \code{x} is the object.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  ggtitle(paste("Data:", deparse(substitute(Orange))))
@

The example above rarely is of much use, as we have anyway to pass the object itself twice, and consequently there is no advantage in effort compare to typing \code{"Data: Orange"} as argument to \code{ggtitle}. A more general way to solve this problem is to write a wrapper function.

<<>>=
ggwrapper <- function(data, ...) {
  ggplot(data, ...) +
    ggtitle(paste("Object: ", substitute(data)))
}

ggwrapper(data = Orange,
          mapping = aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0)
@

This is a bare-bones example, as it does not retain user control over the formatting of the title. The ellipsis (\code{...}) is a catch-all parameter that we use to pass all other arguments to \code{ggplot}. Because of the way our wrapper function is defined using ellipsis, we need to always pass \code{mapping} and other arguments that are to be ``forwarded'' to \code{ggplot} by name.

Using this function in a loop over a list or vector, will produce output is not as useful as you may expect. In many cases, the best, although more complex solution is to add case-specific code the loop itself to generate suitable titles automatically.

We create a suitable set of data frames, build a list with name \code{my.dfs} containing them.

<<>>=
df1 <- data.frame(x = 1:10, y = (1:10)^2)
df2 <- data.frame(x = 10:1, y = (10:1)^2.5)
my.dfs <- list(first.df = df1, second.df = df2)
@

If we print the output produced by the wrapper function when called in a loop but we get always the same title, so this approach is not useful.

<<>>=
for (df in my.dfs) {
  print(
    ggwrapper(data = df,
              mapping = aes(x = x, y = y)) +
      geom_line()
  )
}
@

\begin{warningbox}
 Automatic printing of objects is disabled within functions and iteration loops, making it necessary to use \code{print} explicitly in these cases (see loops above). This `inconsistency' in behaviour is frequently surprising to unexperienced R users, so keep in mind that if some chunk of R code unexpectedly fails to produce visible output, the most frequent reason is that \code{print} needs to be included in the code to make the `missing' result visible. Except for base R plotting functions, the norm in R is that printing, either implicitly or explicitly is needed for output to be visible to the user.
\end{warningbox}

As we have given names to the list members, we can use these and enclose the loop in a function. This is a very inflexible approach, and on top the plots are only printed, and the \code{ggplot} objects get discarded once printed.

<<>>=
plot.dfs <- function(x, ...) {
list.name <- deparse(substitute(x))
member.names <- names(x)
if (is.null(member.names)) {
  member.names <- as.character(seq_along(x))
}

  for (i in seq_along(x)) {
    print(
      ggplot(data = x[[i]], aes(x = x, y = y)) +
        geom_line() +
        ggtitle(paste("Object: ", list.name,
                      '[["', member.names[i], '"]]', sep = ""))
    )
  }

}
@

<<>>=
plot.dfs(my.dfs)
@

\begin{playground}
Study the output from the two loops, and analyse why the titles differ. This will help not only understand this problem, but the implications of formulating \code{for} loops in these three syntactically correct ways.
\end{playground}

As it should be obvious by now, is that as an object ``moves'' through the function-call stack its visible name changes. Consequently when we nest functions or use loops it becomes difficult to retrieve the name under which the object was saved by the user. After these experiments, is should be clear that saving the titles ``in'' the data frames would be the most elegant approach. It is possible to save additional data in R objects using attributes. R itself uses attributes to keep track of objects' properties like the names of members in a list, or the class of objects.

When one has control over the objects, one can add the desired title as an attribute to the data frame, and then retrieve and use this when plotting. One should be careful, however, as some functions and operators may fail to copy user attributes to their output.

\begin{playground}

As an advanced exercise I suggest implementing this attribute-based solution by tagging the data frames using a function defined as shown below or by directly using \code{attr}. You will also need modify the code to use the new attribute when building the \code{ggplot} object.

<<>>=
add.title.attr <- function(x, my.title) {
  attr(x, "title") <- my.title
  x
}
@

What advantages and disadvantages does this approach have? Can it be used in a loop?

\end{playground}

\end{explainbox}

\section{Tile plots}\label{sec:tileplot}

For the special case of heat maps see section \ref{sec:heatmap} on page \pageref{sec:heatmap}.

We here generate 100 random draws from the $F$ distribution with degrees of freedom $\nu_1 = 5, \nu_2 = 20$.

<<>>=
set.seed(1234)
randomf.df <- data.frame(z = rf(100, df1 = 5, df2 = 20),
                         x = rep(letters[1:10], 10),
                         y = LETTERS[rep(1:10, rep(10, 10))])
@

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile()
@

We can use \code{"white"} or some other contrasting color to better delineate the borders of the tiles.

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "white")
@

Any continuous fill scale can be used to control the appearance. Here we show a tile plot using a grey gradient.

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "grey15", high = "grey85", na.value = "red")
@

\section{Bar plots}\label{sec:plot:bar}

R users not familiar yet with \ggplot are frequently surprised by the default behaviour of \code{geom\_bar} as it uses \code{stat\_count} to compute the value plotted, rather than plotting values as is (see section \ref{sec:plot:summaries} on page \pageref{sec:plot:summaries}). The default can be changed, but \code{geom\_col} is equivalent to \code{geom\_bar} used with \code{"identity"} as argument to parameter \code{stat}. The \emph{statistic} \code{stat\_identity} just echoes its input. In previous sections, as when plotting points and lines, this statistic was used by default.

In this bar plot, each bar shows the number of observations in each \code{class} of car in the data set. We use a data set included in \ggplot for this example based on the documentation.
<<>>=
ggplot(mpg, aes(class)) + geom_bar()
@

We can easily get stacked bars grouped by the number of cylinders of the engine.

<<>>=
ggplot(mpg, aes(class, fill = factor(cyl))) + geom_bar()
@

The default palette used for \code{fill} is rather ugly, so we also show the same plot with another scale for fill.

<<>>=
ggplot(mpg, aes(class, fill = factor(cyl))) +
  geom_bar(color = "black") +
  scale_fill_brewer()
@

\section{Circular plots}

Under circular plots I include pie charts. Here we add a new "word" to the grammar of graphics, \textit{coordinates}, such as \code{coord\_polar()} in the next examples. The default coordinate system for $x$ and $y$ \textit{aesthetics} is cartesian.

Pie charts are more difficult to read: our brain is more comfortable at comparing
lengths than angles. If used, they should only be used to show composition, or
fractional components that add up to a total. In this case only if the number of
“pie slices” is small (rule of thumb: less than seven).

We make the equivalent of the first bar plot above. As we are still using \code{geom\_bar} the default is \code{stat\_count}. As earlier we use the brewer scale for nicer colors.

<<>>=
ggplot(data = mpg, aes(x = factor(1), fill = factor(class))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_brewer() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class")
@

Even with four slices pie charts can be difficult to read. Compare the following bar plot and pie chart.

<<>>=
ggplot(data = mpg, aes(x = factor(cyl), fill = factor(cyl))) +
  geom_bar(color = "black") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()

ggplot(data = mpg, aes(x = factor(1), fill = factor(cyl))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()
@

An example comparing pie charts to bar plots is presented in section \ref{sec:plot:pie:bar} on page \pageref{sec:plot:pie:bar}.

\section{Plotting summaries}\label{sec:plot:summaries}

The summaries discussed in this section can be superimposed on raw data plots, or plotted on their own. Beware, that if scale limits are manually set, the summaries will be calculated from the subset of observations within these limits. Scale limits can be altered when explicitly defining a scale or by means of functions \code{xlim()} and \code{ylim}. See section \ref{???} for a way of constraining the viewport (the region visible in the plot) while keeping the scale limits on a wider range of $x$ and $y$ values.

\subsection{Statistical ``summaries''}

It is possible to summarize data on-the-fly when plotting. We describe in the same section the calculation of measures of central position and of variation, as \code{stat\_summary} allows them to be calculated in the same function call.

For the examples we will generate some normally distributed artificial data.

<<>>=
fake.data <- data.frame(
  y = c(rnorm(10, mean=2, sd=0.5),
        rnorm(10, mean=4, sd=0.7)),
  group = factor(c(rep("A", 10), rep("B", 10)))
  )
@

We first use scatter plots for the examples, later we give some additional examples for bar plots.
We will reuse a ``base'' plot in a series of examples, so that the differences are easier to appreciate. We first add just the mean. In this case we need to pass as argument to \code{stat\_summary} the \code{geom} to use, as the default one, \code{geom\_pointrange}, expects data for plotting error bars in addition to the mean.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "mean", geom="point", color="red", shape="-", size=10)
@

Then the median, by changing the argument passed to \code{fun.y}.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "median", geom="point", colour="red", shape="-", size=10)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal", colour="red", size=1, alpha=0.7)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot", colour="red", size=1, alpha=0.7)
@

If needed, we can display less restrictive confidence intervals, at $p = 0.90$ in this example, by means of \code{conf.int = 0.90} passed as a list to the underlying function being called.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot",
               fun.args = list(conf.int = 0.90),
               colour = "red", size = 1, alpha = 0.7)
@

We can plot error bars corresponding to $\pm$s.e. (standard errors) with the function \code{"mean\_se"}, added in \ggplot 2.0.0.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_se",
               colour="red", size=1, alpha=0.7)
@

As \code{mult} is the multiplier based on the probability distribution used, by default student's {t}, by setting it to one, we get also standard errors of the mean.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal",
               fun.args = list(mult = 1),
               colour="red", size=1, alpha=0.7)
@

However, be aware that the code such as below (NOT EVALUATED HERE), as used in earlier versions of \ggplot, needs to be rewritten as above.

<<eval=FALSE>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal", mult = 1,
               colour="red", size=1, alpha=0.7)
@

Finally we can plot error bars showing $\pm$s.d. (standard deviation).

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_sdl", colour="red", size=1, alpha=0.7)
@

We do not give an example here, but instead of using these functions (from package \Hmisc) it is possible to define one's own functions. In addition as arguments to any function used, except for the first one containing the actual data, are supplied as a list through formal argument \code{fun.args}, there is a lot of flexibility with respect to what functions can be used.

Finally we plot the means in a scatter plot, with the observations superimposed and $p = 0.95$ confidence interval (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets mapping them to factors in the data set can be used to distinguish them. Adding \code{stat\_summary} twice allows us to plot the mean and the error bars using different colors.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  stat_summary(fun.y = "mean", geom = "point",
               fill="white", colour="black") +
  stat_summary(fun.data = "mean_cl_boot",
               geom = "errorbar",
               width=0.1, size=1, colour="red") +
  geom_point(size=3, alpha=0.3)
@

Similarly as with scatter plots, we can plot summaries as bars plots and add error bars.
If we supply a different argument to \code{stat} we can for example plot the means or medians for a variable, for each \code{class} of car.

<<>>=
ggplot(mpg, aes(class, hwy)) + geom_bar(stat = "summary", fun.y = mean)
@

<<>>=
ggplot(mpg, aes(class, hwy)) + geom_bar(stat = "summary", fun.y = median)
@

The ``reverse'' syntax is also possible, we can add the \emph{statistics} to the plot object and pass the \emph{geometry} as an argument to it.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

And we can easily add error bars to the bar plot. We use \code{size} to make the lines of the error bar thicker, and a value smaller than zero for \code{fatten} to make the point smaller. The default \code{geom} for \code{stat\_summary} is \code{"pointrange"}.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(fun.data = "mean_se", size = 1,
               fatten = 0.5, color = "red")
@

Instead of making the point smaller, we can pass \code{"linerange"} as argument for \code{geom} to eliminate the point completely.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "linerange",
               fun.data = "mean_se", size = 1,
               color = "red")
@

Passing \code{"errorbar"} to \code{geom} results in more traditional error bars, however, this type of error bars has been criticized as adding unnecesary clutter to plots \autocite{TufteXXXX}. We use \code{width} to reduce the width of the cross lines at the ends of the bars.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "errorbar",
               fun.data = "mean_se", width = 0.1, size = 1,
               color = "red")
@

If we have ready calculated values for the summaries, we can still obtain the same plots. Here we calculate the summaries before plotting, and then redraw the plot immediately above.

<<>>=
mpg_g <- dplyr::group_by(mpg, class)
mpg_summ <- dplyr::summarise(mpg_g, hwy_mean = mean(hwy),
                                    hwy_se = sd(hwy) / sqrt(n()))

ggplot(mpg_summ, aes(x = class,
                     y = hwy_mean,
                     ymax = hwy_mean + hwy_se,
                     ymin = hwy_mean - hwy_se)) +
  geom_col() +
  geom_errorbar(width = 0.1, size = 1, color = "red")
@

\section{Fitted smooth curves}

The \emph{statistic} \code{stat\_smooth} fits a smooth curve to observations in the case when the scales for $x$ and $y$ are continuous. For the first example, we use the default smoother, a spline. The type of spline is automatically chosen based on the number of observations.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
       stat_smooth()
@

In most cases we will want to plot the observations as points together with the smoother. We can plot the observation on top of the smoother, as done here, or the smoother on top of the observations.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
  stat_smooth() +
  geom_point()
@

Instead of using the default spline, we can fit a different model. In this example we use a linear model as smoother, fitted by \code{lm}.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
  stat_smooth(method="lm") +
  geom_point()
@

These data are really grouped, so we map the grouping to the \code{color} \emph{aesthetic}. Now we get three groups of points with different colours but also three separate smooth lines.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm") +
  geom_point()
@

To obtain a single smoother for the three groups, we need to set the mapping of the \code{color} \emph{aesthetic} to a constant within \code{stat\_smooth}. This local value overrides the default for the whole plot set with \code{aes} just for this single \emph{statistic}. We use \code{"black"} but this could be replaced by any other color definition known to R.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm", colour="black") +
  geom_point()
@

Instead of using the default \code{formula} for a linear regression as smoother, we pass a different \code{formula} as argument. In this example we use a polynomial of order 2 fitted by \code{lm}.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm", formula=y~poly(x,2), colour="black") +
  geom_point()
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use of these more advanced models in this section.

\begin{warningbox}
The different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. The \code{alpha} (transparency) aesthetic can be mapped to a constant to make underlying layers visible, or \code{alpha} can be mapped to a data variable for example making the transparency of points in a plot depend on the number of observations used in its calculation.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
  geom_point() +
  geom_smooth(colour="black", alpha=0.7) +
  theme_bw()
@

The plot looks different if the order of the geoms is swapped. The data points overlapping the confidence band are more clearly visible in this second example because they are above the shaded area instead of bellow it.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
  geom_smooth(colour="black", alpha=0.7) +
  geom_point() +
  theme_bw()
@
\end{warningbox}

\section{Frequencies and densities}

A different type of summaries are frequencies and empirical density functions. These can be calculated in one or more dimensions. Sometimes instead of being calculated, we rely on the density of graphical elements to convey the density. Sometimes, scatter plots using a well chosen value for \code{alpha} give a satisfactory impression of the density. Rug plots, described below work in a similar way.

\subsection{Marginal rug plots}

Rarely rug-plots are used by themselves. Instead they are usually an addition to
scatter plots. An example follows. They make it easier to see the distribution
along the $x$- and $y$-axes.

We generate new fake data by random sampling from the normal distribution. We use \code{set.seed(1234)} to initialize the pseudo-random number generator so that
the same data are generated each time the code is run.

<<>>=
set.seed(12345)
my.data <-
  data.frame(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug()
@

\subsection{Histograms}\label{sec:histogram}

Histograms are defined by how the plotted values are calculated. Although they are most frequently plotted as bar plots, many bar plots are not histograms. Although rarely done in practice, a histogram could be plotted using a different \emph{geometry} and \code{stat\_bin} the \emph{statistic} used by default by \code{geom\_histogram}. This statistics does binning of observations before computing frequencies, as is suitable for continuous $x$ scales. For categorical data \code{stat\_count} should be used, which as seen in section \ref{sec:plot:bar} on page \pageref{sec:plot:bar} is the default \code{stat} for \code{geom\_bar}.

<<>>=
ggplot(my.data, aes(x)) +
  geom_histogram(bins = 15)
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "dodge")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "stack")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "identity", alpha = 0.5) +
  theme_bw(16)
@

The \emph{geometry} \code{geom\_bin2d} by default uses the \emph{statistic} \code{stat\_bin2d} which can be thought as a histogram in two dimensions. The frequency for each rectangle is mapped onto a \code{fill} scale.

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_bin2d(bins = 8) +
  facet_wrap(~group)
@

The \emph{geometry} \code{geom\_hex} by default uses the \emph{statistic} \code{stat\_binhex} which can be thought as a histogram in two dimensions. The frequency for each hexagon is mapped onto a \code{fill} scale.

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 8) +
  facet_wrap(~group)
@


\subsection{Density plots}\label{sec:plot:density}

Empirical density functions are the equivalent of a histogram, but are continuous and not calculated using bins. They can be calculated in 1 or 2 dimensions (2d), for $x$ or $x$ and $y$ respectively. As with histograms it is possible to use different \emph{geometries} to visualize them.

<<>>=
ggplot(my.data, aes(x, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_density(alpha = 0.5)
@

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_density_2d()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_density_2d() +
  facet_wrap(~group)
@

<<>>=
ggplot(my.data, aes(x, y)) +
stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\subsection{Box and whiskers plots}\label{sec:boxplot}

Box and whiskers plots, also very frequently called just boxplots, are also summaries that convey some of the characteristics of a distribution. Although they can be calculated and plotted based on just a few observations, they are not useful unless each box plot is based in more than 10 to 15 observations.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_boxplot()
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as color, and others specific to these type of visual representation.

\subsection{Violin plots}\label{sec:plot:violin}

Violin plots are a more recent development than box plots, and usable with relatively large numbers of observations. They could be thought as being a sort of hybrid between an empirical density function and a box plot. As is the case with box plots, they are particularly useful when comparing distributions of related data, side by side.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_violin()
@

<<>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_point(alpha = 0.33, size = rel(4),
             colour = "black", shape = 21)
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as color, and others specific to these type of visual representation.

\section{Using facets}

Sets of coordinated plots are a very useful tool for visualizing data. These became popular through the \code{trellis} graphs in S, and the \code{lattice} package in R. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \ggplot there are two possible types of facets: facets organized in a grid, and facets along a single `axis' but wrapped into several rows. In the examples below we use \code{geom\_point} but faceting can be used with any \code{ggplot} object (even with maps, spectra and ternary plots produced by functions in packages \ggmap, \ggspectra and \ggtern.

\begin{warningbox}
  The code underlying faceting has been rewritten in \ggplot version 2.2.0. All the examples given here are backwards compatible with versions 2.1.0 and possibly 2.0.0. The new functionality is related to the writing of extensions or controlled through themes, and will be discussed in other sections.
\end{warningbox}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p <- ggplot(data = mtcars, aes(mpg, wt)) + geom_point()
# With one variable
p + facet_grid(. ~ cyl)
@

<<>>=
p + facet_grid(cyl ~ .)
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free")
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free", space = "free")
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_grid(vs ~ am)
@

<<>>=
p + facet_grid(vs ~ am, margins=TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p + facet_grid(. ~ vs + am)
@

<<>>=
p + facet_grid(. ~ vs + am, labeller = label_both)
@

<<>>=
p + facet_grid(. ~ vs + am, margins=TRUE)
@

<<>>=
p + facet_grid(cyl ~ vs, labeller = label_both)
@

<<>>=
mtcars$cyl12 <- factor(mtcars$cyl,
                       labels = c("alpha", "beta", "sqrt(x, y)"))
p1 <- ggplot(data = mtcars, aes(mpg, wt)) +
      geom_point() +
      facet_grid(. ~ cyl12, labeller = label_parsed)
@

Here we use as \code{labeller} function \code{label\_bquote()} with a special syntax that allows us to use an expression where replacement based on the facet (panel) data takes place.

<<>>=
p + facet_grid(. ~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

\sloppy
In versions of \ggplot2 before 2.0.0, \code{labeller} was not implemented for \code{facet\_wrap()}, it was only available for \code{facet\_grid()}.

<<>>=
p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

A minimal example of a wrapped facet. In this case the number of levels is
small, when they are more the row of plots will be wrapped into two or more
continuation rows. When using \code{facet\_wrap()} there is only one dimension, so no `.'
 is needed before or after the tilde.

<<>>=
p + facet_wrap(~ cyl)
@

An example showing that even though faceting with \code{facet\_wrap()} is along a single, possibly wrapped, row, it is possible to produce facets based on more than one variable.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_wrap(~ vs + am, ncol=2)
@

%In versions of \ggplot before 2.0.0, \code{labeller} was not implemented for
%\code{facet\_wrap()}, it was only available for \code{facet\_grid()}. In the current
%version it is implemented for both.
%
%<<echo=FALSE>>=
%opts_chunk$set(opts_fig_wide)
%@
%
%<<>>=
%p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
%@

\section{Scales}\label{sec:plot:scales}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted geometrical object, such as \code{color}, \code{size}, position (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the $x$-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also map the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different palette, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Remeber that for example for colour, and `numbers' there are both discrete and continuous scales available. Mapping colour or fill to \code{NA} makes such observation invisible.

\sloppy
Advanced scale manipulation requires package \code{scales} to be loaded, although \ggplot 2.0.0 and later re-exports many functions from package \code{scales}. Some simple examples follow.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

We generate new fake data.

<<>>=
fake2.data <-
  data.frame(y = c(rnorm(20, mean=20, sd=5),
                   rnorm(20, mean=40, sd=10)),
             group = factor(c(rep("A", 20), rep("B", 20))),
             z = rnorm(40, mean=12, sd=6))
@

\subsection{Continuous scales for $x$ and $y$}

\subsubsection{Limits}

To change the limits of the $y$-scale, \code{ylim()} is a convenience function used for modification of the \code{lims} (limits) of the scale used by the $y$ aesthetic. We here exemplify the use of \code{ylim} only, but \code{xlim} can be used equivalently for the $x$ scale.

We can set both limits, minimum and maximum.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(0, 100)
@

We can set both limits, minimum and maximum, reversing the direction of the axis scale.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(100, 0)
@

We can set one limit and leave the other one free.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(0, NA)
@

We can use \code{lims} with discrete scales, listing all the levels that are to be included in the scale, even if they are missing from a given data set, such as after subsetting.

And we can expand the limits, to set a default minimum range, that will grow when needed to accommodate all observations in the data set. Of course here \code{x} and \code{y} refer to the \emph{aesthetics} and not to names of variables in data frame \code{fake2.data}.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + expand_limits(y = 0, x = 0)
@

\subsubsection{Transformed scales}

The default scale used by the \code{y} aesthetic uses \code{position = "identity"}, but there are predefined for transformed scales.

Although transformations can be passed as argument to \code{scale\_x\_continuous} and \code{scale\_y\_continuous}, there are predefined convenience scale functions for \code{log10}, \code{sqrt} and \code{reverse}.

\begin{warningbox}
  Similarly to the maths functions of R, the name of the scales are \code{scale\_x\_log10} and \code{scale\_y\_log10} rather than \code{scale\_y\_log} because in R the function \code{log} returns the natural or Neperian logarithm.
\end{warningbox}

We can use \code{scale\_x\_reverse} to reverse the direction of a continuous scale,

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + scale_x_reverse()
@

Axis tick-labels display the original values before applying the transformation. The \code{"breaks"} need to be given in the original scale as well. We use \code{scale\_y\_log10} to apply a $\log_{10}$ transformation to the $y$ values.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_log10(breaks=c(10,20,50,100))
@

In contrast, transforming the data on-the-fly when mapping it to the $x$ \emph{aesthetic}, results in tick-labels expressed in the logarithm of the original data.

<<>>=
ggplot(fake2.data, aes(z, log10(y))) + geom_point()
@

We show here how to specify a transformation to a continuous scale, using a predefined ``transformation'' object.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(trans = "reciprocal")
@

Natural logarithms are important in growth analysis as the slope against time gives the relative growth rate. We show this with the \code{Orange} data set.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  scale_y_continuous(trans = "log", breaks = c(20, 50, 100, 200))
@

In section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} we define and use a transformation object.

\begin{warningbox}
When combining scale transformations and summaries, one should be aware of which data are used, transformed or not.
\end{warningbox}

\subsubsection{Tick labels}

Finally, when wanting to display tick labels for data available as fractions as percentages, we can use
\code{labels = scales::percent}.

<<>>=
ggplot(fake2.data, aes(z, y / max(y))) +
  geom_point() +
  scale_y_continuous(labels = scales::percent)
@

\sloppy
In the case of currency we can use \code{labels = scales::dollar}, and if we want to use commas to separate thousands, millions, and so on, we can use \code{labels = scales::comma}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::dollar)
@

When using breaks, we can just accept the default labels for the \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60))
@

We can also set tick labels manually, in parallel to the setting of \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", "->", "60"))
@

Using an expression we obtain a Greek letter.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", expression(alpha), "60"))
@

We can pass a function that accepts the breaks and returns labels to \code{labels}. Package \scales defines several formatters, or we can define our own. For \code{log10} scales

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::scientific_format())
@

\sloppy
Please, see section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} for an example of the use of \code{scales::math\_format} together with a logarithmic transformation of the data.

\subsection{Time and date scales for $x$ and $y$}

\subsubsection{Limits}

Time and date scales are conceptually similar to continuous numeric scales, but use special data types and formatting for labels. We can set limits and breaks using constants as time or dates. These are most easily input with the functions in packages \pkgname{lubridate} or \pkgname{anytime}.

Please, see section \ref{sec:ggpmisc:trydf} on page \pageref{sec:ggpmisc:trydf} for examples.

\subsubsection{Axis labels}

By default the tick labels produced and their formatting is automatically selected based on the extent of the time data. For example, if we have all data collected within a single day, then the tick labels will show hours and minutes. If we plot data for several years, the labels will show the date portion of the time instant. The default is frequently good enough, but it is possible, as for numbers to use different formatter functions to generate the tick labels.

\subsection{Discrete scales for $x$ and $y$}

In the case of ordered or unordered factors, the tick labels are by default the names of the factor levels. Consequently one roundabout way to obtaining the desired tick labels is to use them as factor levels. This approach is not recommended as in most cases the text of the desired tick labels may not be recognized as a valid name making the code using them difficult to type in scripts or at the command prompt. It is best to use simple mnemonic short names for factor levels and variables, and to set suitable labels when plotting, as we will show here.

\begin{explainbox}
When using factors, the ordering used for plotting levels is the one they have in the factor. When a factor is created, the default is for levels to be stored in alphabetical order. This default can be easily overridden at the time of creation, as well as the order modified at a later time.

<<>>=
default.fct <- factor(c("a", "c", "f", "f", "a", "d"))
levels(default.fct)
@

<<>>=
levels.fct <- factor(c("a", "c", "f", "f", "a", "d"),
                      levels = c("f", "a", "d", "c"))
levels(levels.fct)
@

Reorder can be used to change the order of the levels based on the values of a numeric variable. We will visit once again the \code{Orange} data set.

<<>>=
my1.Tree <- with(Orange,
                reorder(Tree, -circumference))
levels(Orange$Tree)
levels(my1.Tree)
@

Which is equivalent to reversing the order in this particular case.

<<>>=
my2.Tree <- with(Orange,
                factor(Tree,
                levels = rev(levels(Tree))))
levels(Orange$Tree)
levels(my2.Tree)
@

We restore the default ordering.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = sort(levels(Tree))))
levels(Orange$Tree)
levels(my3.Tree)
@

We can set the levels in any arbitrary order by explicitly listing the level names, not only at the time of creation but also later. Here we show that it is possible to not only reorder existing levels, but even to add a level for which there are no observations.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = c("1", "2", "3", "4", "5", "9")))
levels(Orange$Tree)
levels(my3.Tree)
@

\end{explainbox}

We use here once again the \code{mpg} data set.

We order the columns in the plot based on \code{mpg\$hwy} by reordering \code{mpg\$class}. This approach makes sense if this ordering is needed for all plots. It is always bad to keep several versions of a single data set as it easily leads to mistakes and confusion.

<<>>=
my.mpg <- mpg
my.mpg$class <- with(my.mpg, reorder(factor(class), hwy))
ggplot(my.mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or the same on-the-fly, which is much better as the data remains unmodified..

<<>>=
ggplot(mpg, aes(reorder(factor(class), hwy), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or ordering based on a different variable, \code{displ}.

<<>>=
ggplot(mpg, aes(reorder(factor(class), displ), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Alternatively we can use \code{scale\_x\_discrete} to reorder and select the columns without altering the data. If we use this approach to subset the data, then to avoid warnings we need to add \code{na.rm = TRUE}. We use the scale in this example to convert level names to uppercase. The complementary function of \code{toupper} is \code{tolower}.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean, na.rm = TRUE) +
  scale_x_discrete(limits = c("compact", "subcompact", "midsize"),
  labels = toupper)
@

\subsection{Size}

For the \code{size} \emph{aesthetic} several scales are available, both discrete and continuous. They do not differ much from those already described above. \emph{Geometries} \code{geom\_point}, \code{geom\_line}, \code{geom\_hline}, \code{geom\_vline}, \code{geom\_text}, \code{geom\_label} obey \code{size} as expected. In the case of \code{geom\_bar}, \code{geom\_col}, \code{geom\_area} and all other geometric elements bordered by lines, \code{size} is obeyed by these border lines. In fact, other aesthetics natural for lines such as \code{linetype} also apply to these borders.

When using \code{size} scales, \code{breaks} and \code{labels} affect the key or \code{guide}. In scales that produce a key passing \code{guide = FALSE} removes the key corresponding to the scale.

\subsection{Color and fill}

Colour and fill scales are similar, but they affect different elements of the plot. All visual elements in a plot obey the \code{color} \emph{aesthetic}, but only elements that have an inner region and a boundary, obey both \code{color} and \code{fill} \emph{aesthetics}. There are separate but equivalent sets of scales available for these two aesthetics. We will describe in more detail the \code{color} \emph{aesthetic} and give only some examples for \code{fill}. We will however, start by reviewing how colors are defined and used in R.

\subsubsection{Color definitions in R}\label{sec:plot:colors}

Colors can be specified in R not only through character strings with the names of previously defined colors, but also directly as strings describing the RGB components as hexadecimal numbers (on base 16) such as \code{"\#FFFFFF"} for white or \code{"\#000000"} for black, or \code{"\#FF0000"} for the brightest available pure red. The list of color names known to R can be obtained be entering \code{colors()} in the console.

Given the number of colors available, we may want to subset them based on their names. Function \code{colors()} returns a character vector. We can use \code{grep()} or \code{grepl()} to find indexes to the names containing a given character substring, in this example \code{"dark"}.

<<>>=
grep("dark",colors())
@

\begin{playground}
Replace \code{grep} by \code{grepl} in the example above. What is the difference in the returned value?
\end{playground}

Although the vector of indexes, or the logical vector, could be used to extract the subset of matching color names with code like,

<<>>=
colors()[grep("dark",colors())]
@

a simpler approach is available.

<<>>=
grep("dark", colors(), value = TRUE)
@

To retrieve the RGB values for a color definition we use

<<>>=
col2rgb("purple")
col2rgb("#FF0000")
@

Color definitions in R can contain a \emph{transparency} described by an \code{alpha} value, which by default is not returned.

<<>>=
col2rgb("purple", alpha = TRUE)
@

With function \code{rgb()} we can define new named or nameless colors.
<<>>=
rgb(1, 1, 0)
rgb(1, 1, 0, names = "my.color")
rgb(255, 255, 0, names = "my.color", maxColorValue = 255)
@

As described above colors can be defined in the RGB \emph{color space}, however, other color models such as HSV (hue, saturation, value) can be also used to define colours.

<<>>=
hsv(c(0,0.25,0.5,0.75,1), 0.5, 0.5)
@

The probably a more useful flavour of HSV colors are those returned by function \code{hcl()} for hue, chroma and luminance. While the ``value'' and ``saturation'' in HSV are based physical values, the ``chroma'' and ``luminance'' values in HCL are based on human visual perception. Colours with equal luminance will be as equally bright by average human being. In a scale based on different hues but equal chroma and luminance values, as used by package \ggplot, all colours are perceived as equally bright. The hues need to be expressed as angles in degrees, with values between zero and 360.

<<>>=
hcl(c(0,0.25,0.5,0.75,1) * 360)
@

It is also important to remember that humans can only distinguish a limited set of colours, and even smaller colour gamuts can be reproduced by screens and printers. Furthermore, variation from individual to individual exists in color perception, including different types of colour blindness. It is important to take this into account when using colour in illustrations.

\subsection{Continuous colour-related scales}

\sloppy
Scales \code{scale\_color\_continuous}, \code{scale\_color\_gradient}, \code{scale\_color\_gradient2},  \code{scale\_color\_gradientn}, \code{scale\_color\_date} and \code{scale\_color\_datetime}, give a smooth continuous gradient between two or more colours. They are useful for numerical, date and datetime data. A corresponding set of \code{fill} scales is also available.

\subsection{Discrete colour-related scales}

\sloppy
Scales \code{scale\_color\_discrete}, \code{scale\_color\_hue}, \code{scale\_color\_grey} are useful for categorical data stored as factors.

\subsection{Identity scales}

In the case of identity scales the mapping is 1 to 1 to the data. For example, if we map the \code{color} or \code{fill} \emph{aesthetic} to a variable using \code{scale\_color\_identity} or \code{scale\_fill\_identity} the variable in the data frame passed as argument for \code{data} must already contain valid color definitions. In the case of mapping \code{alpha} the variable must contain numeric values in the rage 0 to 1.

We create a data frame containing a variable \code{colors} containing character strings interpretable as the names of color definitions known to R. We then use them directly in the plot.

<<>>=
df99 <- data.frame(x = 1:10, y = dnorm(10), colors = rep(c("red", "blue"), 5))

ggplot(df99, aes(x, y, color = colors)) +
  geom_point() +
  scale_color_identity()
@

\begin{playground}
How does the plot look, if the identity scale is deleted from the example above? Edit and re-run the example code.
\end{playground}

\begin{playground}
While using the identity scale, how would you need to change the code example above, to produce a plot with green and purple point?
\end{playground}

\subsection{Position of axes}

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_x_continuous(position = "top") +
  scale_y_continuous(position = "right")
@

\subsection{Secondary axes}

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ . ^-1, name = "1/y")
  )
@

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ ., name = "y", breaks = c(33.2, 55.4))
  )
@

\section{Adding annotations}

Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the \code{ggplot} object. In this example we pass directly expressions as tick labels through the scale. Do notice that we use recycling for setting the breaks, as \code{c(0, 0.5, 1, 1.5, 2) * pi} is equivalent to \code{c(0, 0.5 * pi, pi, 1.5 * pi, 2 * pi}. Annotations are plotted at their own position, unrelated to any observation in the data.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)") +
  annotate(geom="text",
           label=c("+", "-"),
           x=c(0.5, 1.5) * pi, y=c(0.5, -0.5),
           size=20) +
  annotate(geom="point",
           colour="red",
           shape=21,
           fill="white",
           x=c(0, 1, 2) * pi, y=0,
           size=6)
@

\section{Themes}
\subsection{Predefined themes}
\subsection{Tweaking a theme}
\subsection{Defining a new theme}

\section{Advanced topics}

\section[Using plotmath expressions]{Using \code{plotmath} expressions}\label{sec:plot:plotmath}

In sections \ref{sec:plot:function} and \ref{sec:plot:text} we gave some simple examples of the use of R expressions in plot. The \code{plotmath} demo and help in R give all the details of using expressions in plots. Composing syntactically correct expressions can be challenging. Expressions are very useful but rather tricky to use because the syntax is unusual. Although expressions are here shown in the context of plotting, they are also used in other contexts in R code as described in section \ref{sec:??} on page \pageref{sec:??}.

In \code{ggplot} one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined within \code{labs}) the expressions have to be entered explicitly, or saved as such into a variable, and the variable supplied as argument.

When plotting expressions using \code{geom\_text} expression arguments should be supplied as character strings and the optional argument \code{parse = TRUE} used to tell the \emph{geometry} to interpret the labels as expressions.

Finally in the case of facets, panel labels can also also be expressions. They can be generated by \emph{labeller} functions to allow them to be dynamic.

Before examples using these different mechanisms to add maths to plots, I will describe the syntax used to write expressions. The most difficult thing to remember is how to connect the different parts of the expression. Tilde (\code{~}) adds space in between symbols. Asterisk (\code{*}) can be also used as a connector, and is needed usually when dealing with numbers. Using space is allowed in some situations, but not in others. For a long list of examples have a look a the output and code displayed by \code{demo(plotmath)} at the R command prompt.

<<eval=FALSE>>=
demo(plotmath)
@

We will use a couple of complex examples to show in each plot how to use expressions for different elements of a plot.

We first create a data frame, using \code{paste} to assemble a vector of subscripted $\alpha$ values.
<<>>=
set.seed(54321) # make sure we always generate the same data
my.data <-
  data.frame(x = 1:5, 
             y = rnorm(5),
             greek.label = paste("alpha[", 1:5, "]", sep = ""))
# my.data$greek.label <- paste("alpha[", my.data$x, "]", sep="")
@

We a lso use a Greek $\alpha$ character, but with $i$ as subscript, instead of a number. The $y$-axis label uses a superscript for the units. The title is a rather complex expression. In these three cases, we explicitly use \code{expression()}.

We label each observation with a subscripted $alpha$, offset from the point position and rotated. We finally add an annotation with the same formula as used for the title but in red. Annotations are plotted ignoring the default aesthetics, but still make use of \emph{geometries}. We cannot pass expressions to \emph{geometries} by simply mapping them to the label aesthetic. Instead, we pass character strings that can be parsed into expressions. In simpler terms, a string, that is written using the syntax of expressions but not using the function \code{expression()}. We need to set \code{parse = TRUE} so that the strings instead of being plotted as is, are parsed into expressions at the time the plot is output.

<<>>=
ggplot(my.data, aes(x,y,label=greek.label)) +
   geom_point() +
   geom_text(angle=45, hjust=1.2, parse=TRUE) + 
   labs(x = expression(alpha[i]), 
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label="sqrt(alpha[1] + frac(beta, gamma))",
           y=2.5, x=3, size=8, colour="red", parse=TRUE) +
   expand_limits(y = c(-2, 4))
@

The example above is fairly complex, but does not use expressions for all the elements that accept them. The next example uses them for scale labels. In the cases of scales, this there are alternative approaches. The simplest approach is to use user-supplied labels to be parsed into expressions.

<<>>=
ggplot(my.data, aes(x,y,label=greek.label)) +
   geom_point() +
   geom_text(angle=45, hjust=1.2, parse=TRUE) +
   labs(x = NULL,
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label="sqrt(alpha[1] + frac(beta, gamma))",
           y=2.5, x=3, size=8, colour="red", parse=TRUE) +
   scale_x_continuous(breaks = c(1,3,5), 
                      labels = c(expression(alpha[1]), expression(alpha[3]), expression(alpha[5]))
                      ) +
   expand_limits(y = c(-2, 4))
@

It is also possible to substitute the value of variables into an expression, allowing on-the-fly construction of expressions to be used as labels.

\textbf{EXAMPLES COMING SOON}


\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
pdf(file="fig1.pdf", width=8, height=6)
print(fig1)
dev.off()
@

Encapsulated Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file="fig1.eps", width=8, height=6)
print(fig1)
dev.off()
@

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file="fig1.tiff", width=1000, height=800)
print(fig1)
dev.off()
@

\subsection{Using \LaTeX\ instead of plotmath}

To use \LaTeX\ syntax in plots we need to use a different \emph{software device} for output. It is called \code{Tikz} and defined in package \pkgname{tikzDevice}. This device generates output that can be interpreted by \LaTeX\ either as a self-contained file or as a file to be input into another \LaTeX\ source file. As the bulk of this handbook does not use this device, we will use it explicitly and input the files into this section. A \TeX\ distribution should be installed, with \LaTeX\ and several (\LaTeX) packages including \pkgname{tikz}.

\subsection{Fonts}

Font face selection, weight, size, maths, etc. are set with \LaTeX\ syntax. The main advantage of using \LaTeX\ is the consistency between the typesetting of the text body and figure labels and legends. For those familiar with \LaTeX\ not having to remember/learn the syntax of plotmath will a bonus.

We will revisit the example from the previous sections, but now using \LaTeX\ for the subscripted Greek $\alpha$ for labels instead of \code{plotmath}. In this example we use as subscripts numeric values from another variable in the same dataframe.

\section{Examples}

In this section we first produce some publication-ready plots requiring the use of different combinations of what has been presented earlier in this chapter and then we recreate some well known plots, using versions from Wikipedia articles as models. Our objective here is to show, how by combining different terms and modifiers from the grammar of graphics we can build step by step very complex plots and/or annotate them with sophisticated labels. Here we do not use any packages extending \ggplot2. Even more elaborate versions of these plots are presented in later chapters using \ggplot together with other packages.

\subsection{Heat maps}\label{sec:heatmap}

Heat maps are 3D plots, with two axes with cartesian coordinates giving origin to rectangular tiles, with a third dimension represented by the \code{fill} of the tiles. They are used to describe deviations from a reference or controls condition, with for example, blue representing values below the reference and red above. A color gradient represents the size of the deviation. Simple heat maps can be produced directly with \ggplot functions and methods. Heat maps with similitude trees obtained through clustering require additional tools.

The main difference with a generic tile plot (See section \ref{sec:tileplot} on page \pageref{sec:tileplot}) is that the fill scale is centred on zero and the red to blue colours used for fill represent a ``temperature''. Nowadays, the name \emph{heatmap} is also used for tile plots using other color for fill, as long as they represent deviations from a central value.

\sloppy
To obtain a heat map, then we need to use as fill scale \code{scale\_fill\_gradient2}. In the first plot we use the default colors for the fill, and in second example we use different ones.

For the examples in this section we use artificial data to build a correlation matrix, which we convert into a data frame before plotting.

<<>>=
set.seed(123)
x <- matrix(rnorm(200), nrow=20, ncol=10)
y <- matrix(rnorm(200), nrow=20, ncol=10)
cor.mat <- cor(x,y)
cor.df <- data.frame(cor = as.vector(cor.mat),
           x = rep(letters[1:10], 10),
           y = LETTERS[rep(1:10, rep(10, 10))])
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2()
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "darkred", mid = "yellow",
  high = "darkgreen")
@

\subsection{Quadrat plots}

A quadrat plot is usually a scatter plot, although sometimes lines are also used. The scales are symmetrical both for $x$ and $y$ and negative and positive ranges: the origin $x = 0, y = 0$ is at the geometrical center of the plot.

We generate an artificial data set with \code{y} values correlated to \code{x} values.

<<>>=
set.seed(4567)
x <- rnorm(200, sd = 1)
quadrat_data.df <- data.frame(x = x,
                              y = rnorm(200, sd = 0.5) + 0.5 * x)
@

Here we draw a simple quadrat plot, by adding two lines and using fixed coordinates with a 1:1 ratio between $x$ and $y$ scales.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point() +
    coord_fixed(ratio = 1) +
    theme_bw()
@

We may want to add lines showing 1:1 slopes, make the axes limits symmetric, and make points semi-transparent to allow overlapping points to be visualized. We expand the limits with \code{expand\_limits} rather that set them with \code{limits} or \code{xlim} and \code{ylim}, so that if there are observations in the data set outside our target limits, the limits will still include them. In other words, we set a minimum expanse for the limits of the axes, but allow them to \emph{grow} further if needed.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
    geom_abline(slope = -1, intercept = 0, color = "blue", linetype = "dashed") +
    geom_point(alpha = 0.5) +
    scale_color_identity(guide = FALSE) +
    scale_fill_identity(guide = FALSE) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@

It is also easy to add a linear regression line with its confidence band.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    stat_smooth(method = "lm") +
    geom_point(alpha = 0.5) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@

\subsection{Volcano plots}\label{sec:plot:volcano}

A volcano plot is just an elaborate version of a scatter plot, and can be created with \ggplot functions.
We here demonstrate how to create a volcano plot with tick labels in untransformed units, off-scale values drawn at the edge of the plotting region and highlighted with a different shape, and points color coded according to whether expression is significantly enhanced or depressed, or the evidence for the direction of the effect is inconclusive. We use a random sample of size 5000 from real data from an RNAseq experiment.

<<>>=
load(file = "data/volcano-example.rda")
head(clean5000.df, 4)
@

First we create a no-frills volcano plot. This is just an ordinary scatter plot, with a certain way of transforming the $P$-values. We do this transformation on the fly when mapping the $y$ aesthetic with \code{y = -log10(PValue)}.

<<>>=
ggplot(data = clean5000.df,
         aes(x = logFC,
             y = -log10(PValue),
             color = factor(outcome))) +
    geom_point() +
    scale_color_manual(values = c("blue", "grey10", "red"), guide = FALSE)
@

Now we add quite many tweaks to the $x$ and $y$ scales. 1) we show tick labels in back-transformed units, at \emph{nice} round numbers. 2) We add publication-ready axis labels. 3) We restrict the limits of the $x$ and $y$ scales, but use \code{oob = scales::squish} so that instead of being dropped observations outside the range limits are plotted at the limit and highlighted with a a different \code{shape}. We also use the black and white \emph{theme} instead of the default one.

As we assume the reverse log transformation to be generally useful we define a function \code{reverselog\_trans} for it. In the plot we use this function to set the transformation as part of the $y$-scale definition, so that we can directly map $P$-values to the $y$ \emph{aesthetic}.

<<>>=
reverselog_trans <- function(base = exp(1)) {
  trans <- function(x) -log(x, base)
  inv <- function(x) base^(-x)
  scales::trans_new(paste0("reverselog-", format(base)), trans, inv,
                    scales::log_breaks(base = base),
                    domain = c(1e-100, Inf))
}

ggplot(data = clean5000.df,
         aes(x = logFC,
             y = PValue,
             color = factor(outcome),
             shape = factor(ifelse(PValue <= 1e-50, "out", "in")))) +
    geom_vline(xintercept = c(log2(2/3), log2(3/2)), linetype = "dotted",
               color = "grey75") +
    geom_point() +
    scale_color_manual(values = c("blue", "grey80", "red"), guide = FALSE) +
    scale_x_continuous(breaks = c(log2(1e-3), log2(1e-2), log2(1e-1), log2(1/2),
                                  0, log2(2), log2(1e1), log2(1e2), log2(1e3)),
                       labels = c("1/1000", "1/100", "1/10", "1/2", "1",
                                  "2", "10", "100", "1000"),
                       limits = c(log2(1e-3), log2(1e3)),
                       name = "Relative expression",
                       minor_breaks = NULL) +
    scale_y_continuous(trans = reverselog_trans(10),
                       breaks = c(1, 1e-3, 1e-10, 1e-20, 1e-30, 1e-40, 1e-50),
                       labels = scales::trans_format("log10",
                                                     scales::math_format(10^.x)),
                       limits = c(1, 1e-50), # axis is reversed!
                       name = expression(italic(P)-{value}),
                       oob = scales::squish,
                       minor_breaks = NULL) +
    scale_shape(guide = FALSE) +
    theme_bw()
@

\subsection{Anscombe's regression examples}

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}.

This classical example form \citeauthor{Anscombe1973} (\citeyear{Anscombe1973}) demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

I will redraw the Wikipedia figure using \ggplot, but first I rearrange the original data.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- data.frame(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

Once the data is in a data frame, plotting the observations plus the regression lines is easy.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2)
@

It is not much more difficult to make it look similar to the Wikipedia original.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm", se=FALSE) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@

Although I think that the confidence bands make the point of the example much clearer.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@

\subsection{Plotting color patches}

For choosing colours when designing plots, or scales used in them, an indexed colour patch plot is usually very convenient (see section \ref{sec:plot:colors} on page \pageref{sec:plot:colors}. We can produce such a chart of colors with subsets of colors, or colours re-ordered compared to their position in the value returned by \code{colors()}. As the present chapter is on package \ggplot we use this package in this example. As this charts are likely to be needed frequently, I define here a function \code{ggcolorchart}.

<<>>=
ggcolorchart <- function(colors,
                         ncol = NULL,
                         use.names = NULL,
                         text.size = 2) {
    # needed if the argument passed is subset with [ ]!
    force(colors)

    len.colors <- length(colors)
    # by default we attempt to use
    if (is.null(ncol)) {
      ncol <- max(trunc(sqrt(len.colors)), 1L)
    }
    # default for when to use color names
    if (is.null(use.names)) {
      use.names <- ncol < 8
    }
    # number of rows needed to fit all colors
    nrow <- len.colors %/% ncol
    if (len.colors %% ncol != 0) {
      nrow <- nrow + 1
    }
    # we extend the vector with NAs to match number of tiles
    if (len.colors < ncol*nrow) {
      colors[(len.colors + 1):(ncol*nrow)] <- NA
    }
    # we build a data frame
    colors.df <-
      data.frame(color = colors,
                 text.color =
                   ifelse(sapply(colors,
                                 function(x){mean(col2rgb(x))}) > 110,
                                 "black", "white"),
                 x = rep(1:ncol, nrow),
                 y = rep(nrow:1, rep(ncol, nrow)),
                 idx = ifelse(is.na(colors),
                              "",
                              format(1:(ncol * nrow), trim = TRUE)))
 # we build the plot
 p <- ggplot(colors.df, aes(x, y, fill = color))
 if (use.names) {
   p <- p + aes(label = ifelse(is.na(colors), "", colors))
 } else {
   p <- p + aes(label = format(idx, width = 3))
 }
 p <- p +
    geom_tile(color = "white") +
    scale_fill_identity() +
    geom_text(size = text.size, aes(color = text.color)) +
    scale_color_identity()
 p + theme_void()
}
@

\begin{playground}
After reading the use examples below, review the definition of the function, section by section, trying to understand what is the function of each section of the code. You can add print statements at different steps to look at the intermediate data values. Once you think you have grasped the purpose of a given statement, you can modify it in some way that modifies the output. For example, changing the defaults, for the shape of the tiles, e.g.\ so that the number of columns is about $1/3$ of the number of rows. Although you may never need exactly this function, studying its code will teach you some \emph{idioms} used by R programers. This function, in contrast to some other R code examples for plotting color tiles, does not contain any loop. It returns a \code{ggplot} object, which be added to and/or modified.
\end{playground}

We first the predefined colors available in R.

<<>>=
ggcolorchart(colors()) +
  ggtitle("R colors",
          subtitle = "Labels give index or position in colors() vector")
@
\label{chunk:plot:color:tiles}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

We subset those containing ``blue'' in the name, using the default number of columns.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), text.size = 3)
@

We reduce the number of columns and obtain rectangular tiles. The default for \code{use.names} depends on the number of tile columns, triggering automatically the change in labels.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), ncol = 4)
@

We demonstrate how perceived colors are affected by the hue, saturation and value in the HSV colour model.

<<>>=
ggcolorchart(hsv(1, (0:48)/48, 0.67), text.size = 3) +
  ggtitle("HSV saturation", "H = 1, S = 0..1, V = 0.67")
@

<<>>=
ggcolorchart(hsv(1, 1, (0:48)/48), text.size = 3) +
  ggtitle("HSV value", "H = 1, S = 1, V = 0..1")
@

<<>>=
ggcolorchart(hsv((0:48)/48, 1, 1), text.size = 3) +
  ggtitle("HSV hue", "H = 0..1, S = 1, V = 1")
@

We demonstrate how perceived colors are affected by the hue, chroma and luminance in the HCL colour model.

<<>>=
ggcolorchart(hcl((0:48)/48 * 360), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 85")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, l = 67), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 67")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, c = 67), text.size = 3) +
    ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 67, l = 85")
@

\begin{playground}
  The default order of the different colors in the vector returned by \code{colors()} results in a rather unappealing color tile plot (see page \pageref{chunk:plot:color:tiles}). Use functions \code{col2rgb()}, \code{rgb2hsv()} and \code{sort()} or \code{order()} to rearrange the tiles into a more pleasant arrangement, but still using for the labels the indexes to the positions of the colors in the original unsorted vector.
\end{playground}

\subsection{Pie charts vs.\ bar plots example}\label{sec:plot:pie:bar}

<<>>=
opts_chunk$set(opts_fig_wide)
@

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}).

Here is my \ggplot version of the same figure, using much simpler code and obtaining almost the same result.

<<>>=
example.data <-
  data.frame(values = c(17, 18, 20, 22, 23,
                        20, 20, 19, 21, 20,
                        23, 22, 20, 18, 17),
             examples= rep(c("A", "B", "C"), c(5,5,5)),
             cols = rep(c("red", "blue", "green", "yellow", "black"), 3)
  )

ggplot(example.data, aes(x=cols, y=values, fill=cols)) +
  geom_col(width = 1) +
  facet_grid(.~examples) +
  scale_fill_identity()
ggplot(example.data, aes(x=factor(1), y=values, fill=cols)) +
  geom_col(width = 1) +
  facet_grid(.~examples) +
  scale_fill_identity() +
  coord_polar(theta="y")
@

\section{Building complex data displays}

In this section we do not refer to those aspects of the design of a plot that can be adjust through themes (see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes}. Whenever this possibility exists, it is the best. Here we refer to aspects that are not really part of the graphical (''artistic'') design, but instead mappings, labels and similar data and metadata related aspects of plots. In many cases scales (see section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}) also fall within the scope of the present section.

\subsection{Using the grammar of graphics for individual plots}\label{sec:plot:composition}

The grammar of graphics allows one to build and test plots incrementally. In daily use, it is best to start with a simple design for a plot, print this plot, checking that the output is as expected and the code error-free. Afterwards, one can map additional \emph{aesthetics} and \emph{geometries} and \emph{statistics} gradually. The final steps are then to add \emph{annotations} and the text or expressions used for titles, and axis and key labels.

\begin{playground}
  Build a graphically complex data plot of your interest, step by step. By step by step, I do not refer to using the grammar in the construction of the plot as earlier, but of taking advantage of this modularity to test intermediate version in an iterative design process, first by building up the complex plot in stages as a tool in debugging, and later using iteration in the processes of improving the graphic design of the plot and improving its readability and effectiveness.
\end{playground}

\subsection{Using the grammar of graphics for series of plots with consistent design}

As in any type of script with instructions (for humans or computers), we should avoid unnecessary repetition, as repetition conspires against consistent results and is a major source of errors when the script needs to be modified. Not less important, a shorter script, if well written is easier to read.

One approach is to use user-defined functions. One can for example, write simple wrapper functions on top functions defined in \ggplot, for example, adding/changing the defaults mappings to ones suitable for our application. In the case of \code{ggplot()}, as it is defined as a generic function, if one's data is stored in objects of a user-defined class, the wrapper can be a specialization of the generic, and become almost invisible to users (e.g.\ not require a different syntax or adding a word to the grammar). At the other extreme of complexity compared to a wrapper function, we could write a function that encapsulates all the code needed to build a specific type of plot. Package \pkgname{ggspectra} uses the last two approaches.

As \code{ggplot} objects are composed using operator \code{+} to assemble together the different components, one can also store in a variable these components, or using a list, partial plots, which can be used to compose the final figure.

\begin{explainbox}
We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

<<>>=
myplot <- ggplot(data = mtcars,
                 aes(x=disp, y=mpg,
                 colour=factor(cyl))) +
          geom_point()

mylabs <- labs(x="Engine displacement)",
               y="Gross horsepower",
               colour="Number of\ncylinders",
               shape="Number of\ncylinders")
@

And now we can assemble them into plots.

<<>>=
myplot
myplot + mylabs + theme_bw(16)
myplot + mylabs + theme_bw(16) + ylim(0, NA)
@

We can also save intermediate results.

<<>>=
mylogplot <- myplot + scale_y_log10(limits=c(8,55))
mylogplot + mylabs + theme_bw(16)
@

If the pieces to put together do not include a "ggplot" object, we can put them
into a "list" object.

<<>>=
myparts <- list(mylabs, theme_bw(16))
mylogplot + myparts
@

The are a few predefined themes in package \ggplot and additional ones in other packages such as \cowplot, even the default \code{theme\_grey} can come in handy because the first parameter to themes is the point size used as reference to calculate all other font sizes. You can see in the two examples bellow, that the size of all text elements changes proportionally when we set a different base size in points.

<<>>=
myplot + mylabs + theme_grey(10)
myplot + mylabs + theme_grey(16)
@

The code in the next chunk is valid, it returns a blank plot. This apparently useless plot, can be very useful when writing functions that return \code{ggplot} objects or build them piece by piece in a loop.

<<>>=
ggplot()
@

\begin{playground}
Revise the code you wrote for the ``playground'' exercise in section \ref{sec:plot:composition}, but this time, pre-building and saving groups of elements that you expect to be useful unchanged when composing a different plot of the same type, or a plot of a different type from the same data.
\end{playground}

\end{explainbox}


<<eco=FALSE>>=
try(detach(package:tikzDevice))
try(detach(package:ggplot2))
try(detach(package:scales))
@

