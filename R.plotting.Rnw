% !Rnw root = appendix.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
@

\chapter[Plots with ggpplot]{Plots with \ggplot}\label{chap:R:plotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(ggplot2)
library(tikzDevice)
@

We set a font larger size than the default
<<>>=
theme_set(theme_grey(16))
@
<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \code{Lattice} and \ggplot. There are additional packages that add extra functionality to these packages.

In the examples in this chapter we use \ggplot. In later chapters we use \ggplot together with \ggmap, \ggtern, \ggrepel, and \ggpmisc. Here we start with an introduction to the `grammar of graphics' and \ggplot. There is ample literature on the use of \ggplot, starting with very good reference documentation at \url{http://ggplot2.org/}. The book `R Graphics Cookbook' \autocite{Chang2013} is very useful and should be always near you, when using the package, as it contains many worked out examples. Much of the literature available at this time is for older versions of \ggplot but we here describe version 2.0.0, and highlight the most important incompatibilities that need to be taken into account when using versions of \ggplot earlier than 2.0.0. There is little well-organized literature on packages extending \ggplot so we will describe some of them in later chapters.

\section{Grammar of graphics}

What separates \ggplot from base-R and trellis/lattice plotting functions is the use of a grammar of graphics (the reason behind `gg' in the name of the package). What is meant by grammar in this case is that plots are assembled piece by piece from different `nouns' and `verbs'. Instead of using a single function with many arguments, plots are assembled by combining different elements with operators \code{+} and \verb|%+%|. Furthermore, the constructions is mostly semantic-based and to a large extent how the plot looks when is printed, displayed or exported to a bitmap or vector graphics file is controlled by themes.

\subsection{Mapping}

When we design a plot, we need to map data variables to aesthetics (or graphic `properties'). Most plots will have an $x$ dimension, which is considered an aesthetic, and a variable containing numbers mapped to it. The position on a 2D plot of say a point will be determined by $x$ and $y$ aesthetics, while in a 3D plot, three aesthetics need to be mapped $x$, $y$ and $z$. Many aesthetics are not related to coordinates, they are properties, like color, size, shape, line type or even rotation angle, which add an additional dimension on which to plot variables.

\subsection{Geometries}

Geometries describe the graphics representation of the data: for example, \texttt{geom\_point}, plots a `point' or symbol for each observation, while \texttt{geom\_line}, draws line segments between successive observations. Some geometries rely on statistics, but most `geoms' default to the identity statistics.

\subsection{Statistics}

Statistics are `words' that represent calculation of summaries or some other values from the data, and these values can be plotted with a geometry. For example \texttt{stat\_smooth} fits a smoother, and \texttt{stat\_summary} applies a summary function. Statistics are applied automatically by group when data has been grouped by mapping additional aesthetics such as color.

But as all this is easier to show by example than to explain, after this short introduction we will focus on examples showing how to produce graphs of increasing complexity.

\subsection{Scales}

Scales give the relationship between data values and the aesthetic values to be actually plotted. Mapping a variable to the `color' aesthetic only tells that different values stored in the mapped variable will be represented by different colors. A scale, such as \texttt{scale\_color\_continuous} will determine which color in the plot corresponds to which value in the variable. Scales are used both for continuous variables, such as numbers, and categorical ones such as factors.

\subsection{Themes}

How the plots look when displayed or printed can be altered by means of themes. A plot can be saved without adding a theme and then printed or displayed using different themes. Also individual theme elements can be changed, and whole new themes defined. This adds a lot of flexibility and helps in the separation of the data representation aspects from those related to the graphical design.

\section{Basic examples: points and lines}

As discussed above the grammar of graphics is based on aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geometry.

In the examples that follow we will use the \code{mtcars} data set included in R. To learn more about this data set, \code{help("mtcars")} at the R command prompt.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
  geom_point()
@

I could have written the code above passing the arguments by position but this
makes the code more difficult to read and less tolerant to possible changes to the
definitions of the functions used in future version of package \ggplot. It is not
recommended to use this terse style in scripts or package coding. However, it can
be used at the command prompt, although it can lead to mistakes when the sanity
of results is difficult to quickly assess at first sight.

<<>>=
ggplot(mtcars, aes(disp, mpg)) +
  geom_point()
@

Data variables can be `mapped' to \textit{aesthetics}, variables can be either continuous (numeric) or discrete (categorical, factor). Variable \code{cyl} is encoded in the \code{mtcars} dataframe as numeric values. Even though only three values are present, a continuous color scale is used by default.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = cyl)) +
  geom_point()
@

Some scales exist in two `flavours', one suitable for continuous variables and another for discrete variables. For now we will just use the default scales, but later on we will see how to alter them. We can convert \code{cyl} into a factor `on-the-fly' to force the use of a discrete color scale.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl))) +
  geom_point()
@

Using an aesthetic, involves mapping of values in the data to aesthetic values such as colours. The mapping is defined by means of scales. If we now consider the \code{colour} aesthetic in the previous statement, a default discrete colour scale was used. In this case if we would like different colours used for the three values, but still have them selected automatically, we can select a different colour palette:

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, fill = factor(cyl))) +
  geom_point(size = rel(2)) +
  scale_color_brewer(type = "div", palette = 8) +
  theme_bw(16)
@

Data assigned to an aesthetic can be the `result of a computation'. In other words, the values to be plotted do not need to be stored in the data frame passed as argument to \code{data}, the first formal parameter of \code{ggplot()}

<<>>=
ggplot(data = mtcars,
       aes(x = factor(cyl), y = mpg / disp)) +
  geom_point()
@

Within \code{aes()} the aesthetics are interpreted as being a function of the values in the data. If given outside \code{aes()} they are interpreted as constants values, which apply to one geom if given within the call to \code{geom\_xxx} but outside \code{aes()}. The aesthetics and data given as \code{ggplot()}'s arguments become the defaults for all the geoms, but geoms also accept aesthetics and data as arguments, which when supplied as arguments override the whole-plot defaults. In the example below, we override the default colour of the points.

<<>>=
ggplot(data = mtcars,
       aes(x = factor(cyl), y = mpg / disp)) +
  geom_point(color = "red")
@

<<>>=
ggplot(data = mtcars,
       aes(x = factor(cyl), y = mpg / disp, color = factor(cyl))) +
  geom_point()
@

The same plot can be also obtained by adding all pieces one by one (although
seldom used except when defining new functions).

<<>>=
ggplot() +
  aes(x = factor(cyl), y = mpg / disp,
      colour = factor(cyl)) +
  geom_point(data = mtcars)
@

The code in the next chunk is also valid, it returns a blank plot.

<<>>=
ggplot()
@

In the next example we override the \code{color} aesthetic in \code{geom\_smooth}\footnote{Smoothing and curve fitted is discussed in more detail in section \ref{sec:???}.}, causing all the data to be fitted together. The data points are labelled according to \code{cyl} but the smooth line is calculated jointly for all values of \code{cyl}. That we use \code{code = "black"} is not important, what is important is that we use a constant to override an aesthetic mapping set globally for the whole plot.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=hp, colour=factor(cyl))) +
  geom_smooth(colour="black") +
  geom_point()
@

In the example above the order in which the two geoms are added is important, as this determines the position of their layers. In the example above the points are plotted on top of the smoother, while in the next example \code{geom\_smooth} is plotted on top of the points.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=hp, colour=factor(cyl))) +
  geom_point() +
  geom_smooth(colour="black")
@

We can assign the same variable to more than one aesthetic, and the combined key will be produced automatically.

<<>>=
ggplot(data = mtcars,
       aes(x=disp, y=hp, colour=factor(cyl),
           shape=factor(cyl))) +
  geom_point()
@

We can change the labels for the different aesthetics, and give a title (\verb!\n! means `new line' and can be used to continue a label in the next line). In this case, if two aesthetics are linked to the same variable, the labels supplied should be identical, otherwise two separate keys will be produced.

<<>>=
ggplot(data = mtcars,
       aes(x=disp, y=hp, colour=factor(cyl),
           shape=factor(cyl))) +
  geom_point() +
  labs(x="Engine displacement)",
       y="Gross horsepower",
       colour="Number of\ncylinders",
       shape="Number of\ncylinders")
@

We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

<<>>=
myplot <- ggplot(data = mtcars,
                 aes(x=disp, y=mpg,
                 colour=factor(cyl))) +
          geom_point()

mylabs <- labs(x="Engine displacement)",
               y="Gross horsepower",
               colour="Number of\ncylinders",
               shape="Number of\ncylinders")
@

And now we can assemble them into plots.

<<>>=
myplot
myplot + mylabs + theme_bw(16)
myplot + mylabs + theme_bw(16) + ylim(0, NA)
@

We can also save intermediate results.

<<>>=
mylogplot <- myplot + scale_y_log10(limits=c(8,55))
mylogplot + mylabs + theme_bw(16)
@

If the pieces to put together do not include a "ggplot" object, we can put them
into a "list" object.

<<>>=
myparts <- list(mylabs, theme_bw(16))
mylogplot + myparts
@

The are a few predefined themes in package \ggplot and additional ones in other packages such as \cowplot, even the default \code{theme\_grey} can come in handy because the first parameter to themes is the point size used as reference to calculate all other font sizes. You can see in the two examples bellow, that the size of all text elements changes proportionally.

<<>>=
myplot + mylabs + theme_grey(10)
myplot + mylabs + theme_grey(16)
@

As exemplified above the different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. The \code{alpha} (transparency) aesthetic can be mapped to a constant to make underlying layers visible, or they can be mapped to a data variable for example making the transparency of points in a plot depend on the number of observations used in its calculation.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
  geom_point() + geom_smooth(colour="black", alpha=0.7)
@

The plot looks different if the order of the geoms is swapped. The data points overlapping the confidence band are more clearly visible in this second example because they are above the shaded area instead of bellow it.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
   geom_smooth(colour="black", alpha=0.7) + geom_point()
@

\section{Plotting summaries}

The summaries discussed in this section can be superimposed on raw data plots, or plotted on their own. Beware, that if scale limits are manually set, the summaries will be calculated from the subset of observations within these limits. Scale limits can be altered when explicitly defining a scale or by means of functions \code{xlim()} and \code{ylim}. See section \ref{???} for a way of constraining the viewport (the region visible in the plot) while keeping the scale limits on a wider range of $x$ and $y$ values.

\subsection{Fitted curves, including splines}

We will now show an example of the use of \code{stat\_smooth} accepting the default spline smoothing.

<<>>=
myplot + stat_smooth(colour="black")
@

Instead of using the default spline, we can use a linear model fit. In this example we use a linear model, fitted by \code{lm}, as smoother:

<<>>=
myplot + stat_smooth(method="lm", colour="black")
@

Instead of using the default linear regression as smoother, we can use a linear model fit. In this example we use a polynomial of order 2 fitted by \code{lm}.

<<>>=
myplot + stat_smooth(method="lm", formula=y~poly(x,2), colour="black")
@

If we do not use \code{colour="black"} then the colour aesthetics supplied to \code{ggplot} is used, and splits the data into three groups to which the model is fitted separately.

<<>>=
myplot + stat_smooth(method="lm")
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use these more advanced models.

\subsection{Statistical ``summaries''}

It is also possible to summarize data on-the-fly when plotting, but before showing this we will generate some normally distributed artificial data:

<<>>=
fake.data <- data.frame(
  y = c(rnorm(20, mean=2, sd=0.5),
        rnorm(20, mean=4, sd=0.7)),
  group = factor(c(rep("A", 20), rep("B", 20)))
  )
@

Now will we use these data to plot means and confidence intervals by group. However, to save typing we first produce a dot plot by group.

<<>>=
fig2 <- ggplot(data=fake.data, aes(y=y, x=group)) +
          geom_point()
fig2
@

We have saved the base figure in \code{fig2}, so now we can play with different summaries. We first add just the mean. In this case we need to add as argument to \code{stat\_summary} the geom to use, as the default one expects data for plotting error bars, in later examples, this is not needed.

<<>>=
fig2 + stat_summary(fun.y = "mean", geom="point",
                    colour="red", shape="-", size=20)
@

Then the median, by changing the argument passed to \code{fun.y}.

<<>>=
fig2 + stat_summary(fun.y = "median", geom="point",
                    colour="red", shape="-", size=20)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal",
                    colour="red", size=1, alpha=0.7)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot",
                    colour="red", size=1, alpha=0.7)
@

If needed, we can instead add the means and less restrictive confidence intervals, at $p = 0.90$ in this example, by means of \code{conf.int = 0.90} passed as a list to the underlying function being called.

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_boot",
                    fun.args = list(conf.int = 0.90),
                    colour = "red", size = 1, alpha = 0.7)
@

We can plot error bars corresponding to $\pm$s.e. (standard errors) with the function \code{"mean\_se"} that was added in \ggplot 2.0.0.

<<>>=
fig2 + stat_summary(fun.data = "mean_se",
                    colour="red", size=1, alpha=0.7)
@

As \code{mult} is the multiplier based on the probability distribution used, by default student's {t}, by setting it to one, we get also standard errors of the mean.

<<>>=
fig2 + stat_summary(fun.data = "mean_cl_normal", fun.args = list(mult = 1),
                    colour="red", size=1, alpha=0.7)
@

However, be aware that the code below, as used in earlier versions of \ggplot, needs to be rewritten as above.

<<eval=FALSE>>=
fig2 + stat_summary(fun.data = "mean_cl_normal", mult = 1,
                    colour="red", size=1, alpha=0.7)
@

Finally we can plot error bars showing $\pm$s.d. (standard deviation).

<<>>=
fig2 + stat_summary(fun.data = "mean_sdl",
                    colour="red", size=1, alpha=0.7)
@

We do not show it here, but instead of using these functions (from package \Hmisc) it is possible to define one's own functions, and remember that arguments to all functions, except for the first one containing the actual data should be supplied as a list through formal argument \code{fun.args}.

Finally we plot the means in a bar plot, with the observations superimposed and $p = 0.95$ C.I. (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets mapping
them to factors in the data set can be used to distinguish them.

<<eval=FALSE>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  stat_summary(fun.y = "mean", geom = "bar",
               fill="yellow", colour="black") +
  stat_summary(fun.data = "mean_cl_normal",
               geom = "errorbar", mult = 1,
               width=0.1, size=1, colour="red") +
  geom_point(size=3, alpha=0.3)
@

\section{Plotting functions}

We can also directly plot functions, without need to generate data beforehand (the number of data points to be generated can be also set).

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
@

We can even pass additional arguments to a function.

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

Of course, user-defined functions (not shown), and anonymous functions can also be used.

<<>>=
ggplot(data.frame(x=0:1), aes(x=x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

Here is an example of a predefined function, but in this case the default breaks (tick positions) are not the best:

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin)
@

We need to change the $x$-axis scale to better suit the sin function and the use of radians as angular units\footnote{The use of \code{expression} is explained in detail in section \ref{sec:??}, an the use of \code{scales} in section \ref{sec:???}.}.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)")
@

\section{Plotting text and expressions}

One can use \code{geom\_text} to add text labels to observations. The aesthetic \code{label} gives text and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{color} aesthetic can be also used for text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of zero for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the label left or down, and positive values right or up. A value of 1 or 0 sets the text so that its edge is at the supplied coordinate. Values outside the range $0\ldots 1$ sift the text even further away.

<<>>=
my.data <-
  data.frame(x=1:5, y=rep(2, 5),
             label=paste(letters[1:5], " "))

ggplot(my.data, aes(x,y,label=label)) +
  geom_text(angle=45, hjust=1) + geom_point()
@

In this example we use \code{paste()} (which uses recycling here) to add a space at the end of each label. Justification values outside the range $0\ldots 1$ are allowed, but are relative to the width of the label. As the default font used in this case has variable width characters, the justification would be inconsistent (e.g. try the code above but using \code{hjust} set to 3 instead of to 1 without pasting a space character to the labels.)

Plotting expressions (mathematical expressions) involves passing as \code{label} data character strings that can be parsed as expressions, and setting \code{parse = TRUE}.

<<>>=
my.data <-
  data.frame(x=1:5, y=rep(2, 5),
             label=paste("alpha[", 1:5, "]", sep = ""))

ggplot(my.data, aes(x,y,label=label)) +
  geom_text(hjust=-0.2, parse=TRUE, size = rel(6)) +
  geom_point()
@

A similar example using \code{geom\_label}.

<<>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_label(hjust = -0.2, parse = TRUE, size = rel(4),
             fill = "white", colour = "red") +
  geom_point()
@

See R's `plotmath' demo for more information on the syntax of expressions.

\section{Circular plots}

Under circular plots I include pie charts. Here we add a new "word" to the grammar of graphics, \textit{coordinates}, such as \code{coord\_polar()} in the next examples. The default coordinate system for $x$ and $y$ \textit{aesthetics} is cartesian.

Pie charts are more difficult to read: our brain is more comfortable at comparing
lengths than angles. If used, they should only be used to show composition, or
fractional components that add up to a total. In this case only if the number of
“pie slices” is small (rule of thumb: less seven).

A funny example stolen from the \ggplot website at \url{http://docs.ggplot2.org/current/coord_polar.html}.

<<>>=
# Hadley's favourite pie chart
df <- data.frame(
  variable = c("resembles", "does not resemble"),
  value = c(80, 20)
)
ggplot(df, aes(x = "", y = value, fill = variable)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_manual(values = c("red", "yellow")) +
  coord_polar("y", start = pi / 3) +
  labs(title = "Pac man")
@

Something just a bit more useful, also stolen from the same page:

<<>>=
# A pie chart = stacked bar chart + polar coordinates
pie <- ggplot(data = mtcars, aes(x = factor(1), fill = factor(cyl))) +
         geom_bar(width = 1)
pie + coord_polar(theta = "y")
@

\section{Bar plots}

\section{Pie charts vs.\ bar plots example}

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}).

Here is my \ggplot version of the same figure, using much simpler code and obtaining almost the same result.

<<>>=
example.data <-
  data.frame(values = c(17, 18, 20, 22, 23,
                        20, 20, 19, 21, 20,
                        23, 22, 20, 18, 17),
             examples= rep(c("A", "B", "C"), c(5,5,5)),
             cols = rep(c("red", "blue", "green", "yellow", "black"), 3)
  )

ggplot(example.data, aes(x=cols, y=values, fill=cols)) +
  geom_bar(width = 1, stat="identity") +
  facet_grid(.~examples) +
  scale_fill_identity()
ggplot(example.data, aes(x=factor(1), y=values, fill=cols)) +
  geom_bar(width = 1, stat="identity") +
  facet_grid(.~examples) +
  scale_fill_identity() +
  coord_polar(theta="y")
@

\section{Frequencies and densities}

\subsection{Marginal rug plots}

Rarely rug-plots are used by themselves. Instead they are usually an addition to
scatter plots. An example follows. They make it easier to see the distribution
along the $x$- and $y$-axes.

We generate new fake data by random sampling from the normal distribution. We use \code{set.seed(1234)} to initialize the pseudo-random number generator so that
the same data are generated each time the code is run.

<<>>=
set.seed(1234)
my.data <-
  data.frame(x = rnorm(100),
             y = c(rnorm(50, -1, 1), rnorm(50, 1, 1)),
             group = factor(rep(c("A", "B"), c(50, 50))) )
@

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug()
@

\subsection{Histograms}

<<>>=
ggplot(my.data, aes(x)) +
  geom_histogram(bins = 15)
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "dodge")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "stack")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "identity", alpha = 0.5) +
  theme_bw(16)
@

\subsection{Density plots}

<<>>=
ggplot(my.data, aes(x, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_density(alpha = 0.5)
@

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_density_2d()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_density_2d() +
  facet_wrap(~group)
@

<<>>=
ggplot(my.data, aes(x, y)) +
stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\subsection{Box and whiskers plots}

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_boxplot()
@

\subsection{Violin plots}

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_violin()
@

<<>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_point(alpha = 0.33, size = rel(4),
             colour = "black", shape = 21)
@

\section{Special plots}

In this section we present some bare-bones examples of specialized plots. More elaborate versions are presented in later chapters using extensions to \ggplot. These plots are not special in the grammar used to build them, but are to some extent idiosyncratic although frequently used in certain disciplines.

\subsection{Heat maps}



\subsection{Volcano plots}

A volcano plot is just an elaborate version of a scatter plot, and can be created with \ggplot functions.

<<>>=
fake_expression.data <- NA

@

\section{Using facets}

Sets of coordinated plots are a very useful tool for visualizing data. These became popular through the \code{trellis} graphs in S, and the \code{lattice} package in R. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \ggplot there are two possible types of facets: facets organized in a grid, and facets along a single `axis' but wrapped into several rows. In the examples below we use \code{geom\_point} but faceting can be used with any \code{ggplot} object (even with maps, spectra and ternary plots produced by functions in packages \ggmap, \ggspectra and \ggtern.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p <- ggplot(data = mtcars, aes(mpg, wt)) + geom_point()
# With one variable
p + facet_grid(. ~ cyl)
@

<<>>=
p + facet_grid(cyl ~ .)
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free")
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free", space = "free")
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_grid(vs ~ am)
@

<<>>=
p + facet_grid(vs ~ am, margins=TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p + facet_grid(. ~ vs + am)
@

<<>>=
p + facet_grid(. ~ vs + am, labeller = label_both)
@

<<>>=
p + facet_grid(. ~ vs + am, margins=TRUE)
@

<<>>=
p + facet_grid(cyl ~ vs, labeller = label_both)
@

<<>>=
mtcars$cyl12 <- factor(mtcars$cyl,
                       labels = c("alpha", "beta", "sqrt(x, y)"))
p1 <- ggplot(data = mtcars, aes(mpg, wt)) +
      geom_point() +
      facet_grid(. ~ cyl12, labeller = label_parsed)
@

Here we use as \code{labeller} function \code{label\_bquote()} with a special syntax that allows us to use an expression where replacement based on the facet (panel) data takes place.

<<>>=
p + facet_grid(. ~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

In versions of \ggplot2 before 2.0.0, \code{labeller} was not implemented for \code{facet\_wrap()}, it was only available for \code{facet\_grid()}.

<<>>=
p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

A minimal example of a wrapped facet. In this case the number of levels is
small, when they are more the row of plots will be wrapped into two or more
continuation rows. When using \code{facet\_wrap()} there is only one dimension, so no `.'
 is needed before or after the tilde.

<<>>=
p + facet_wrap(~ cyl)
@

An example showing that even though faceting with \code{facet\_wrap()} is along a single, possibly wrapped, row, it is possible to produce facets based on more than one variable.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_wrap(~ vs + am, ncol=2)
@

In versions of \ggplot before 2.0.0, \code{labeller} was not implemented for
\code{facet\_wrap()}, it was only available for \code{facet\_grid()}. In the current
version it is implemented for both.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

\section{Scales}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted geometrical object, such as \code{color}, \code{size}, position (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the $x$-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also map the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different palette, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Remeber that for example for colour, and `numbers' there are both discrete and continuous scales available. Mapping colour or fill to \code{NA} makes such observation invisible.

Advanced scale manipulation requires package \code{scales} to be loaded, although \ggplot 2.0.0 re-exports many functions from package \code{scales}. Some simple examples follow.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

Some new fake data.

<<>>=
fake2.data <-
  data.frame(y = c(rnorm(20, mean=20, sd=5),
                   rnorm(20, mean=40, sd=10)),
             group = factor(c(rep("A", 20), rep("B", 20))),
             z = rnorm(40, mean=12, sd=6))
@

We save \code{ggplot} object with the default scales.

<<>>=
fig2 <- ggplot(fake2.data, aes(z, y)) + geom_point()
@

We re-save a \code{ggplot} object using the default scales, except that we change the limits of the $y$-scale. \code{ylim()} is a convenience function used for modification of the \code{lims} (limits) of the scale used by the $y$ aesthetic.

<<>>=
fig2 + ylim(0, NA)
@

The default scale used by the \code{y} aesthetic uses \code{position = "identity"}, but there are predefined for transformed scales. Axis tick labels display the original values before applying the transformation, original numbers. The \code{"breaks"} need to be given in the original scale.

<<>>=
fig2 + scale_y_log10(breaks=c(10,20,50,100))
@

In contrast, transforming the data, results in tick-labels expressed in the logarithm of the original data.

<<>>=
fig2log <- ggplot(fake2.data, aes(z, log10(y))) + geom_point()
@

When combining scale transformations and summaries, one should be aware of which data are used, transformed or not.


\section{Adding annotations}

Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the \code{ggplot} object. In this example we pass directly expressions as tick labels. Do notice that we use recycling for setting the breaks, as \code{c(0, 0.5, 1, 1.5, 2) * pi} is equivalent to \code{c(0, 0.5 * pi, pi, 1.5 * pi, 2 * pi}.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)") +
  annotate(geom="text",
           label=c("+", "-"),
           x=c(0.5, 1.5) * pi, y=c(0.5, -0.5),
           size=20) +
  annotate(geom="point",
           colour="red",
           shape=21,
           fill="white",
           x=c(0, 1, 2) * pi, y=0,
           size=6)
@

\section{Themes}
\subsection{Predefined themes}
\subsection{Tweaking a theme}
\subsection{Defining a new theme}

\section{Advanced topics}

\section[Using plotmath expressions]{Using \code{plotmath} expressions}

Expressions are very useful but rather tricky to use because the syntax is unusual. In \code{ggplot} one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined with \code{labs}) the expressions have to be entered explicitly, or saved as such into a variable, and the variable supplied as argument. When plotting expressions using \code{geom\_text} expression arguments should be supplied as character strings and the optional argument \code{parse = TRUE} used to tell the geom to interpret the labels as expressions. We will go through a few useful examples.

We will revisit the example from the previous section, but now using subscripted Greek $\alpha$ for labels. In this example we use as subscripts numeric values from another variable in the same dataframe.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = paste("alpha[", 1:5, "]", sep = ""))
my.data$greek.label <- paste("alpha[", my.data$x, "]", sep="")
(fig <- ggplot(my.data, aes(x,y,label=greek.label)) +
   geom_text(angle=45, hjust=1.2, parse=TRUE) + geom_point())
@

Setting an axis label with superscripts. The easiest way to deal with spaces is to use `~' or `~~'. One can connect pieces that would otherwise cause errors using `*'. If we

<<>>=
fig + labs(x=expression(alpha), y=expression(Speed~~(m~s^{-1})))
@

It is possible to store expressions in variables.

<<>>=
my.title <- expression(sqrt(alpha[1] + frac(beta, gamma)))
fig + labs(title=my.title)
@

Annotations are plotted ignoring the default aesthetics, but still make use of geoms, so labels for annotations also have to be supplied as character strings and parsed.

<<>>=
fig + ylim(1,3) +
  annotate("text", label="sqrt(alpha[1] + frac(beta, gamma))",
           y=2.5, x=3, size=8, colour="red", parse=TRUE)
@

hWe discuss how to use expressions as facet labels in section \ref{sec:facet}.

\section{Scales in detail}

\section{Generating output files}

It is possible, when using RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R, files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
pdf(file="fig1.pdf", width=8, height=6)
print(fig1)
dev.off()
@

Encapsulated Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file="fig1.eps", width=8, height=6)
print(fig1)
dev.off()
@

There are Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file="fig1.tiff", width=1000, height=800)
print(fig1)
dev.off()
@

\subsection{Using \LaTeX\ instead of plotmath}

To use \LaTeX\ syntax in plots we need to use a different \emph{software device} for output. It is called \code{Tikz} and defined in package \pkgname{tikzDevice}. This device generates output that can be interpreted by \LaTeX\ either as a self-contained file or as a file to be input into another \LaTeX\ source file. As the bulk of this handbook does not use this device, we will use it explicitly and input the files into this section. A \TeX\ distribution should be installed, with \LaTeX\ and several (\LaTeX) packages including \pkgname{tikz}.

\subsection{Fonts}

Font face selection, weight, size, maths, etc. are set with \LaTeX\ syntax. The main advantage of using \LaTeX\ is the consistency between the typesetting of the text body and figure labels and legends. For those familiar with \LaTeX\ not having to remember/learn the syntax of plotmath will a bonus.

We will revisit the example from the previous sections, but now using \LaTeX\ for the subscripted Greek $\alpha$ for labels instead of \code{plotmath}. In this example we use as subscripts numeric values from another variable in the same dataframe.

\section{Examples}

\subsection{Anscombe's regression examples}

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}.

This classical example form \citeauthor{Anscombe1973} (\citeyear{Anscombe1973}) demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

I will redraw the Wikipedia figure using \ggplot, but first I rearrange the original data.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- data.frame(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

Once the data is in a data frame, plotting the observations plus the regression lines is easy.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2)
@

It is not much more difficult to make it look similar to the Wikipedia original.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm", se=FALSE) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@

Although I think that the confidence bands make the point of the example much clearer.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@



<<>>=
try(detach(package:ggplot2))
@

