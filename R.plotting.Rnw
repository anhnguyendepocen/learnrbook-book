% !Rnw root = appendix.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
play.eval <- FALSE
@

\chapter[Plots with ggpplot]{Plots with \ggplot}\label{chap:R:plotting}

\dictum[Edward Tufte]{The commonality between science and art is in trying to see profoundly---to develop strategies of seeing and showing.}

\index{geometries (ggplot)|see{plots, geometries}}
\index{geom@\code{geom}|see{plots, geometries}}
\index{statistics (ggplot)|see{plots, statistics}}
\index{stat@\code{stat}|see{plots, statistics}}
\index{scales (ggplot)|see{plots, scales}}
\index{coordinates (ggplot)|see{plots, coordinates}}
\index{themes (ggplot)|see{plots, themes}}
\index{facets (ggplot)|see{plots, facets}}
\index{annotations (ggplot)|see{plots, annotations}}
\index{aesthetics (ggplot)|see{plots, aesthetics}}

\section{Aims of this chapter}

Three main plotting systems are available to \R users: base R, package \pkgname{lattice} \autocite{Sarkar2008} and package \pkgname{ggplolt2} \autocite{Wickham2016}, being the last one the most recent and currently most popular system available in \R for plotting data. Even two different sets of graphics primitives are available in R, that in base R and a newer one in the \pkgname{grid} package \autocite{Murrell2011}.

In this chapter you will learn the concepts of the grammar of graphics, on which package \pkgname{ggplot2} is based. You will as well learn how to do many of the data plots that can be produced with package \pkgname{ggplot2}. We will focus only on the grammar of graphics, as it is currently the most used plotting approach in R. As a consequence of this popularity and its flexibility, many extensions to \pkgname{ggplot2} have been released through free licences and deposited in public repositories. Several of these packages will be described in Chapter \ref{chap:R:more:ggplotting} starting on page \pageref{chap:R:more:ggplotting} and in Chapter \ref{chap:R:maps} starting on page \pageref{chap:R:maps}. As previous chapters, this chapter is intended to be read in whole.

\section{Packages used in this chapter}

<<>>=
citation(package = "ggplot2")
@

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(ggplot2)
library(scales)
library(tikzDevice)
library(lubridate)
@

We set a font of larger size than the default
<<>>=
theme_set(theme_grey(14))
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\section{Introduction}

Being R extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \pkgname{Lattice} \autocite{Sarkar2008} and \ggplot \autocite{Wickham2016}. There are additional packages that add extra functionality to these packages (see Chapter \ref{chap:R:more:ggplotting} starting on page \pageref{chap:R:more:ggplotting}.

In the examples in this chapter we describe the of use package \ggplot. We start with an introduction to the `grammar of graphics' and \ggplot. There is ample literature on the use of \ggplot, including the very good reference documentation at \url{http://docs.ggplot2.org/}. The book titled \citetitle{Wickham2016} \autocite{Wickham2016} is the authoritative reference, as it is authored by the developers of \ggplot. The book `R Graphics Cookbook' \autocite{Chang2013} is very useful as a reference as it contains many worked out examples. Some of the literature available at this time is for older versions of \ggplot but we here describe version 2.2.0, and highlight the most important incompatibilities that need to be taken into account when using versions of \ggplot earlier than 2.2.0. There is no comprehensive text on packages extending \ggplot so I will describe many of them in later chapters. In the present chapter we describe the functions and methods defined in package \ggplot, in chapter \ref{chap:R:more:ggplotting} on page \pageref{chap:R:more:ggplotting} we describe extensions to \ggplot defined in other packages, except for those related to plotting data onto maps and other images, described in chapter \ref{chap:R:maps} on page \pageref{chap:R:maps}. Consistent with the title of this book, we use a tutorial style, interspersing exercises to motivate learning using a hands-on approach and playful exploration of a wide range of possible uses of the \emph{grammar of graphics}.

\section{Grammar of graphics}

What separates \ggplot from base-R and trellis/lattice plotting functions is the use of a grammar of graphics\index{grammar of graphics} (the reason behind `gg' in the name of the package). What is meant by grammar in this case is that plots are assembled piece by piece from different `nouns' and `verbs' \autocite{Cleveland1985}. Instead of using a single function with many arguments, plots are assembled by combining different elements with operators \code{+} and \verb|%+%|. Furthermore, the construction is mostly semantic-based and to a large extent how the plot looks when is printed, displayed or exported to a bitmap or vector graphics file is controlled by themes.

\subsection{Mapping}

When we design a plot, we need to map data variables to aesthetics\index{plots!aesthetics} (or graphic `properties'). Most plots will have an $x$ dimension, which is considered an aesthetic, and a variable containing numbers mapped to it. The position on a 2D plot of say a point will be determined by $x$ and $y$ aesthetics, while in a 3D plot, three aesthetics need to be mapped $x$, $y$ and $z$. Many aesthetics are not related to coordinates, they are properties, like color, size, shape, line type or even rotation angle, which add an additional dimension on which to represent the values of variables and/or constants.

\subsection{Geometries}

Geometries\index{plots!geometries} describe the graphics representation of the data: for example, \texttt{geom\_point}, plots a `point' or symbol for each observation, while \texttt{geom\_line}, draws line segments between successive observations. Some geometries rely on statistics, but most `geoms' default to the identity statistics.

\subsection{Statistics}

Statistics\index{plots!statistics} are `words' that represent calculation of summaries or some other operation on the values from the data, and these summary values can be plotted with a geometry. For example \texttt{stat\_smooth} fits a smoother, and \texttt{stat\_summary} applies a summary function. Statistics are applied automatically by group when data has been grouped by mapping additional aesthetics such as color to a factor.

\subsection{Scales}

Scales\index{plots!scales} give the relationship between data values and the aesthetic values to be actually plotted. Mapping a variable to the `color' aesthetic only tells that different values stored in the mapped variable will be represented by different colors. A scale, such as \texttt{scale\_color\_continuous} will determine which color in the plot corresponds to which value in the variable. Scales are used both for continuous variables, such as numbers, and categorical ones such as factors.

\subsection{Coordinate systems}

The most frequently used coordinate system\index{plots!coordinates} when plotting data is the cartesian system, which is the default for most \emph{geometries}. In the cartesian system, $x$ and $y$ are represented as distances on two orthogonal (at 90$^\circ$) axes. In the polar system of coordinates, angles around a central point are used instead of distances on a straight line. However, package \pkgname{ggtern} adds a ternary system of coordinates, to allow the extension of the grammar to allow the construction of ternary plots.

\subsection{Themes}

How the plots look when displayed or printed can be altered by means of themes\index{plots!themes}. A plot can be saved without adding a theme and then printed or displayed using different themes. Also individual theme elements can be changed, and whole new themes defined. This adds a lot of flexibility and helps in the separation of the data representation aspects from those related to the graphical design.

As discussed above the grammar of graphics is based on aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, labels \code{labs}, \code{coordinate} systems and themes \code{theme\_\ldots}. Plots are assembled from these elements, we start with a plot with two aesthetics, and one geometry.

As the workings and use of the grammar are easier to show by example than to explain with words, after this short introduction we will focus on examples showing how to produce graphs of increasing complexity.

\section{Scatter plots}\label{sec:plot:scatter}\label{sec:simple:points:lines}
\index{plots!scatter plot|(}
In the examples that follow we will use the \code{mtcars} data set included in R. To learn more about this data set, type \code{help("mtcars")} at the R command prompt.

Data variables must be `mapped' to \textit{aesthetics} to appear as in a plot. Variables to be represented in a plot can be either continuous (numeric) or discrete (categorical, factor). Variable \code{cyl} is encoded in the \code{mtcars} data frame as numeric values. Even though only three values are present, a continuous color scale is used by default. In the example below, \code{x}, \code{y} and \code{color} are \emph{aesthetics}. In this example they are all mapped to variables contained in the data frame \code{mtcars}. To build a scatter plot, we use the \code{"point"} geometry as in a scatter plot each individual observation is represented by a \emph{point} or symbol in the plot.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = cyl)) +
  geom_point()
@

\begin{playground}
Try a different mapping: \code{disp} $\rightarrow$ \code{color}, \code{cyl} $\rightarrow$ \code{x}. Continue by using \code{help(mtcars)} and/or \code{names(mtcars)} to see what variables are available, and then try the combinations that trigger your curiosity.
\end{playground}

Some scales exist in two `flavours', one suitable for continuous variables and another for discrete variables. We can convert \code{cyl} into a factor `on-the-fly' to force the use of a discrete color scale.
If we \emph{map} the \code{color} aesthetic to \code{factor(cyl)}, points get colors according to the levels of the factor, and by default a \code{guide} or \emph{key} for the mapping is also added.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point()
@

\begin{playground}
Try a different mapping: \code{mpg} $\rightarrow$ \code{color}, \code{cyl} $\rightarrow$ \code{y}. Invent your own mappings taking into account which variables are continuous and which ones categorical.
\end{playground}

Using an aesthetic, involves the mapping of values in the data to aesthetic values such as colours. The mapping is defined by means of \emph{scales}. If we now consider the \code{color} aesthetic in the previous statement, a default discrete color scale was used when \code{factor(cyl)} was mapped to the aesthetic, while a continuous color scale was used when \code{mpg} was mapped to it.

In the case of the discrete scale three different colours taken from a default palette were used. If we would like to use a different set of three colours for the three values of the factor, but still have them assigned automatically to each \emph{point} in the plot, we can select a different colour palette by passing an argument to the corresponding scale function.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point() +
  scale_color_brewer(type = "qual", palette = 2)
@

\begin{playground}
Try the different palettes available through the brewer scale. You can play directly with the palettes using function \code{brewer\_pal()} from package \pkgname{scales} together with \code{show\_col()}).
<<eval=play.eval>>=
show_col(brewer_pal()(3))
show_col(brewer_pal(type = "qual", palette = 2, direction = 1)(3))
@
Once you have found a suitable palette for these data, redo the plot above with the chosen palette.
\end{playground}

Neither the data, nor the aesthetics mappings or geometries are different than in earlier code; to alter how the plot looks we have changed only the palette used by the color aesthetic. Conceptually it is still exactly the same plot we earlier created. This is a very important point to understand, because it is extremely useful in practice. Plots are assembled piece by piece and it is even possible to replace elements in an existing plot.

\begin{warningbox}
Within \code{aes()} the aesthetics are interpreted as being a function of the values in the data---i.e.\ to be mapped. If given outside \code{aes()} they are interpreted as constant values, which apply to one \emph{geometry} if given within the call to a \code{geom\_} but outside \code{aes()}. The aesthetics and data given as \code{ggplot()}'s arguments become the defaults for all the geoms, but geoms also accept aesthetics and data as arguments, which when supplied locally override the whole-plot defaults. In the example below, we override the default colour of the points.
\end{warningbox}

If we \emph{set} the \code{color} aesthetic to a constant value, \code{"red"}, all points are plotted in red.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point(color = "red")
@

\begin{playground}
Does the code chunk below produces exactly the same plot as that above this box? Consider how the two mappings differ, and make sure that you understand the reasons behind the difference or lack of difference in output by trying different variations of these examples
<<play.eval>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point(color = "red")
@
\end{playground}

As with any R function it is possible to pass arguments by position to \code{aes} when
mapping variables to \emph{aesthetics} but this
makes the code more difficult to read and less tolerant to possible changes to the
definitions of functions. It is not
recommended to use this terse style in scripts or package coding. However, it can
be used by experienced users at the command prompt usually without problems.

Mapping passing arguments by \emph{name} to \code{aes}.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
  geom_point()
@

\begin{playground}
If we swap the order of the arguments do we still obtain the same plot?
<<eval=play.eval>>=
ggplot(data = mtcars, aes(y = mpg, x = disp)) +
  geom_point()
@
\end{playground}

Mapping passing arguments by \emph{position} to \code{aes}.

<<>>=
ggplot(mtcars, aes(disp, mpg)) +
  geom_point()
@

\begin{playground}
If we swap the order of the arguments do we obtain a different plot?
<<eval=play.eval>>=
ggplot(mtcars, aes(mpg, disp)) +
  geom_point()
@
\end{playground}

When not relying on colors, the most common way of distinguishing groups of observations in scatter plots is to use the \code{shape} of the points as an \emph{aesthetic}. We need to change a single ``word'' in the code statement to achieve this different mapping.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point()
@

We can use \code{scale\_shape\_manual} to choose each shape to be used. We set three ``open'' shapes that we will see later are very useful as they obey both \code{color} and \code{fill} \emph{aesthetics}.\label{chunk:filled:symbols}

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point() +
  scale_shape_manual(values = c(21, 22, 23))
@

It is also possible to use characters as shapes. The character is centred on the position of the observation. Conceptually using \code{character} values for \code{shape} is different to using \code{geom\_text} as in the later case there is much more flexibility as character strings and expressions are allowed in addition to single characters. Also positioning with respect to the coordinates of the observations can be adjusted through justification. While \code{geom\_text} is usually used for annotations, the present example treats the character string as a symbol. (This also opens the door to the use as shapes of symbols defined in special fonts.)

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point(size = 2.5) +
  scale_shape_manual(values = c("4", "6", "8"), guide = FALSE)
@

\begin{playground}
What do you expect to be the result of the following statement?

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point(size = 4) +
  scale_shape_manual(values = c("c4", "c6", "c8"), guide = FALSE)
@
\end{playground}

As seen earlier one variable can be mapped to more than one aesthetic allowing redundant aesthetics. This may seem wasteful, but it is extremely useful as it allows one to produce figures that even when produced in color, can still be read if reproduced as monochrome images.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          color = factor(cyl))) +
  geom_point()
@

\begin{playground}
Here we map \code{fill} and \code{shape} to \code{cyl}. What do you expect this variation of the statement above to produce?

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          fill = factor(cyl))) +
  geom_point()
@

Hint: Do all shapes obey the \code{fill} aesthetic? (Having a look at page \pageref{chunk:filled:symbols} may be of help.)
\end{playground}


We can create a ``bubble'' plot by mapping the \code{size} \emph{aesthetic} to a continuous variable. In this case, one has to think what is visually more meaningful. Although the radius of the shape is frequently mapped, due to how human perception works, mapping a variable to the area of the shape is more useful by being perceptually closer to a linear mapping. For this example we add a new variable to the plot. The weight of the car in tons and map it to the area of the points.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size_area() +
  geom_point()
@

\begin{playground}
If we use a radius-based scale the ``impression'' is different.

<<eval=play.eval>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size() +
  geom_point()
@

Make the plot, look at it carefully. Check the numerical values of some of the weights, and assess if your perception of the plot matches the numbers behind it.
\end{playground}

As a final example of how to combine different aesthetics, we use in a single plot several of the different mappings described in earlier examples.

<<>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          fill = factor(cyl),
                          size = wt)) +
  geom_point(alpha = 0.33, color = "black") +
  scale_size_area() +
  scale_shape_manual(values = c(21, 22, 23))
@

\begin{playground}
Play with the code in the chunk above. Remove or change each of the mappings and the scale, display the new plot and compare it to the one above. Continue playing with the code until you are sure you understand what each individual element in the code statement creates or controls which graphical element in the plot itself.
\end{playground}

Data assigned to an \emph{aesthetic} can be the `result of a computation'. In other words, the values to be plotted do not need to be stored in the data frame passed as argument to \code{data}, the first formal parameter of \code{ggplot()}

Here we plot the ratio of miles-per-gallon, \code{mpg}, and the engine displacement (volume), \code{disp}. Instead of mapping as above \code{disp} to the $x$ \emph{aesthetic}, we map \code{factor(cyl)} to $x$. In contrast to the continuous variable \code{disp} we earlier used, now we use a factor, so a discrete (categorical) scale is used by default for $x$.

<<>>=
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg / disp)) +
  geom_point()
@

\begin{playground}
What will happen if we replace \code{factor(cyl)} with \code{cyl} in the statement above? How do you expect the plot to change? First think carefully what you can expect, and then run the edited code.
\end{playground}

Although \code{factor(cyl)} is mapped to $x$, we can map it in addition to  \code{color}. This may be useful when desiring to keep the design consistent across plots, for example this one and those above.

<<>>=
ggplot() +
  aes(x = factor(cyl), y = mpg / disp,
      colour = factor(cyl)) +
  geom_point(data = mtcars)
@

We can set the labels for the different aesthetics, and give a title (\verb!\n! means `new line' and can be used to continue a label in the next line). In this case, if two aesthetics are linked to the same variable, the labels supplied should be identical, otherwise two separate \emph{keys} will be produced.

<<>>=
ggplot(data = mtcars,
       aes(x=disp, y=hp, colour=factor(cyl),
           shape=factor(cyl))) +
  geom_point() +
  labs(x="Engine displacement)",
       y="Gross horsepower",
       colour="Number of\ncylinders",
       shape="Number of\ncylinders")
@

\begin{playground}
Play with the code statement above. Edit the character strings. Move the \verb|\n| around. How would you write a string so that quotation marks can be included as part of the title of the plot? Experiment, and google, if needed, until you get this to work.
\end{playground}

Please, see section \ref{sec:plot:labs} on page \pageref{sec:plot:labs} for more an extended description of the use of \code{labs}.
\index{plots!scatter plot|)}

\section{Line plots}
\index{plots!line plot|(}
For line plots we use \code{geom\_line}. The \code{size} of a line is its thickness, and as we had \code{shape} for points, we have \code{linetype} for lines. In a line plot observations in successive rows of the data frame, or the subset corresponding to a group, are joined by straight lines. We use a different data set included in R, Orange, with data on the growth of five orange trees. See the help page for \code{Orange} for details.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line()
@

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, linetype = Tree)) +
  geom_line()
@

Much of what was described above for scatter plots can be adapted to line plots.
\index{plots!line plot|)}

\section{Plotting functions}\label{sec:plot:function}
\index{plots!plotting functions|(}
\index{plots!statistics!function}
In addition to plotting data from a data frame with variables to map to $x$ and $y$ \emph{aesthetics}, it is possible to have only a variable mapped to $x$ and use \code{stat\_function} to generate the values to be mapped to $y$ using a function. This avoids the need to generate data beforehand (the number of data points to be generated can be also set).

We start with the Normal distribution function.

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
@

Using a list we can even pass by name additional arguments to a function.

<<>>=
ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

\begin{playground}
1) Edit the code above so as to plot in the same figure three curves, either for three different values for \code{mean} or for three different values for \code{sd}.

2) Edit the code above to use a different function, say \code{df}, the F distribution, adjusting the argument(s) passed through \code{args} accordingly.
\end{playground}

Of course, user-defined functions (not shown), and anonymous functions (below) can also be used.

<<>>=
ggplot(data.frame(x = 0:1), aes(x = x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

\begin{playground}
Edit the code above to use a different function, such as $e^{x + k}$, adjusting the argument(s) passed through \code{args} accordingly. Do this by means of an anonymous function, and by means of an equivalent named function defined by your code.
\end{playground}

\begin{explainbox}
In some cases we may want to tweak some aspects of the plot to better match the properties of the mathematical function. Here we use a predefined function for which the default $x$-axis breaks (tick positions) are not the best. We first show how the plot looks using defaults.

<<>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin)
@

Next we change the $x$-axis scale to better match the sine function and the use of radians as angular units.

<<>>=
ggplot(data.frame(x = c(0, 2 * pi)), aes(x = x)) +
  stat_function(fun = sin) +
  scale_x_continuous(
    breaks = c(0, 0.5, 1, 1.5, 2) * pi,
    labels = c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)")
@

There are three things in the above code that you need to understand: the use of the R built-in numeric constant \code{pi}, the use of argument `recycling' to avoid having to type \code{pi} many times, and the use of R \emph{expressions} to construct suitable tick labels for the $x$ axis. Do also consider why \code{pi} is interpreted differently within \code{expression} than within the numeric statements.

The use of \code{expression} is explained in detail in section \ref{sec:plot:plotmath}, an the use of \code{scales} in section \ref{sec:plot:scales}.

\end{explainbox}
\index{plots!plotting functions|)}

\section{Plotting text and maths}\label{sec:plot:text}
\index{plots!text in|(}
\index{plots!maths in|(}
We can use \code{geom\_text} or \code{geom\_label} to add text labels to observations. For \code{geom\_text} and \code{geom\_label}, the aesthetic \code{label} provides the text to be plotted and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{color} and \code{size} aesthetics can be also used for the text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of 0.5 for both \code{hjust} and \code{vjust} centres the label. The centre of the text is at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Negative justification values, shift the label left or down, and positive values right or up. A value of 1 or 0 sets the text so that its edge is at the supplied coordinate. Values outside the range $0\ldots 1$ shift the text even further away, however, based on the length of the string. In the case of \code{geom\_label} the text is enclosed in a rectangle, which obeys the \code{fill} \emph{aesthetic} and takes additional parameters (described starting at page \pageref{start:plot:label}). However, it does not support rotation with \code{angle}.

<<>>=
my.data <-
  data.frame(x = 1:5,
             y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust=1.5, size = 8) +
  geom_point()
@

\begin{playground}
Modify the examples above to use \code{geom\_label} instead of \code{geom\_text} using in addition the \code{fill} aesthetic.
\end{playground}

In the next example we select a different font family, using the same characters in the Roman alphabet.
We start by checking which fonts families R recognizes on our system for the PDF output device we use to compile the figures in this book.

<<>>=
names(pdfFonts())
@

A sans-serif font, either \code{"Helvetica"} or \code{"Arial"} is the default, but we can change the default through parameter \code{family}. Some of the family names are \emph{generic} like \code{serif}, \code{sans} (sans-serif) and \code{mono} (mono-spaced), and others refer to actual font names. Some related fonts (e.g.\ from different designers or foundries) may also use variations of the same name. Base R does not support the use of system fonts in graphics output devices. However, add-on packages allow their use. The simplest to use is package \pkgname{showtext} described in \ref{sec:plot:fonts} on page \pageref{sec:plot:fonts}.

<<>>=
my.data <-
  data.frame(x = 1:5,
             y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust=1.5, size = 8, family = "serif") +
  geom_point()
@

In the next example we use \code{paste()} (which uses recycling here) to add a space at the end of each label.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = paste(c("a", "ab", "abc", "abcd", "abcde"), " "))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust=1, color = "blue") +
  geom_point()
@

\begin{playground}
Justification values outside the range $0\ldots 1$ are allowed, but are relative to the width of the label. As the labels are of different length, using any value other than zero or one results in uneven positioning of the labels with respect to points.
Edit the code above using \code{hjust} set to 1.5 instead of to 1, without pasting a space character to the labels. Is the plot obtained ``tidy'' enough for publication? and for data exploration?
\end{playground}

Plotting expressions (mathematical expressions) involves mapping to the \code{label} aesthetic character strings that can be parsed as expressions, and setting \code{parse = TRUE}.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label=paste("alpha[", 1:5, "]", sep = ""))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

Plotting maths and other alphabets using R expressions is discussed in section \ref{sec:plot:plotmath} on page \pageref{sec:plot:plotmath}.

In the examples above we plotted text and expressions present in the data frame passed as argument for \code{data}. It is also possible to build suitable labels on-the-fly within \code{aes} when setting the mapping for \code{label}. Here we use \code{geom\_text} and expressions for the example, but the same two approaches can be use to ``build'' character strings to be used directly without parsing.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5))

ggplot(my.data, aes(x,
                    y,
                    label = paste("alpha[", x, "]", sep = ""))) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

\begin{playground}
What are the advantages and disadvantages of each approach in relation to easy with which a script in which several figures using the same ``labels'' are produced, in relation to consistency across figures? In contrast, which approach would you prefer if different figures in the same script used different variations of labels constructed from the same variables in the data?
\end{playground}

As \code{geom\_label} obeys the same parameters as \code{geom\_text} except for \code{angle} we describe below only the additional parameters compared to \code{geom\_text}.\label{start:plot:label}

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label=paste("alpha[", 1:5, "]", sep = ""))
ggplot(my.data, aes(x, y, label = label)) +
  geom_label(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point() +
  expand_limits(x = 5.4)
@

We may want to alter the default width of the border line or the color used to \code{fill} the rectangle, or to change the ``roundness'' of the corners. To suppress the border line use \code{NA}, as a value of zero produces a very thin border. Corner roundness is controlled by parameter \code{label.r} and the size of the margin around the text with \code{label.padding}.

<<>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label=paste("alpha[", 1:5, "]", sep = ""))
ggplot(my.data, aes(x, y, label = label)) +
  geom_label(hjust = -0.2, parse = TRUE, size = 6,
             label.size = NA,
             label.r = unit(0, "lines"),
             label.padding = unit(0.15, "lines"),
             fill = "yellow", alpha = 0.5) +
  geom_point() +
  expand_limits(x = 5.4)
@

\begin{playground}
Play with the arguments to the different parameters and with the \emph{aesthetics} to get an idea of what can be with them. For example, use thicker border lines and increase the padding so that a good margin is still achieve. You may also try mapping the \code{fill} and \code{color} \emph{aesthetics} to factors in the data.
\end{playground}

\begin{warningbox}
You\index{plots!fonts} should be aware that R and ggplot2 support the use of UNICODE\index{UNICODE}, such as UTF8\index{UTF8} character encoding in strings. If your editor or IDE supports their use, then you can type Greek letters and simple maths symbols directly, and they may show correctly in labels if a suitable font is loaded and an extended encoding like UTF8 in use by the operating system. Even if UTF8 is in use, text is not fully portable unless the same font is available\index{portability}, as even if the character positions are standardized for many languages, most UNICODE fonts support at most a small number of languages. In principle one can use this mechanism to have labels both using other alphabets and languages like Chinese with their numerous symbols mixed in the same figure. Furthermore, the support for fonts and consequently character sets in R is output-device dependent. The font encoding used by R by default depends on the default locale settings of the operating system, which can also lead to garbage printed to the console or wrong characters being plotted running the same code on a different computer from the one where a script was edited. Not all is lost, though, as R can be coerced to use system fonts and Google fonts with functions provided by packages \pkgname{showtext} and \pkgname{extrafont} described in section \ref{sec:plot:fonts} on page \pageref{sec:plot:fonts}. Encoding-related problems, specially in MS-Windows, are very common.
\end{warningbox}


\index{plots!text in|)}
\index{plots!maths in|)}

\section{Axis- and key labels, titles, subtitles and captions}\label{sec:plot:titles}\label{sec:plot:labs}
\index{plots!labels|(}
\index{plots!title|(}
\index{plots!subtitle|(}
\index{plots!caption|(}
I describe this in the same section, and immediately after the section on plotting text labels, as they are added to plots using similar approaches. Be aware that the default justification of plot titles has changed in \ggplot version 2.2.0 from centered to left justified. At the same time, support for subtitles and captions was added.

The most flexible approach is to use \code{labs} as it allows the user to set the text or expressions to be used for these different elements.

<<axis-labels-01>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  labs(title = "Growth of orange trees",
       subtitle = "Starting from 1968-12-31",
       caption = "see Draper, N. R. and Smith, H. (1998)",
       x = "Time (d)",
       y = "Stem circumference (mm)",
       color = "Tree\nnumber")
@

There are in addition to \code{labs} convenience functions for setting the axis labels, \code{xlab} and \code{ylab}.

<<axis-labels-02>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  xlab("Time (d)") +
  ylab("Stem circumference (mm)")
@

An additional convenience function, \code{ggtitle} can be used to add a title and optionally a subtitle.

<<axis-labels-03>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  ggtitle("Growth of orange trees",
          subtitle = "Starting from 1968-12-31")
@

\begin{playground}
Make an empty plot (\code{ggplot()}) and add to it as title an expression producing $y = b_0 + b_1 x + b_2 x^2$. (Hint: have a look at the examples for the use of expressions as labels in section \ref{sec:plot:text} on page \pageref{sec:plot:text} and the \code{plotmath} demo in R.)
\end{playground}

Function \code{update\_labels} allows the replacement of labels in an existing plot. We first create a plot with one set of labels, and afterwards we replace them. (In \ggplot 2.2.1 \code{update\_labels} fails for \emph{aesthetic} \code{color} but works as expected with \code{colour}. Issue raised in Github on 2016-01-21.)

<<axis-labels-04>>=
p <-
    ggplot(data = mtcars,
           aes(x = disp, y = hp, colour = factor(cyl),
               shape = factor(cyl))) +
      geom_point() +
      labs(x = "Engine displacement)",
           y = "Gross horsepower",
           color = "Number of\ncylinders",
           shape = "Number of\ncylinders")
p
@

<<axis-labels-05>>=
update_labels(p, list(x = "Cilindrada",
                      y = "Potencia bruta (caballos de fuerza)",
                      colour = "no. de\ncilindros",
                      shape = "no. de\ncilindros"))
@

\begin{warningbox}
When setting or updating labels using either \code{labs()} or \code{update\_labels()} be aware that even though \code{color} and \code{colour} are synonyms for the same \emph{aesthetics}, the `name' used in the call to \code{aes()} must match the  `name' used when setting or updating the labels.
\end{warningbox}

\begin{playground}
Modify the code used in the code chunk above to update labels, so that \code{colour} is used instead of \code{color}. How does the figure change?
\end{playground}

The labels used in keys and axis tick-labels for factor levels can be changed through the different \emph{scales} as described in section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}.

\begin{explainbox}
Sometimes we would like to include in the title or as an annotation in the plot, the name of the argument passed to \code{ggplot}'s \code{data} parameter. To obtain the name of an object as a character string, the usual R ``slang'' is \code{deparse(substitute(x))} where \code{x} is the object.

<<axis-labels-06>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  ggtitle(paste("Data:", deparse(substitute(Orange))))
@

The example above rarely is of much use, as we have anyway to pass the object itself twice, and consequently there is no advantage in effort compare to typing \code{"Data: Orange"} as argument to \code{ggtitle}. A more general way to solve this problem is to write a wrapper function.

<<axis-labels-07>>=
ggwrapper <- function(data, ...) {
  ggplot(data, ...) +
    ggtitle(paste("Object: ", substitute(data)))
}

ggwrapper(data = Orange,
          mapping = aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0)
@

This is a bare-bones example, as it does not retain user control over the formatting of the title. The ellipsis (\code{...}) is a catch-all parameter that we use to pass all other arguments to \code{ggplot}. Because of the way our wrapper function is defined using ellipsis, we need to always pass \code{mapping} and other arguments that are to be ``forwarded'' to \code{ggplot} by name.

Using this function in a loop over a list or vector, will produce output is not as useful as you may expect. In many cases, the best, although more complex solution is to add case-specific code the loop itself to generate suitable titles automatically.

We create a suitable set of data frames, build a list with name \code{my.dfs} containing them.

<<axis-labels-08>>=
df1 <- data.frame(x = 1:10, y = (1:10)^2)
df2 <- data.frame(x = 10:1, y = (10:1)^2.5)
my.dfs <- list(first.df = df1, second.df = df2)
@

If we print the output produced by the wrapper function when called in a loop but we get always the same title, so this approach is not useful.

<<axis-labels-09>>=
for (df in my.dfs) {
  print(
    ggwrapper(data = df,
              mapping = aes(x = x, y = y)) +
      geom_line()
  )
}
@

\begin{warningbox}
 Automatic printing of objects is disabled within functions and iteration loops, making it necessary to use \code{print()} explicitly in these cases (see loops above). This `inconsistency' in behaviour is frequently surprising to unexperienced R users, so keep in mind that if some chunk of R code unexpectedly fails to produce visible output, the most frequent reason is that \code{print()} needs to be included in the code to make the `missing' result visible. Except for base R plotting functions, the norm in R is that printing, either implicitly or explicitly is needed for output to be visible to the user.
\end{warningbox}

As we have given names to the list members, we can use these and enclose the loop in a function. This is a very inflexible approach, and on top the plots are only printed, and the \code{ggplot} objects get discarded once printed.

<<axis-labels-10>>=
plot.dfs <- function(x, ...) {
list.name <- deparse(substitute(x))
member.names <- names(x)
if (is.null(member.names)) {
  member.names <- as.character(seq_along(x))
}

  for (i in seq_along(x)) {
    print(
      ggplot(data = x[[i]], aes(x = x, y = y)) +
        geom_line() +
        ggtitle(paste("Object: ", list.name,
                      '[["', member.names[i], '"]]', sep = ""))
    )
  }

}
@

<<axis-labels-11>>=
plot.dfs(my.dfs)
@

\begin{playground}
Study the output from the two loops, and analyse why the titles differ. This will help not only understand this problem, but the implications of formulating \code{for} loops in these three syntactically correct ways.
\end{playground}

As it should be obvious by now, is that as an object ``moves'' through the function-call stack its visible name changes. Consequently when we nest functions or use loops it becomes difficult to retrieve the name under which the object was saved by the user. After these experiments, is should be clear that saving the titles ``in'' the data frames would be the most elegant approach. It is possible to save additional data in R objects using attributes. R itself uses attributes to keep track of objects' properties like the names of members in a list, or the class of objects.

When one has control over the objects, one can add the desired title as an attribute to the data frame, and then retrieve and use this when plotting. One should be careful, however, as some functions and operators may fail to copy user attributes to their output.

\begin{playground}

As an advanced exercise I suggest implementing this attribute-based solution by tagging the data frames using a function defined as shown below or by directly using \code{attr}. You will also need modify the code to use the new attribute when building the \code{ggplot} object.

<<axis-labels-12>>=
add.title.attr <- function(x, my.title) {
  attr(x, "title") <- my.title
  x
}
@

What advantages and disadvantages does this approach have? Can it be used in a loop?

\end{playground}

\end{explainbox}

\index{plots!caption|)}
\index{plots!subtitle|)}
\index{plots!title|)}
\index{plots!labels|)}

\section{Tile plots}\label{sec:tileplot}
\index{plots!tile plot|(}
For the special case of heat maps see section \ref{sec:plot:heatmap} on page \pageref{sec:plot:heatmap}.

We here generate 100 random draws from the $F$ distribution with degrees of freedom $\nu_1 = 5, \nu_2 = 20$.

<<>>=
set.seed(1234)
randomf.df <- data.frame(z = rf(100, df1 = 5, df2 = 20),
                         x = rep(letters[1:10], 10),
                         y = LETTERS[rep(1:10, rep(10, 10))])
@

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile()
@

We can use \code{"white"} or some other contrasting color to better delineate the borders of the tiles.

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "white")
@

Any continuous fill scale can be used to control the appearance. Here we show a tile plot using a grey gradient.

<<>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "black") +
  scale_fill_gradient(low = "grey15", high = "grey85", na.value = "red")
@
\index{plots!tile plot|)}
\section{Bar plots}\label{sec:plot:bar}
\index{plots!bar plot|(}
R users not familiar yet with \ggplot are frequently surprised by the default behaviour of \code{geom\_bar} as it uses \code{stat\_count} to compute the value plotted, rather than plotting values as is (see section \ref{sec:plot:summaries} on page \pageref{sec:plot:summaries}). The default can be changed, but \code{geom\_col} is equivalent to \code{geom\_bar} used with \code{"identity"} as argument to parameter \code{stat}. The \emph{statistic} \code{stat\_identity} just echoes its input. In previous sections, as when plotting points and lines, this statistic was used by default.

In this bar plot, each bar shows the number of observations in each \code{class} of car in the data set. We use a data set included in \ggplot for this example based on the documentation.
<<>>=
ggplot(mpg, aes(class)) + geom_bar()
@

We can easily get stacked bars grouped by the number of cylinders of the engine.

<<>>=
ggplot(mpg, aes(class, fill = factor(cyl))) + geom_bar()
@

The default palette used for \code{fill} is rather ugly, so we also show the same plot with another scale for fill.

<<>>=
ggplot(mpg, aes(class, fill = factor(cyl))) +
  geom_bar(color = "black") +
  scale_fill_brewer()
@
\index{plots!bar plot|)}

\section{Plotting summaries}\label{sec:plot:summaries}

The summaries discussed in this section can be superimposed on raw data plots, or plotted on their own. Beware, that if scale limits are manually set, the summaries will be calculated from the subset of observations within these limits. Scale limits can be altered when explicitly defining a scale or by means of functions \code{xlim()} and \code{ylim}. See the text box on \pageref{box:plot:coord:lims} for a way of constraining the viewport (the region visible in the plot) by changing coordinate limits while keeping the scale limits on a wider range of $x$ and $y$ values.

\subsection{Statistical ``summaries''}
\index{plots!statistics|(}
\index{plots!statistics!summary}
It is possible to summarize data on-the-fly when plotting. We describe in the same section the calculation of measures of central position and of variation, as \code{stat\_summary} allows them to be calculated in the same function call.

For the examples we will generate some normally distributed artificial data.

<<>>=
fake.data <- data.frame(
  y = c(rnorm(10, mean=2, sd=0.5),
        rnorm(10, mean=4, sd=0.7)),
  group = factor(c(rep("A", 10), rep("B", 10)))
  )
@

We first use scatter plots for the examples, later we give some additional examples for bar plots.
We will reuse a ``base'' plot in a series of examples, so that the differences are easier to appreciate. We first add just the mean. In this case we need to pass as argument to \code{stat\_summary} the \code{geom} to use, as the default one, \code{geom\_pointrange}, expects data for plotting error bars in addition to the mean.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "mean", geom="point", color="red", shape="-", size=10)
@

Then the median, by changing the argument passed to \code{fun.y}.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "median", geom="point", colour="red", shape="-", size=10)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal", colour="red", size=1, alpha=0.7)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot", colour="red", size=1, alpha=0.7)
@

If needed, we can display less restrictive confidence intervals, at $p = 0.90$ in this example, by means of \code{conf.int = 0.90} passed as a list to the underlying function being called.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot",
               fun.args = list(conf.int = 0.90),
               colour = "red", size = 1, alpha = 0.7)
@

We can plot error bars corresponding to $\pm$s.e. (standard errors) with the function \code{"mean\_se"}, added in \ggplot 2.0.0.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_se",
               colour="red", size=1, alpha=0.7)
@

\begin{warningbox}\label{box:plot:coord:lims}
\textbf{Scale- and coordinate limits are very different.} Scale limits restrict the data used, while coordinate limits restrict the data that are visible. For a scatter plot, the effect of either approach on the resulting plot are equivalent, as no calculations are involved, but when using \emph{statistics} to compute summaries, one should almost always rely on coordinate limits, to make sure that no data are excluded from the calculated summary. An example follows, using artificial data with an outlier added.

<<>>=
outlier.data <- fake.data
outlier.data[1, "y"] <- outlier.data[1, "y"] * 5
@

This figure has the wrong values for mean and standard error, as the outlier has been excluded from the calculations. A warning is issued, reporting that observations have been excluded. One should never ignore such warnings before one understands why they are being triggered and is confident that this what one really intended to do!

<<>>=
ggplot(data=outlier.data, aes(y=y, x=group)) +
  stat_summary(fun.data = "mean_se",
               colour="red", size=1, alpha=0.7) +
  ylim(range(fake.data$y))
@

This figure has the correct values for mean and standard error, as the outlier has been included in the calculations.

<<>>=
ggplot(data=outlier.data, aes(y=y, x=group)) +
  stat_summary(fun.data = "mean_se",
               colour="red", size=1, alpha=0.7) +
  coord_cartesian(ylim = range(fake.data$y))
@

\end{warningbox}

As \code{mult} is the multiplier based on the probability distribution used, by default student's {t}, by setting it to one, we get also standard errors of the mean.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal",
               fun.args = list(mult = 1),
               colour="red", size=1, alpha=0.7)
@

However, be aware that the code such as below (NOT EVALUATED HERE), as used in earlier versions of \ggplot, needs to be rewritten as above.

<<eval=FALSE>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal", mult = 1,
               colour="red", size=1, alpha=0.7)
@

Finally we can plot error bars showing $\pm$s.d. (standard deviation).

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_sdl", colour="red", size=1, alpha=0.7)
@

We do not give an example here, but instead of using these functions (from package \Hmisc) it is possible to define one's own functions. In addition as arguments to any function used, except for the first one containing the actual data, are supplied as a list through formal argument \code{fun.args}, there is a lot of flexibility with respect to what functions can be used.

Finally we plot the means in a scatter plot, with the observations superimposed and $p = 0.95$ confidence interval (the order in which the geoms are added is important: by having \code{geom\_point} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets mapping them to factors in the data set can be used to distinguish them. Adding \code{stat\_summary} twice allows us to plot the mean and the error bars using different colors.

<<>>=
ggplot(data=fake.data, aes(y=y, x=group)) +
  stat_summary(fun.y = "mean", geom = "point",
               fill="white", colour="black") +
  stat_summary(fun.data = "mean_cl_boot",
               geom = "errorbar",
               width=0.1, size=1, colour="red") +
  geom_point(size=3, alpha=0.3)
@

Similarly as with scatter plots, we can plot summaries as bars plots and add error bars.
If we supply a different argument to \code{stat} we can for example plot the means or medians for a variable, for each \code{class} of car.

<<>>=
ggplot(mpg, aes(class, hwy)) + geom_bar(stat = "summary", fun.y = mean)
@

<<>>=
ggplot(mpg, aes(class, hwy)) + geom_bar(stat = "summary", fun.y = median)
@

The ``reverse'' syntax is also possible, we can add the \emph{statistics} to the plot object and pass the \emph{geometry} as an argument to it.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

And we can easily add error bars to the bar plot. We use \code{size} to make the lines of the error bar thicker, and a value smaller than zero for \code{fatten} to make the point smaller. The default \code{geom} for \code{stat\_summary} is \code{"pointrange"}.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(fun.data = "mean_se", size = 1,
               fatten = 0.5, color = "red")
@

Instead of making the point smaller, we can pass \code{"linerange"} as argument for \code{geom} to eliminate the point completely.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "linerange",
               fun.data = "mean_se", size = 1,
               color = "red")
@

Passing \code{"errorbar"} to \code{geom} results in more traditional error bars, however, this type of error bars has been criticized as adding unnecessary clutter to plots \autocite{Tufte1983}. We use \code{width} to reduce the width of the cross lines at the ends of the bars.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "errorbar",
               fun.data = "mean_se", width = 0.1, size = 1,
               color = "red")
@

If we have ready calculated values for the summaries, we can still obtain the same plots. Here we calculate the summaries before plotting, and then redraw the plot immediately above.

<<>>=
mpg_g <- dplyr::group_by(mpg, class)
mpg_summ <- dplyr::summarise(mpg_g, hwy_mean = mean(hwy),
                                    hwy_se = sd(hwy) / sqrt(n()))

ggplot(mpg_summ, aes(x = class,
                     y = hwy_mean,
                     ymax = hwy_mean + hwy_se,
                     ymin = hwy_mean - hwy_se)) +
  geom_col() +
  geom_errorbar(width = 0.1, size = 1, color = "red")
@
\index{plots!statistics|)}

\section{Fitted smooth curves}
\index{plots!smooth curves|(}
\index{plots!fitted curves|(}
\index{plots!statistics!smooth}
The \emph{statistic} \code{stat\_smooth} fits a smooth curve to observations in the case when the scales for $x$ and $y$ are continuous. For the first example, we use the default smoother, a spline. The type of spline is automatically chosen based on the number of observations.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
       stat_smooth()
@

In most cases we will want to plot the observations as points together with the smoother. We can plot the observation on top of the smoother, as done here, or the smoother on top of the observations.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
  stat_smooth() +
  geom_point()
@

Instead of using the default spline, we can fit a different model. In this example we use a linear model as smoother, fitted by \code{lm}.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg)) +
  stat_smooth(method="lm") +
  geom_point()
@

These data are really grouped, so we map the grouping to the \code{color} \emph{aesthetic}. Now we get three groups of points with different colours but also three separate smooth lines.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm") +
  geom_point()
@

To obtain a single smoother for the three groups, we need to set the mapping of the \code{color} \emph{aesthetic} to a constant within \code{stat\_smooth}. This local value overrides the default for the whole plot set with \code{aes} just for this single \emph{statistic}. We use \code{"black"} but this could be replaced by any other color definition known to R.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm", colour="black") +
  geom_point()
@

Instead of using the default \code{formula} for a linear regression as smoother, we pass a different \code{formula} as argument. In this example we use a polynomial of order 2 fitted by \code{lm}.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, color=factor(cyl))) +
  stat_smooth(method="lm", formula=y~poly(x,2), colour="black") +
  geom_point()
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will not give examples of the use of these more advanced models in this section.

\begin{warningbox}
The different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. The \code{alpha} (transparency) aesthetic can be mapped to a constant to make underlying layers visible, or \code{alpha} can be mapped to a data variable for example making the transparency of points in a plot depend on the number of observations used in its calculation.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
  geom_point() +
  geom_smooth(colour="black", alpha=0.7) +
  theme_bw()
@

The plot looks different if the order of the geoms is swapped. The data points overlapping the confidence band are more clearly visible in this second example because they are above the shaded area instead of bellow it.

<<>>=
ggplot(data = mtcars, aes(x=disp, y=mpg, colour=factor(cyl))) +
  geom_smooth(colour="black", alpha=0.7) +
  geom_point() +
  theme_bw()
@
\end{warningbox}
\index{plots!smooth curves|)}
\index{plots!fitted curves|)}

\section{Frequencies and densities}
\index{density plots|(}

A different type of summaries are frequencies and empirical density functions. These can be calculated in one or more dimensions. Sometimes instead of being calculated, we rely on the density of graphical elements to convey the density. Sometimes, scatter plots using a well chosen value for \code{alpha} give a satisfactory impression of the density. Rug plots, described below work in a similar way.

\subsection{Marginal rug plots}
\index{plots!rug marging|(}

Rarely rug-plots are used by themselves. Instead they are usually an addition to
scatter plots. An example follows. They make it easier to see the distribution
along the $x$- and $y$-axes.

We generate new fake data by random sampling from the normal distribution. We use \code{set.seed(1234)} to initialize the pseudo-random number generator so that
the same data are generated each time the code is run.

<<>>=
set.seed(12345)
my.data <-
  data.frame(x = rnorm(200),
             y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
             group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug()
@
\index{plots!rug marging|)}

\subsection{Histograms}\label{sec:histogram}
\index{plots!histograms|(}

Histograms are defined by how the plotted values are calculated. Although they are most frequently plotted as bar plots, many bar plots are not histograms. Although rarely done in practice, a histogram could be plotted using a different \emph{geometry} and \code{stat\_bin} the \emph{statistic} used by default by \code{geom\_histogram}. This statistics does binning of observations before computing frequencies, as is suitable for continuous $x$ scales. For categorical data \code{stat\_count} should be used, which as seen in section \ref{sec:plot:bar} on page \pageref{sec:plot:bar} is the default \code{stat} for \code{geom\_bar}.

<<>>=
ggplot(my.data, aes(x)) +
  geom_histogram(bins = 15)
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "dodge")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "stack")
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "identity", alpha = 0.5) +
  theme_bw(16)
@

The \emph{geometry} \code{geom\_bin2d} by default uses the \emph{statistic} \code{stat\_bin2d} which can be thought as a histogram in two dimensions. The frequency for each rectangle is mapped onto a \code{fill} scale.

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_bin2d(bins = 8) +
  facet_wrap(~group)
@

The \emph{geometry} \code{geom\_hex} by default uses the \emph{statistic} \code{stat\_binhex} which can be thought as a histogram in two dimensions. The frequency for each hexagon is mapped onto a \code{fill} scale.

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 8) +
  facet_wrap(~group)
@
\index{plots!histograms|)}


\subsection{Density plots}\label{sec:plot:density}
\index{plots!density plot!1 dimension|(}
\index{plots!statistics!density}
Empirical density functions are the equivalent of a histogram, but are continuous and not calculated using bins. They can be calculated in 1 or 2 dimensions (2d), for $x$ or $x$ and $y$ respectively. As with histograms it is possible to use different \emph{geometries} to visualize them.

<<>>=
ggplot(my.data, aes(x, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, colour = group)) +
  geom_density()
@

<<>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_density(alpha = 0.5)
@
\index{plots!density plot!1 dimension|)}

\index{plots!density plot!2 dimensions|(}
\index{plots!statistics!density 2d}

<<>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_density_2d()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
ggplot(my.data, aes(x, y)) +
  geom_density_2d() +
  facet_wrap(~group)
@

<<>>=
ggplot(my.data, aes(x, y)) +
stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@
\index{plots!density plot!2 dimensions|)}

\subsection{Box and whiskers plots}\label{sec:boxplot}
\index{box plots|see{plots, box and whiskers plot}}
\index{plots!box and whiskers plot|(}

Box and whiskers plots, also very frequently called just boxplots, are also summaries that convey some of the characteristics of a distribution. Although they can be calculated and plotted based on just a few observations, they are not useful unless each box plot is based in more than 10 to 15 observations.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_boxplot()
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as color, and others specific to these type of visual representation.
\index{plots!box and whiskers plot|)}

\subsection{Violin plots}\label{sec:plot:violin}
\index{plots!violin plot|(}

Violin plots are a more recent development than box plots, and usable with relatively large numbers of observations. They could be thought as being a sort of hybrid between an empirical density function and a box plot. As is the case with box plots, they are particularly useful when comparing distributions of related data, side by side.

<<>>=
ggplot(my.data, aes(group, y)) +
  geom_violin()
@

<<>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_point(alpha = 0.33, size = rel(4),
             colour = "black", shape = 21)
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as color, and others specific to these type of visual representation.
\index{plots!violin plot|)}

\section{Using facets}
\index{plots!facets|(}
\index{plots!panels|see{plots, facets}}
Sets of coordinated plots are a very useful tool for visualizing data. These became popular through the \code{trellis} graphs in S, and the \code{lattice} package in R. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \ggplot there are two possible types of facets: facets organized in a grid, and facets along a single `axis' but wrapped into several rows. In the examples below we use \code{geom\_point} but faceting can be used with any \code{ggplot} object (even with maps, spectra and ternary plots produced by functions in packages \ggmap, \ggspectra and \ggtern.

\begin{warningbox}
  The code underlying faceting has been rewritten in \ggplot version 2.2.0. All the examples given here are backwards compatible with versions 2.1.0 and possibly 2.0.0. The new functionality is related to the writing of extensions or controlled through themes, and will be discussed in other sections.
\end{warningbox}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p <- ggplot(data = mtcars, aes(mpg, wt)) + geom_point()
# With one variable
p + facet_grid(. ~ cyl)
@

<<>>=
p + facet_grid(cyl ~ .)
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free")
@

<<>>=
p + facet_grid(. ~ cyl, scales = "free", space = "free")
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_grid(vs ~ am)
@

<<>>=
p + facet_grid(vs ~ am, margins=TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p + facet_grid(. ~ vs + am)
@

<<>>=
p + facet_grid(. ~ vs + am, labeller = label_both)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_very_wide)
@

<<>>=
p + facet_grid(. ~ vs + am, margins=TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
p + facet_grid(cyl ~ vs, labeller = label_both)
@

<<>>=
mtcars$cyl12 <- factor(mtcars$cyl,
                       labels = c("alpha", "beta", "sqrt(x, y)"))
p1 <- ggplot(data = mtcars, aes(mpg, wt)) +
      geom_point() +
      facet_grid(. ~ cyl12, labeller = label_parsed)
@

Here we use as \code{labeller} function \code{label\_bquote()} with a special syntax that allows us to use an expression where replacement based on the facet (panel) data takes place.

<<>>=
p + facet_grid(. ~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

\sloppy
In versions of \ggplot2 before 2.0.0, \code{labeller} was not implemented for \code{facet\_wrap()}, it was only available for \code{facet\_grid()}.

<<>>=
p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
@

A minimal example of a wrapped facet. In this case the number of levels is
small, when they are more the row of plots will be wrapped into two or more
continuation rows. When using \code{facet\_wrap()} there is only one dimension, so no `.'
 is needed before or after the tilde.

<<>>=
p + facet_wrap(~ cyl)
@

An example showing that even though faceting with \code{facet\_wrap()} is along a single, possibly wrapped, row, it is possible to produce facets based on more than one variable.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
p + facet_wrap(~ vs + am, ncol=2)
@

%In versions of \ggplot before 2.0.0, \code{labeller} was not implemented for
%\code{facet\_wrap()}, it was only available for \code{facet\_grid()}. In the current
%version it is implemented for both.
%
%<<echo=FALSE>>=
%opts_chunk$set(opts_fig_wide)
%@
%
%<<>>=
%p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
%@
\index{plots!facets|)}

\section{Scales}\label{sec:plot:scales}
\index{plots!scales|(}

Scales map data onto aesthetics. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted geometrical object, such as \code{color}, \code{size}, position (\code{x, y, z}), \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most elemental mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \code{scale\_x\_continuous}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the $x$-axis will be based on the logarithm of the original data. A continuous data variable can, if we think it useful for describing our data, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \code{scale\_colour\_identity} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also map the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from the default palette, unless we chose a different palette, or even use \code{scale\_colour\_manual} to assign whatever colour we want to each level to be mapped. The same is true for other discrete scales like symbol \code{shape} and \code{linetype}. Remember that for example for colour, and `numbers' there are both discrete and continuous scales available. Mapping colour or fill to \code{NA} makes such observation invisible.

\sloppy
Advanced scale manipulation requires package \code{scales} to be loaded, although \ggplot 2.0.0 and later re-exports many functions from package \code{scales}. Some simple examples follow.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

We generate new fake data.

<<>>=
fake2.data <-
  data.frame(y = c(rnorm(20, mean=20, sd=5),
                   rnorm(20, mean=40, sd=10)),
             group = factor(c(rep("A", 20), rep("B", 20))),
             z = rnorm(40, mean=12, sd=6))
@

\subsection{Continuous scales for $x$ and $y$}

\subsubsection{Limits}

To\index{plots!scales!continuous!limits} change the limits of the $y$-scale, \code{ylim()} is a convenience function used for modification of the \code{lims} (limits) of the scale used by the $y$ aesthetic. We here exemplify the use of \code{ylim} only, but \code{xlim} can be used equivalently for the $x$ scale.

We can set both limits, minimum and maximum.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(0, 100)
@

We can set both limits, minimum and maximum, reversing the direction of the axis scale.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(100, 0)
@

We can set one limit and leave the other one free.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(0, NA)
@

We can use \code{lims} with discrete scales, listing all the levels that are to be included in the scale, even if they are missing from a given data set, such as after subsetting.

And we can expand the limits, to set a default minimum range, that will grow when needed to accommodate all observations in the data set. Of course here \code{x} and \code{y} refer to the \emph{aesthetics} and not to names of variables in data frame \code{fake2.data}.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + expand_limits(y = 0, x = 0)
@

\subsubsection{Transformed scales}

The\index{plots!scales!continuous!transformations} default scale used by the \code{y} aesthetic uses \code{position = "identity"}, but there are predefined for transformed scales.

Although transformations can be passed as argument to \code{scale\_x\_continuous} and \code{scale\_y\_continuous}, there are predefined convenience scale functions for \code{log10}, \code{sqrt} and \code{reverse}.

\begin{warningbox}
  Similarly to the maths functions of R, the name of the scales are \code{scale\_x\_log10} and \code{scale\_y\_log10} rather than \code{scale\_y\_log} because in R the function \code{log} returns the natural or Neperian logarithm.
\end{warningbox}

We can use \code{scale\_x\_reverse} to reverse the direction of a continuous scale,

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + scale_x_reverse()
@

Axis tick-labels display the original values before applying the transformation. The \code{"breaks"} need to be given in the original scale as well. We use \code{scale\_y\_log10} to apply a $\log_{10}$ transformation to the $y$ values.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_log10(breaks=c(10,20,50,100))
@

In contrast, transforming the data on-the-fly when mapping it to the $x$ \emph{aesthetic}, results in tick-labels expressed in the logarithm of the original data.

<<>>=
ggplot(fake2.data, aes(z, log10(y))) + geom_point()
@

We show here how to specify a transformation to a continuous scale, using a predefined ``transformation'' object.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(trans = "reciprocal")
@

Natural logarithms are important in growth analysis as the slope against time gives the relative growth rate. We show this with the \code{Orange} data set.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  scale_y_continuous(trans = "log", breaks = c(20, 50, 100, 200))
@

In section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} we define and use a transformation object.

\begin{warningbox}
When combining scale transformations and summaries, one should be aware of which data are used, transformed or not.
\end{warningbox}

\subsubsection{Tick labels}

Finally, when\index{plots!scales!continuous!tick labels} wanting to display tick labels for data available as fractions as percentages, we can use
\code{labels = scales::percent}.

<<>>=
ggplot(fake2.data, aes(z, y / max(y))) +
  geom_point() +
  scale_y_continuous(labels = scales::percent)
@

\sloppy
In the case of currency we can use \code{labels = scales::dollar}, and if we want to use commas to separate thousands, millions, and so on, we can use \code{labels = scales::comma}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::dollar)
@

When using breaks, we can just accept the default labels for the \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60))
@

We can also set tick labels manually, in parallel to the setting of \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", "->", "60"))
@

Using an expression we obtain a Greek letter.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", expression(alpha), "60"))
@

We can pass a function that accepts the breaks and returns labels to \code{labels}. Package \scales defines several formatters, or we can define our own. For \code{log10} scales

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::scientific_format())
@

\sloppy
Please, see section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} for an example of the use of \code{scales::math\_format} together with a logarithmic transformation of the data.

\subsection{Time and date scales for $x$ and $y$}

\subsubsection{Limits}

Time\index{plots!scales!time!limits} and date scales are conceptually similar to continuous numeric scales, but use special data types and formatting for labels. We can set limits and breaks using constants as time or dates. These are most easily input with the functions in packages \pkgname{lubridate} or \pkgname{anytime}.

Please, see section \ref{sec:ggpmisc:trydf} on page \pageref{sec:ggpmisc:trydf} for examples.

\subsubsection{Axis labels}

By\index{plots!scales!time!axis labels} default the tick labels produced and their formatting is automatically selected based on the extent of the time data. For example, if we have all data collected within a single day, then the tick labels will show hours and minutes. If we plot data for several years, the labels will show the date portion of the time instant. The default is frequently good enough, but it is possible, as for numbers to use different formatter functions to generate the tick labels.

\subsection{Discrete scales for $x$ and $y$}

In\index{plots!scales!limits}\index{plots!scales!discrete} the case of ordered or unordered factors, the tick labels are by default the names of the factor levels. Consequently one roundabout way to obtaining the desired tick labels is to use them as factor levels. This approach is not recommended as in most cases the text of the desired tick labels may not be recognized as a valid name making the code using them difficult to type in scripts or at the command prompt. It is best to use simple mnemonic short names for factor levels and variables, and to set suitable labels when plotting, as we will show here.

\begin{explainbox}
When using factors, the ordering used for plotting levels is the one they have in the factor. When a factor is created, the default is for levels to be stored in alphabetical order. This default can be easily overridden at the time of creation, as well as the order modified at a later time.

<<>>=
default.fct <- factor(c("a", "c", "f", "f", "a", "d"))
levels(default.fct)
@

<<>>=
levels.fct <- factor(c("a", "c", "f", "f", "a", "d"),
                      levels = c("f", "a", "d", "c"))
levels(levels.fct)
@

Reorder can be used to change the order of the levels based on the values of a numeric variable. We will visit once again the \code{Orange} data set.

<<>>=
my1.Tree <- with(Orange,
                reorder(Tree, -circumference))
levels(Orange$Tree)
levels(my1.Tree)
@

Which is equivalent to reversing the order in this particular case.

<<>>=
my2.Tree <- with(Orange,
                factor(Tree,
                levels = rev(levels(Tree))))
levels(Orange$Tree)
levels(my2.Tree)
@

We restore the default ordering.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = sort(levels(Tree))))
levels(Orange$Tree)
levels(my3.Tree)
@

We can set the levels in any arbitrary order by explicitly listing the level names, not only at the time of creation but also later. Here we show that it is possible to not only reorder existing levels, but even to add a level for which there are no observations.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = c("1", "2", "3", "4", "5", "9")))
levels(Orange$Tree)
levels(my3.Tree)
@

\end{explainbox}

We use here once again the \code{mpg} data set.

We order the columns in the plot based on \code{mpg\$hwy} by reordering \code{mpg\$class}. This approach makes sense if this ordering is needed for all plots. It is always bad to keep several versions of a single data set as it easily leads to mistakes and confusion.

<<>>=
my.mpg <- mpg
my.mpg$class <- with(my.mpg, reorder(factor(class), hwy))
ggplot(my.mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or the same on-the-fly, which is much better as the data remains unmodified..

<<>>=
ggplot(mpg, aes(reorder(factor(class), hwy), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or ordering based on a different variable, \code{displ}.

<<>>=
ggplot(mpg, aes(reorder(factor(class), displ), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Alternatively we can use \code{scale\_x\_discrete} to reorder and select the columns without altering the data. If we use this approach to subset the data, then to avoid warnings we need to add \code{na.rm = TRUE}. We use the scale in this example to convert level names to uppercase. The complementary function of \code{toupper} is \code{tolower}.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean, na.rm = TRUE) +
  scale_x_discrete(limits = c("compact", "subcompact", "midsize"),
  labels = toupper)
@

\subsection{Size}

For\index{plots!scales!size} the \code{size} \emph{aesthetic} several scales are available, both discrete and continuous. They do not differ much from those already described above. \emph{Geometries} \code{geom\_point}, \code{geom\_line}, \code{geom\_hline}, \code{geom\_vline}, \code{geom\_text}, \code{geom\_label} obey \code{size} as expected. In the case of \code{geom\_bar}, \code{geom\_col}, \code{geom\_area} and all other geometric elements bordered by lines, \code{size} is obeyed by these border lines. In fact, other aesthetics natural for lines such as \code{linetype} also apply to these borders.

When using \code{size} scales, \code{breaks} and \code{labels} affect the key or \code{guide}. In scales that produce a key passing \code{guide = FALSE} removes the key corresponding to the scale.

\subsection{Color and fill}

Colour\index{scales!color}\index{scales!fill} and fill scales are similar, but they affect different elements of the plot. All visual elements in a plot obey the \code{color} \emph{aesthetic}, but only elements that have an inner region and a boundary, obey both \code{color} and \code{fill} \emph{aesthetics}. There are separate but equivalent sets of scales available for these two aesthetics. We will describe in more detail the \code{color} \emph{aesthetic} and give only some examples for \code{fill}. We will however, start by reviewing how colors are defined and used in R.

\subsubsection{Color definitions in R}\label{sec:plot:colors}
\index{colour|see{color}}
\index{color!definitions|(}
\index{color!using|(}
Colors can be specified in R not only through character strings with the names of previously defined colors, but also directly as strings describing the RGB components as hexadecimal numbers (on base 16) such as \code{"\#FFFFFF"} for white or \code{"\#000000"} for black, or \code{"\#FF0000"} for the brightest available pure red. The list of color names known to R can be obtained be entering \code{colors()} in the console.

Given the number of colors available, we may want to subset them based on their names. Function \code{colors()} returns a character vector. We can use \code{grep()} or \code{grepl()} to find indexes to the names containing a given character substring, in this example \code{"dark"}.

<<>>=
grep("dark",colors())
@

\begin{playground}
Replace \code{grep} by \code{grepl} in the example above. What is the difference in the returned value?
\end{playground}

Although the vector of indexes, or the logical vector, could be used to extract the subset of matching color names with code like,

<<>>=
colors()[grep("dark",colors())]
@

a simpler approach is available.

<<>>=
grep("dark", colors(), value = TRUE)
@

To retrieve the RGB values for a color definition we use

<<>>=
col2rgb("purple")
col2rgb("#FF0000")
@

Color definitions in R can contain a \emph{transparency} described by an \code{alpha} value, which by default is not returned.

<<>>=
col2rgb("purple", alpha = TRUE)
@

With function \code{rgb()} we can define new named or nameless colors.
<<>>=
rgb(1, 1, 0)
rgb(1, 1, 0, names = "my.color")
rgb(255, 255, 0, names = "my.color", maxColorValue = 255)
@

As described above colors can be defined in the RGB \emph{color space}, however, other color models such as HSV (hue, saturation, value) can be also used to define colours.

<<>>=
hsv(c(0,0.25,0.5,0.75,1), 0.5, 0.5)
@

The probably a more useful flavour of HSV colors are those returned by function \code{hcl()} for hue, chroma and luminance. While the ``value'' and ``saturation'' in HSV are based physical values, the ``chroma'' and ``luminance'' values in HCL are based on human visual perception. Colours with equal luminance will be as equally bright by average human being. In a scale based on different hues but equal chroma and luminance values, as used by package \ggplot, all colours are perceived as equally bright. The hues need to be expressed as angles in degrees, with values between zero and 360.

<<>>=
hcl(c(0,0.25,0.5,0.75,1) * 360)
@

It is also important to remember that humans can only distinguish a limited set of colours, and even smaller colour gamuts can be reproduced by screens and printers. Furthermore, variation from individual to individual exists in color perception, including different types of colour blindness. It is important to take this into account when using colour in illustrations.
\index{color!definitions|)}

\subsection{Continuous colour-related scales}
\index{plots!scales!color|(}
\index{plots!scales!fill|(}
\sloppy
Scales \code{scale\_color\_continuous}, \code{scale\_color\_gradient}, \code{scale\_color\_gradient2},  \code{scale\_color\_gradientn}, \code{scale\_color\_date} and \code{scale\_color\_datetime}, give a smooth continuous gradient between two or more colours. They are useful for numerical, date and datetime data. A corresponding set of \code{fill} scales is also available.

\subsection{Discrete colour-related scales}

\sloppy
Scales \code{scale\_color\_discrete}, \code{scale\_color\_hue}, \code{scale\_color\_grey} are useful for categorical data stored as factors.

\subsection{Identity scales}

In the case of identity scales the mapping is 1 to 1 to the data. For example, if we map the \code{color} or \code{fill} \emph{aesthetic} to a variable using \code{scale\_color\_identity} or \code{scale\_fill\_identity} the variable in the data frame passed as argument for \code{data} must already contain valid color definitions. In the case of mapping \code{alpha} the variable must contain numeric values in the rage 0 to 1.

We create a data frame containing a variable \code{colors} containing character strings interpretable as the names of color definitions known to R. We then use them directly in the plot.

<<>>=
df99 <- data.frame(x = 1:10, y = dnorm(10), colors = rep(c("red", "blue"), 5))

ggplot(df99, aes(x, y, color = colors)) +
  geom_point() +
  scale_color_identity()
@

\begin{playground}
How does the plot look, if the identity scale is deleted from the example above? Edit and re-run the example code.
\end{playground}

\begin{playground}
While using the identity scale, how would you need to change the code example above, to produce a plot with green and purple point?
\end{playground}
\index{plots!scales!fill|)}
\index{plots!scales!color|)}
\index{color!using|)}

\subsection{Position of axes}
\index{plots!axis position}

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_x_continuous(position = "top") +
  scale_y_continuous(position = "right")
@

\subsection{Secondary axes}
\index{plots!secondary axes}
<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ . ^-1, name = "1/y")
  )
@

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ ., name = "y", breaks = c(33.2, 55.4))
  )
@
\index{plot!scales|)}

\section{Adding annotations}
\index{plots!annotations}
Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the \code{ggplot} object. Annotations frequently make use \code{"text"} or \code{"label"} \emph{geometries} with character strings as data, possibly to be parsed as expressions. However, other \emph{geometries} can also be very useful. We start with a simple example with text.

<<annotate-01>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  annotate(geom = "text",
           label = "origin",
           x = 0, y = 0,
           color = "blue",
           size=4)
@

\begin{playground}
Play with the values of the arguments to \code{annotate} to vary the position, size, color, font family, font face, rotation angle and justification of the annotation.
\end{playground}

We can add lines to mark the origin more precisely and effectively. With \ggplot 2.2.1 we cannot use \code{annotate} with \code{geom = "vline"} or \code{geom = "hline"}, but we can achieve the same effect by directly adding the \emph{geometry} to the plot.

<<annotate-02>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  geom_hline(yintercept = 0, color = "blue") +
  geom_vline(xintercept = 0, color = "blue")
@

\begin{playground}
Play with the values of the arguments to \code{annotate} to vary the position and attributes of the lines. The vertical and horizontal line geometries have the same properties as other lines: linetype, color, size, etc.
\end{playground}

\begin{playground}
Modify the examples above to use the \code{line} \emph{geometry} for the annotations. Explore the help page for \code{geom\_line} and add arrows as annotations to the plot.
\end{playground}

In this third example, in addition to adding expressions as annotations, we also pass expressions as tick labels through the scale. Do notice that we use recycling for setting the breaks, as \code{c(0, 0.5, 1, 1.5, 2) * pi} is equivalent to \code{c(0, 0.5 * pi, pi, 1.5 * pi, 2 * pi}. Annotations are plotted at their own position, unrelated to any observation in the data, but using the same coordinates and units as for plotting the data.

<<annotate-03>>=
ggplot(data.frame(x=c(0, 2 * pi)), aes(x=x)) +
  stat_function(fun=sin) +
  scale_x_continuous(
    breaks=c(0, 0.5, 1, 1.5, 2) * pi,
    labels=c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y="sin(x)") +
  annotate(geom="text",
           label=c("+", "-"),
           x=c(0.5, 1.5) * pi, y=c(0.5, -0.5),
           size=20) +
  annotate(geom="point",
           colour="red",
           shape=21,
           fill="white",
           x=c(0, 1, 2) * pi, y=0,
           size=6)
@

\begin{playground}
Modify the plot above to show the cosine instead of the sine function, replacing \code{sin} with \code{cos}. This is easy, but the catch is that you will need to relocate the annotations.
\end{playground}

\section{Coordinates and circular plots}
\index{plots!circular|(}

In this section I include pie charts and wind-rose plots. Here we add a new "word" to the grammar of graphics, \textit{coordinates}, such as \code{coord\_polar()} in the next examples\index{coordinates!polar}\index{plots!coordinates!polar}. The default coordinate system for $x$ and $y$ \textit{aesthetics} is cartesian.

\subsection{Pie charts}
\index{plots!pie charts|(}

Pie charts are more difficult to read: our brain is more comfortable at comparing
lengths than angles. If used, they should only be used to show composition, or
fractional components that add up to a total. In this case only if the number of
“pie slices” is small (rule of thumb: less than seven).

We make the equivalent of the first bar plot above. As we are still using \code{geom\_bar} the default is \code{stat\_count}. As earlier we use the brewer scale for nicer colors.

<<>>=
ggplot(data = mpg, aes(x = factor(1), fill = factor(class))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_brewer() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class")
@

Even with four slices pie charts can be difficult to read. Compare the following bar plot and pie chart.

<<>>=
ggplot(data = mpg, aes(x = factor(cyl), fill = factor(cyl))) +
  geom_bar(color = "black") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()

ggplot(data = mpg, aes(x = factor(1), fill = factor(cyl))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()
@

An example comparing pie charts to bar plots is presented in section \ref{sec:plot:pie:bar} on page \pageref{sec:plot:pie:bar}.
\index{plots!pie charts|)}

\subsection{Wind-rose plots}
\index{plots!wind rose|(}
They can be plotted as histograms on polar coordinates, when the data is to be represented by frequencies or, as density plot. A bar plot or a line or points when the values are means calculated with a \emph{statistic} or a single observation is available per quadrat. It also possible to use summaries, or smoothers.

Some types of data are more naturally expressed on polar coordinates than on cartesian coordinates. The clearest example is wind direction, from which the name derives. In some cases of time series data with a strong periodic variation, polar coordinates can be used to highlight any phase shifts or changes in frequency. A more mundane application is to plot variation in a response variable through the day with a clock-face like representation of time-of-day.

We use for this example wind speed and direction data, measured once per minute during 24~h.

<<wind-01>>=
load("data/wind-data.rda")
@

We first show a time series plot, using cartesian coordinates, which demonstrates the problem of using an arbitrary origin at the North for a variable that does not have a scale with true limits: early in the day the predominant direction is just slightly West of 0 degrees North and the cloud of observations gets artificially split. We can also observe a clear change in wind direction soon after solar noon.

<<wind-02>>=
ggplot(viikki_d29.dat, aes(solar_time, WindDir_D1_WVT))  +
geom_point() +
scale_x_datetime(date_labels = "%H:%M") +
labs(x = "Time of day (hh:mm)", y = "Wind direction (degrees)")
@

No such problem exists with wind speed.

<<wind-03>>=
ggplot(viikki_d29.dat, aes(solar_time, WindSpd_S_WVT))  +
geom_point() +
geom_smooth() +
scale_x_datetime(date_labels = "%H:%M") +
labs(x = "Time of day (hh:mm)", y = "Wind speed (m/s)")
@

Using a scatter plot with polar coordinates helps to some extent, but having time of day on the radial axis is rather unclear.

<<wind-04>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, solar_time))  +
  coord_polar() +
  geom_point() +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_datetime(date_labels = "%H:%M",
                   name = "Time of day (hh:mm)",
                   date_breaks = "6 hours",
                   date_minor_breaks = "3 hours",)
@

Most frequently, wind-rose plots use summaries, such as histograms or densities.
Next we plot a circular histogram of wind directions with 15 degrees-wide bins.

<<wind-05>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT))  +
  coord_polar() +
  stat_bin(color = "black", fill = "grey50", binwidth = 15, geom = "bar") +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Frequency")
@

An equivalent plot, using an empirical density.

<<wind-06>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT))  +
  coord_polar() +
  stat_density(color = "black", fill = "grey50", size = 1, na.rm = TRUE) +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Density")
@

As final wind-rose plot examples we do a scatter plot of wind speeds versus wind direction and a two dimensional density plot. In both cases we use \code{facet\_wrap()} to have separate panel for AM and PM. In the scatter plot we set \code{alpha = 0.1} for better visualization of overlapping points.

<<wind-07>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, WindSpd_S_WVT)) +
  coord_polar() +
  geom_point(alpha = 0.1, shape = 16) +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Wind speed (m/s)") +
  facet_wrap(~factor(ifelse(hour(solar_time) < 12, "AM", "PM")))
@

<<wind-08>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, WindSpd_S_WVT)) +
  coord_polar() +
  stat_density_2d() +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Wind speed (m/s)") +
  facet_wrap(~factor(ifelse(hour(solar_time) < 12, "AM", "PM")))
@

\index{plots!wind rose|)}
\index{plots!circular|)}


\section{Themes}\label{sec:plot:themes}
\index{plots!themes|(}
For ggplots themes are the equivalent of style sheets for text. They determine how the different elements of a plot are rendered when displayed, printed or saved to a file. They do not alter how the data themselves are displayed, but instead that of text-labels, titles, axes, grids, etc. are formatted. Package \ggplot includes several predefined themes, and some extension packages define additional ones. In addition to switching between themes, the user can modify the format applied to individual elements, or define totally new themes.

\subsection{Predefined themes}
\index{plots!themes!predefined|(}
The theme used by default is \code{theme\_grey}. Themes are defined as functions, with parameters. These parameters allow changing some ``base'' properties. The base size for text elements is given in points, and affects all text elements in a plot (except those produced by \emph{geometries}) as the size of them is by default defined relative to the base size. Another parameter, \code{base\_family}, allows the font family to be set.

<<themes-01>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  theme_grey(15, "serif")
@

\begin{playground}
Change the code in the previous chunk to use the \code{"mono"} font family at size 8.
\end{playground}

<<themes-02>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  theme_bw()
@

\begin{playground}
Change the code in the previous chunk to use all the other predefined themes: \code{theme\_classic}, \code{theme\_minimal}, \code{theme\_linedraw}, \code{theme\_light}, \code{theme\_dark} and \code{theme\_void}.
\end{playground}

A frequent idiom is to create a ggplot without specifying a theme, and then adding the theme when printed.

<<themes-03>>=
p <- ggplot(fake2.data, aes(z, y)) +
       geom_point()
p + theme_bw()
@

\begin{playground}
Play by replacing in the last statement in the previous code chunk the theme used to print the saved ggplot object \code{p}. Do also try the effect of changing the base size and font family.
\end{playground}

It is also possible to set the default theme to be used by all subsequent plots rendered.

<<themes-04>>=
p
@

We save the current default theme, so as to be able to restore it. If there is no need to `go back' then saving can be skipped by not including the left hand side and the assignment operator in the first statement below.

<<themes-05>>=
old_theme <- theme_set(theme_bw(15))
p
@

<<themes-06>>=
theme_set(old_theme)
p
@
\index{plots!themes!predefined|)}

\subsection{Modifying a theme}
\index{plots!themes!modifying|(}
Sometimes we would just like to slightly tweak one of the predefined themes. This is also possible. We exemplify this by solving the frequent problem of overlapping $x$-axis tick labels with different approaches. We force this by setting the number ticks to a high value. Usually rotating the text of the labels solves the problem.

<<themes-11>>=
ggplot(fake2.data, aes(z + 100, y)) +
  geom_point() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
@

\begin{playground}
Play with the code above, modifying the values used for \code{angle}, \code{hjust} and \code{vjust}. (Angles are expressed in degrees, and justification with values between 0 and 1.
\end{playground}

\begin{warningbox}
When tick labels are rotated one usually needs to set both the horizontal and vertical justification as the default values are no longer suitable. This is due to the fact that justification settings are referenced to the text itself rather than to the plot, i.e.\ vertical justification of $x$-axis tick labels rotated 90 degrees sets their horizontal position with respect to the plot.
\end{warningbox}

Another possibility is to use a smaller font size. Within theme function \code{rel()} can be used to set size relative to the base size.

<<themes-12>>=
ggplot(fake2.data, aes(z + 100, y)) +
  geom_point() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +
  theme(axis.text = element_text(color = "darkblue"),
        axis.text.x = element_text(size = rel(0.6)))
@

Themes definitions follow a hierarchy, allowing us to modify the formatting of groups of similar elements, as well as of individual elements. In the chunk above we modify the color of the tick labels in both axes, but changed the font size only for the $x$-axis.

\begin{playground}
Modify the example above, so that the tick labels on the $x$-axis are blue and those on the $y$-axis red, and the font size the same for both axes, but changed from the default.
\end{playground}

Formatting of all other text elements can be adjusted in a similar way.

The color of the background, and the properties of the grid lines and other lines can be adjusted thought theme elements. We next change the properties of the lines used for the axes, removing the lines on the top and right margins, and adding arrow heads to the axis lines. See chapter 9 in \citetitle{Wickham2016} \autocite{Wickham2016} for additional examples and \citetitle{Chang2013} \autocite{Chang2013} for more details.

\begin{warningbox}
If you use a saved theme, and want to modify some elements, then the saved theme should be added to the plot before adding \code{+ theme(...)} as otherwise the changes would be overwritten.
\end{warningbox}

It is also possible to modify the default theme used for rendering all subsequent plots.

<<themes-14>>=
p
@

As above, we save the current default theme, so as to be able to restore it.

<<themes-15>>=
old_theme <- theme_update(text = element_text(color = "red"))
p
@

<<themes-16>>=
theme_set(old_theme)
p
@
\index{plots!themes!modifying|)}

\subsection{Defining a new theme}
\index{plots!themes!creating|(}

Themes can be defined both from scratch, or by modifying existing saved themes, and saving the modified version. If we want to preserve the ability to change the base settings, we cannot use \code{theme()} to modify a saved theme and save the resulting theme. We need to create a new theme from scratch. However, unless you are writing a package, the first way of ``creating'' a new theme is enough, and documented in the vignette accompanying package \ggplot. We give an example below.

<<themes-21>>=
my_theme <- theme_bw() + theme(text = element_text(color = "red"))
@

The default theme remains unchanged.

<<themes-22>>=
p
@

But we can use the saved theme when desired.

<<themes-23>>=
p + my_theme
@

Be aware that \code{my\_theme} is not a function, and consequently we do not use parenthesis as with the saved themes included in package \ggplot.

\begin{playground}
It is always good to learn to recognize error messages. One way of doing this is by generating errors on purpose. So do add parentheses to the statement in the code chunk above.
\end{playground}

\begin{explainbox}
How to create a new theme with a behaviour similar to those part of package \ggplot is not documented, as it is usually the case with changes that involve programming. However, you should always remember that the source code is available. Usually typing the name of a function without the parentheses is enough to get a listing of its definition, or if this is not useful, then reading the source file in the package reveals how a function has been defined. We can then use it as a template for writing our own function.
\end{explainbox}

Looking at the definition of \code{theme\_minimal} gives us enough information as to proceed to define our own modified theme as a function.

<<themes-31, tidy=TRUE, tidy.opts=list(width.cutoff=30)>>=
theme_minimal
@

Using \code{theme\_minimal} as a model, we will proceed to define our own theme function. Argument \code{complete = TRUE} is essential as it affects the behaviour of the returned theme. A `complete' theme replaces any theme present in the ggplot object clearing all settings, while a theme that is not `complete' adds to the existing the new elements without clearing existing settings not being redefined. Saved themes like \code{theme\_grey()} are complete themes, while the themes objects returned by \code{theme()} are by default not complete.

<<themes-32>>=
my_theme <-
    function (base_size = 11, base_family = "") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(color = "red"), complete = TRUE)
    }
@

The default theme remains unchanged, as shown earlier. The saved theme is now a function, and accepts arguments. In this example we have kept the function parameters the same as used by the predefined themes---whenever it is possible we should avoid surprising users.

<<themes-33>>=
p + my_theme(base_family = "serif")
@

There is nothing to prevent us from defining a theme function with additional parameters. The example below is fully compatible with the one defined above thanks to the default argument for \code{text.color} but allows changing the color.

<<themes-32a>>=
my_theme <-
    function (base_size = 11, base_family = "", text.color = "red") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(color = text.color), complete = TRUE)
    }
@

<<themes-33a>>=
p + my_theme(text.color = "green")
@

\begin{playground}
Define a theme function that instead of \code{color} allows setting the \code{face} (regular, bold, italic) through a user-supplied argument.
\end{playground}

\begin{warningbox}
In the definition of \code{theme\_minimal}, \code{\%+replace\%} is used so as to unset all the properties of each theme element, while \code{+} only replaces the properties explicitly given as argument to the \emph{element}-setting function.
\end{warningbox}

\begin{explainbox}
The function \code{theme\_minimal} was a good model for the example above, however, it was not the first function I explored. I did list the definition of \code{theme\_gray} first, but as this theme is defined from scratch, it was not the best starting point for our problem. Of course, if we had wanted to define a theme from scratch, then it would have been the `model' to use for defining it.
\end{explainbox}

Frequently one needs the same plots differently formatted, e.g.\ for overhead slides and for use in a printed article or book. In such a case, we may even want some elements like titles to be included only in the plots in overhead slides. One could create two different \code{ggplot} objects, one for each occasion, but this can lead to inconsistencies if the code used to create the plot is updated. A better solution is to use themes, more generally, define themes for the different occasions according to one's taste and needs. A simple example is given in the next five code chunks.

<<themes-35>>=
theme_ovh <-
    function (base_size = 15, base_family = "") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(face = "bold"), complete = TRUE)
    }

theme_prn <-
    function (base_size = 11, base_family = "serif") {
        theme_classic(base_size = base_size, base_family = base_family) +
            theme(plot.title = element_blank(),
                  plot.subtitle = element_blank(),
                  complete = TRUE)
    }
@

<<themes-36>>=
p1 <- p + ggtitle("A Title", subtitle = "with a subtitle")
@

<<themes-37>>=
p1
@

<<themes-38>>=
p1 + theme_ovh()
@

<<themes-39>>=
p1 + theme_prn()
@

\begin{playground}
Modify the two themes defined above, so as to suite your own tastes and needs, but first of all, just play around to get a feel of all the possibilities. The help page for function \code{theme()} describes and exemplifies the use of most if not all the valid theme elements.
\end{playground}
\index{plots!themes!creating|)}
\index{plots!themes|)}

\section{Advanced topics}

\section[Using plotmath expressions]{Using \code{plotmath} expressions}\label{sec:plot:plotmath}
\index{plotmath}
\index{plots!math expressions|(}
In sections \ref{sec:plot:function} and \ref{sec:plot:text} we gave some simple examples of the use of R expressions in plot. The \code{plotmath} demo and help in R give all the details of using expressions in plots. Composing syntactically correct expressions can be challenging. Expressions are very useful but rather tricky to use because the syntax is unusual. Although expressions are here shown in the context of plotting, they are also used in other contexts in R code as described in section \ref{sec:??} on page \pageref{sec:??}.

In \code{ggplot} one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined within \code{labs}) the expressions have to be entered explicitly, or saved as such into a variable, and the variable supplied as argument.

When plotting expressions using \code{geom\_text} expression arguments should be supplied as character strings and the optional argument \code{parse = TRUE} used to tell the \emph{geometry} to interpret the labels as expressions.

Finally in the case of facets, panel labels can also also be expressions. They can be generated by \emph{labeller} functions to allow them to be dynamic.

Before examples using these different mechanisms to add maths to plots, I will describe the syntax used to write expressions. The most difficult thing to remember is how to connect the different parts of the expression. Tilde (\code{~}) adds space in between symbols. Asterisk (\code{*}) can be also used as a connector, and is needed usually when dealing with numbers. Using space is allowed in some situations, but not in others. For a long list of examples have a look a the output and code displayed by \code{demo(plotmath)} at the R command prompt.

<<eval=FALSE>>=
demo(plotmath)
@

We will use a couple of complex examples to show in each plot how to use expressions for different elements of a plot.

We first create a data frame, using \code{paste} to assemble a vector of subscripted $\alpha$ values.
<<>>=
set.seed(54321) # make sure we always generate the same data
my.data <-
  data.frame(x = 1:5,
             y = rnorm(5),
             greek.label = paste("alpha[", 1:5, "]", sep = ""))
# my.data$greek.label <- paste("alpha[", my.data$x, "]", sep="")
@

We a lso use a Greek $\alpha$ character, but with $i$ as subscript, instead of a number. The $y$-axis label uses a superscript for the units. The title is a rather complex expression. In these three cases, we explicitly use \code{expression()}.

We label each observation with a subscripted $alpha$, offset from the point position and rotated. We finally add an annotation with the same formula as used for the title but in red. Annotations are plotted ignoring the default aesthetics, but still make use of \emph{geometries}. We cannot pass expressions to \emph{geometries} by simply mapping them to the label aesthetic. Instead, we pass character strings that can be parsed into expressions. In simpler terms, a string, that is written using the syntax of expressions but not using the function \code{expression()}. We need to set \code{parse = TRUE} so that the strings instead of being plotted as is, are parsed into expressions at the time the plot is output.

<<>>=
ggplot(my.data, aes(x,y,label=greek.label)) +
   geom_point() +
   geom_text(angle=45, hjust=1.2, parse=TRUE) +
   labs(x = expression(alpha[i]),
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label="sqrt(alpha[1] + frac(beta, gamma))",
           y=2.5, x=3, size=8, colour="red", parse=TRUE) +
   expand_limits(y = c(-2, 4))
@

The example above is fairly complex, but does not use expressions for all the elements that accept them. The next example uses them for scale labels. In the cases of scales, this there are alternative approaches. The simplest approach is to use user-supplied labels to be parsed into expressions.

<<>>=
ggplot(my.data, aes(x,y,label=greek.label)) +
   geom_point() +
   geom_text(angle=45, hjust=1.2, parse=TRUE) +
   labs(x = NULL,
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label="sqrt(alpha[1] + frac(beta, gamma))",
           y=2.5, x=3, size=8, colour="red", parse=TRUE) +
   scale_x_continuous(breaks = c(1,3,5),
                      labels = c(expression(alpha[1]), expression(alpha[3]), expression(alpha[5]))
                      ) +
   expand_limits(y = c(-2, 4))
@

It is also possible to substitute the value of variables into an expression, allowing on-the-fly construction of expressions to be used as labels.

\textbf{EXAMPLES COMING SOON}

\index{plots!math expressions|)}

\section{Generating output files}
\index{devices!output|see{graphic output devices}}
\index{graphic output devices|(}
It is possible, when using \pgrmname{RStudio}, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R,\index{plots!printing}\index{plots!saving}\index{plots!output to files} files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very\index{plots!PDF output} simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x=-3:3), aes(x=x)) +
  stat_function(fun=dnorm)
pdf(file="fig1.pdf", width=8, height=6)
print(fig1)
dev.off()
@

Encapsulated\index{plots!Postscript output} Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file="fig1.eps", width=8, height=6)
print(fig1)
dev.off()
@

There are Graphics devices for\index{plots!bitmap output} BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file="fig1.tiff", width=1000, height=800)
print(fig1)
dev.off()
@

\subsection{Using \LaTeX\ instead of plotmath}
\index{plots!using Latex@using \LaTeX|(}
\index{tikz output device|see{plots, using \LaTeX}}
To use \LaTeX\ syntax in plots we need to use a different \emph{software device} for output. It is called \code{Tikz} and defined in package \pkgname{tikzDevice}. This device generates output that can be interpreted by \LaTeX\ either as a self-contained file or as a file to be input into another \LaTeX\ source file. As the bulk of this handbook does not use this device, we will use it explicitly and input the files into this section. A \TeX\ distribution should be installed, with \LaTeX\ and several (\LaTeX) packages including \pkgname{tikz}.

\subsubsection{Fonts}

Font face selection, weight, size, maths, etc. are set with \LaTeX\ syntax. The main advantage of using \LaTeX\ is the consistency between the typesetting of the text body and figure labels and legends. For those familiar with \LaTeX\ not having to remember/learn the syntax of plotmath will a bonus.

We will revisit the example from the previous sections, but now using \LaTeX\ for the subscripted Greek $\alpha$ for labels instead of \code{plotmath}. In this example we use as subscripts numeric values from another variable in the same dataframe.
\index{plots!using Latex@using \LaTeX|)}
\index{graphic output devices|)}

\section{Examples}
\index{plots!advanced examples|(}
In this section we first produce some publication-ready plots requiring the use of different combinations of what has been presented earlier in this chapter and then we recreate some well known plots, using versions from Wikipedia articles as models. Our objective here is to show, how by combining different terms and modifiers from the grammar of graphics we can build step by step very complex plots and/or annotate them with sophisticated labels. Here we do not use any packages extending \ggplot2. Even more elaborate versions of these plots are presented in later chapters using \ggplot together with other packages.

\subsection{Heat maps}\label{sec:plot:heatmap}
\index{plots!advanced examples!heatmap plot|(}
Heat maps are 3D plots, with two axes with cartesian coordinates giving origin to rectangular tiles, with a third dimension represented by the \code{fill} of the tiles. They are used to describe deviations from a reference or controls condition, with for example, blue representing values below the reference and red above. A color gradient represents the size of the deviation. Simple heat maps can be produced directly with \ggplot functions and methods. Heat maps with similitude trees obtained through clustering require additional tools.

The main difference with a generic tile plot (See section \ref{sec:tileplot} on page \pageref{sec:tileplot}) is that the fill scale is centred on zero and the red to blue colours used for fill represent a ``temperature''. Nowadays, the name \emph{heatmap} is also used for tile plots using other color for fill, as long as they represent deviations from a central value.

\sloppy
To obtain a heat map, then we need to use as fill scale \code{scale\_fill\_gradient2}. In the first plot we use the default colors for the fill, and in second example we use different ones.

For the examples in this section we use artificial data to build a correlation matrix, which we convert into a data frame before plotting.

<<>>=
set.seed(123)
x <- matrix(rnorm(200), nrow=20, ncol=10)
y <- matrix(rnorm(200), nrow=20, ncol=10)
cor.mat <- cor(x,y)
cor.df <- data.frame(cor = as.vector(cor.mat),
           x = rep(letters[1:10], 10),
           y = LETTERS[rep(1:10, rep(10, 10))])
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2()
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "darkred", mid = "yellow",
  high = "darkgreen")
@
\index{plots!advanced examples!heatmap plot|)}

\subsection{Quadrat plots}
\index{plots!advanced examples!quadrat plot|(}

A quadrat plot is usually a scatter plot, although sometimes lines are also used. The scales are symmetrical both for $x$ and $y$ and negative and positive ranges: the origin $x = 0, y = 0$ is at the geometrical center of the plot.

We generate an artificial data set with \code{y} values correlated to \code{x} values.

<<>>=
set.seed(4567)
x <- rnorm(200, sd = 1)
quadrat_data.df <- data.frame(x = x,
                              y = rnorm(200, sd = 0.5) + 0.5 * x)
@

Here we draw a simple quadrat plot, by adding two lines and using fixed coordinates with a 1:1 ratio between $x$ and $y$ scales.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point() +
    coord_fixed(ratio = 1) +
    theme_bw()
@

We may want to add lines showing 1:1 slopes, make the axes limits symmetric, and make points semi-transparent to allow overlapping points to be visualized. We expand the limits with \code{expand\_limits} rather that set them with \code{limits} or \code{xlim} and \code{ylim}, so that if there are observations in the data set outside our target limits, the limits will still include them. In other words, we set a minimum expanse for the limits of the axes, but allow them to \emph{grow} further if needed.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
    geom_abline(slope = -1, intercept = 0, color = "blue", linetype = "dashed") +
    geom_point(alpha = 0.5) +
    scale_color_identity(guide = FALSE) +
    scale_fill_identity(guide = FALSE) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@

It is also easy to add a linear regression line with its confidence band.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    stat_smooth(method = "lm") +
    geom_point(alpha = 0.5) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@
\index{plots!advanced examples!quadrat plot|)}

\subsection{Volcano plots}\label{sec:plot:volcano}
\index{plots!advanced examples!volcano plot|(}

A volcano plot is just an elaborate version of a scatter plot, and can be created with \ggplot functions.
We here demonstrate how to create a volcano plot with tick labels in untransformed units, off-scale values drawn at the edge of the plotting region and highlighted with a different shape, and points color coded according to whether expression is significantly enhanced or depressed, or the evidence for the direction of the effect is inconclusive. We use a random sample of size 5000 from real data from an RNAseq experiment.

<<>>=
load(file = "data/volcano-example.rda")
head(clean5000.df, 4)
@

First we create a no-frills volcano plot. This is just an ordinary scatter plot, with a certain way of transforming the $P$-values. We do this transformation on the fly when mapping the $y$ aesthetic with \code{y = -log10(PValue)}.

<<>>=
ggplot(data = clean5000.df,
         aes(x = logFC,
             y = -log10(PValue),
             color = factor(outcome))) +
    geom_point() +
    scale_color_manual(values = c("blue", "grey10", "red"), guide = FALSE)
@

Now we add quite many tweaks to the $x$ and $y$ scales. 1) we show tick labels in back-transformed units, at \emph{nice} round numbers. 2) We add publication-ready axis labels. 3) We restrict the limits of the $x$ and $y$ scales, but use \code{oob = scales::squish} so that instead of being dropped observations outside the range limits are plotted at the limit and highlighted with a a different \code{shape}. We also use the black and white \emph{theme} instead of the default one.

As we assume the reverse log transformation to be generally useful we define a function \code{reverselog\_trans} for it. In the plot we use this function to set the transformation as part of the $y$-scale definition, so that we can directly map $P$-values to the $y$ \emph{aesthetic}.

<<>>=
reverselog_trans <- function(base = exp(1)) {
  trans <- function(x) -log(x, base)
  inv <- function(x) base^(-x)
  scales::trans_new(paste0("reverselog-", format(base)), trans, inv,
                    scales::log_breaks(base = base),
                    domain = c(1e-100, Inf))
}

ggplot(data = clean5000.df,
         aes(x = logFC,
             y = PValue,
             color = factor(outcome),
             shape = factor(ifelse(PValue <= 1e-40, "out", "in")))) +
    geom_vline(xintercept = c(log2(2/3), log2(3/2)), linetype = "dotted",
               color = "grey75") +
    geom_point() +
    scale_color_manual(values = c("blue", "grey80", "red"), guide = FALSE) +
    scale_x_continuous(breaks = c(log2(1e-2), log2(1e-1), log2(1/2),
                                  0, log2(2), log2(1e1), log2(1e2)),
                       labels = c("1/100", "1/10", "1/2", "1",
                                  "2", "10", "100"),
                       limits = c(log2(1e-2), log2(1e2)),
                       name = "Relative expression",
                       minor_breaks = NULL) +
    scale_y_continuous(trans = reverselog_trans(10),
                       breaks = c(1, 1e-3, 1e-10, 1e-20, 1e-30, 1e-40),
                       labels = scales::trans_format("log10",
                                                     scales::math_format(10^.x)),
                       limits = c(1, 1e-40), # axis is reversed!
                       name = expression(italic(P)-{value}),
                       oob = scales::squish,
                       minor_breaks = NULL) +
    scale_shape(guide = FALSE) +
    theme_bw()
@
\index{plots!advanced examples!volcano plot|)}

\subsection{Anscombe's regression examples}\label{sec:plot:anscombe}
\index{plots!advanced examples!Anscombe's linear regression plots|(}

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}.

This classical example form \citeauthor{Anscombe1973} (\citeyear{Anscombe1973}) demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

I will redraw the Wikipedia figure using \ggplot, but first I rearrange the original data.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- data.frame(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

Once the data is in a data frame, plotting the observations plus the regression lines is easy.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2)
@

It is not much more difficult to make it look similar to the Wikipedia original.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm", se=FALSE) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@

Although I think that the confidence bands make the point of the example much clearer.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@
\index{plots!advanced examples!Anscombe's linear regression plots|)}

\subsection{Plotting color patches}
\index{plots!advanced examples!color patches|(}

For choosing colours when designing plots, or scales used in them, an indexed colour patch plot is usually very convenient (see section \ref{sec:plot:colors} on page \pageref{sec:plot:colors}. We can produce such a chart of colors with subsets of colors, or colours re-ordered compared to their position in the value returned by \code{colors()}. As the present chapter is on package \ggplot we use this package in this example. As this charts are likely to be needed frequently, I define here a function \code{ggcolorchart}.

<<>>=
ggcolorchart <- function(colors,
                         ncol = NULL,
                         use.names = NULL,
                         text.size = 2) {
    # needed if the argument passed is subset with [ ]!
    force(colors)

    len.colors <- length(colors)
    # by default we attempt to use
    if (is.null(ncol)) {
      ncol <- max(trunc(sqrt(len.colors)), 1L)
    }
    # default for when to use color names
    if (is.null(use.names)) {
      use.names <- ncol < 8
    }
    # number of rows needed to fit all colors
    nrow <- len.colors %/% ncol
    if (len.colors %% ncol != 0) {
      nrow <- nrow + 1
    }
    # we extend the vector with NAs to match number of tiles
    if (len.colors < ncol*nrow) {
      colors[(len.colors + 1):(ncol*nrow)] <- NA
    }
    # we build a data frame
    colors.df <-
      data.frame(color = colors,
                 text.color =
                   ifelse(sapply(colors,
                                 function(x){mean(col2rgb(x))}) > 110,
                                 "black", "white"),
                 x = rep(1:ncol, nrow),
                 y = rep(nrow:1, rep(ncol, nrow)),
                 idx = ifelse(is.na(colors),
                              "",
                              format(1:(ncol * nrow), trim = TRUE)))
 # we build the plot
 p <- ggplot(colors.df, aes(x, y, fill = color))
 if (use.names) {
   p <- p + aes(label = ifelse(is.na(colors), "", colors))
 } else {
   p <- p + aes(label = format(idx, width = 3))
 }
 p <- p +
    geom_tile(color = "white") +
    scale_fill_identity() +
    geom_text(size = text.size, aes(color = text.color)) +
    scale_color_identity()
 p + theme_void()
}
@

\begin{playground}
After reading the use examples below, review the definition of the function, section by section, trying to understand what is the function of each section of the code. You can add print statements at different steps to look at the intermediate data values. Once you think you have grasped the purpose of a given statement, you can modify it in some way that modifies the output. For example, changing the defaults, for the shape of the tiles, e.g.\ so that the number of columns is about $1/3$ of the number of rows. Although you may never need exactly this function, studying its code will teach you some \emph{idioms} used by R programers. This function, in contrast to some other R code examples for plotting color tiles, does not contain any loop. It returns a \code{ggplot} object, which be added to and/or modified.
\end{playground}

We first the predefined colors available in R.

<<>>=
ggcolorchart(colors()) +
  ggtitle("R colors",
          subtitle = "Labels give index or position in colors() vector")
@
\label{chunk:plot:color:tiles}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

We subset those containing ``blue'' in the name, using the default number of columns.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), text.size = 3)
@

We reduce the number of columns and obtain rectangular tiles. The default for \code{use.names} depends on the number of tile columns, triggering automatically the change in labels.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), ncol = 4)
@

We demonstrate how perceived colors are affected by the hue, saturation and value in the HSV colour model.

<<>>=
ggcolorchart(hsv(1, (0:48)/48, 0.67), text.size = 3) +
  ggtitle("HSV saturation", "H = 1, S = 0..1, V = 0.67")
@

<<>>=
ggcolorchart(hsv(1, 1, (0:48)/48), text.size = 3) +
  ggtitle("HSV value", "H = 1, S = 1, V = 0..1")
@

<<>>=
ggcolorchart(hsv((0:48)/48, 1, 1), text.size = 3) +
  ggtitle("HSV hue", "H = 0..1, S = 1, V = 1")
@

We demonstrate how perceived colors are affected by the hue, chroma and luminance in the HCL colour model.

<<>>=
ggcolorchart(hcl((0:48)/48 * 360), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 85")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, l = 67), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 67")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, c = 67), text.size = 3) +
    ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 67, l = 85")
@

\begin{playground}
  The default order of the different colors in the vector returned by \code{colors()} results in a rather unappealing color tile plot (see page \pageref{chunk:plot:color:tiles}). Use functions \code{col2rgb()}, \code{rgb2hsv()} and \code{sort()} or \code{order()} to rearrange the tiles into a more pleasant arrangement, but still using for the labels the indexes to the positions of the colors in the original unsorted vector.
\end{playground}
\index{plots!advanced examples!color patches|)}

\subsection{Pie charts vs.\ bar plots example}\label{sec:plot:pie:bar}
\index{plots!advanced examples!pies vs. bar plots@plots!advanced examples!pies \emph{vs.}\ bar plots|(}

<<>>=
opts_chunk$set(opts_fig_wide)
@

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}).

Here is my \ggplot version of the same figure, using much simpler code and obtaining almost the same result.

<<>>=
example.data <-
  data.frame(values = c(17, 18, 20, 22, 23,
                        20, 20, 19, 21, 20,
                        23, 22, 20, 18, 17),
             examples= rep(c("A", "B", "C"), c(5,5,5)),
             cols = rep(c("red", "blue", "green", "yellow", "black"), 3)
  )

ggplot(example.data, aes(x=cols, y=values, fill=cols)) +
  geom_col(width = 1) +
  facet_grid(.~examples) +
  scale_fill_identity()
ggplot(example.data, aes(x=factor(1), y=values, fill=cols)) +
  geom_col(width = 1) +
  facet_grid(.~examples) +
  scale_fill_identity() +
  coord_polar(theta="y")
@
\index{plots!advanced examples!pies vs. bar plots@plots!advanced examples!pies \emph{vs.}\ bar plots|)}
\index{plots!advanced examples|(}

\section{Building complex data displays}
\index{examples!modular plot construction|(}

In this section we do not refer to those aspects of the design of a plot that can be adjust through themes (see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes}. Whenever this possibility exists, it is the best. Here we refer to aspects that are not really part of the graphical (''artistic'') design, but instead mappings, labels and similar data and metadata related aspects of plots. In many cases scales (see section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}) also fall within the scope of the present section.

\subsection{Using the grammar of graphics for individual plots}\label{sec:plot:composition}

The grammar of graphics\index{grammar of graphics}\index{plots!layers} allows one to build and test plots incrementally. In daily use, it is best to start with a simple design for a plot, print this plot, checking that the output is as expected and the code error-free. Afterwards, one can map additional \emph{aesthetics} and \emph{geometries} and \emph{statistics} gradually. The final steps are then to add \emph{annotations} and the text or expressions used for titles, and axis and key labels.

\begin{playground}
  Build a graphically complex data plot of your interest, step by step. By step by step, I do not refer to using the grammar in the construction of the plot as earlier, but of taking advantage of this modularity to test intermediate version in an iterative design process, first by building up the complex plot in stages as a tool in debugging, and later using iteration in the processes of improving the graphic design of the plot and improving its readability and effectiveness.
\end{playground}

\subsection{Using the grammar of graphics for series of plots with consistent design}

As in any type of script with instructions (for humans or computers), we should avoid unnecessary repetition, as repetition conspires against consistent results and is a major source of errors when the script needs to be modified. Not less important, a shorter script, if well written is easier to read.

One approach is to use user-defined functions\index{plots!consistent format using functions}. One can for example, write simple wrapper functions on top functions defined in \ggplot, for example, adding/changing the defaults mappings to ones suitable for our application. In the case of \code{ggplot()}, as it is defined as a generic function, if one's data is stored in objects of a user-defined class, the wrapper can be a specialization of the generic, and become almost invisible to users (e.g.\ not require a different syntax or adding a word to the grammar). At the other extreme of complexity compared to a wrapper function, we could write a function that encapsulates all the code needed to build a specific type of plot. Package \pkgname{ggspectra} uses the last two approaches.

As \code{ggplot}\index{plots!reusing parts of} objects are composed using operator \code{+} to assemble together the different components, one can also store in a variable these components, or using a list, partial plots, which can be used to compose the final figure.

\begin{explainbox}
We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

<<>>=
myplot <- ggplot(data = mtcars,
                 aes(x=disp, y=mpg,
                 colour=factor(cyl))) +
          geom_point()

mylabs <- labs(x="Engine displacement)",
               y="Gross horsepower",
               colour="Number of\ncylinders",
               shape="Number of\ncylinders")
@

And now we can assemble them into plots.

<<>>=
myplot
myplot + mylabs + theme_bw(16)
myplot + mylabs + theme_bw(16) + ylim(0, NA)
@

We can also save intermediate results.

<<>>=
mylogplot <- myplot + scale_y_log10(limits=c(8,55))
mylogplot + mylabs + theme_bw(16)
@

If the pieces to put together do not include a "ggplot" object, we can put them
into a "list" object.

<<>>=
myparts <- list(mylabs, theme_bw(16))
mylogplot + myparts
@

The\index{plots!themes} are a few predefined themes in package \ggplot and additional ones in other packages such as \cowplot, even the default \code{theme\_grey} can come in handy because the first parameter to themes is the point size used as reference to calculate all other font sizes. You can see in the two examples bellow, that the size of all text elements changes proportionally when we set a different base size in points.

<<>>=
myplot + mylabs + theme_grey(10)
myplot + mylabs + theme_grey(16)
@

The code in the next chunk is valid, it returns a blank plot. This apparently useless plot, can be very useful when writing functions that return \code{ggplot} objects or build them piece by piece in a loop.

<<>>=
ggplot()
@

\begin{playground}
Revise the code you wrote for the ``playground'' exercise in section \ref{sec:plot:composition}, but this time, pre-building and saving groups of elements that you expect to be useful unchanged when composing a different plot of the same type, or a plot of a different type from the same data.
\end{playground}

\end{explainbox}
\index{examples!modular plot construction|)}


<<eco=FALSE>>=
try(detach(package:lubridate))
try(detach(package:tikzDevice))
try(detach(package:ggplot2))
try(detach(package:scales))
@

