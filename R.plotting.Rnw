% !Rnw root = appendix.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
opts_knit$set(unnamed.chunk.label = 'plotting-chunk')
@

\chapter{Grammar of graphics}\label{chap:R:plotting}

\begin{VF}
The commonality between science and art is in trying to see profoundly---to develop strategies of seeing and showing.

\VA{Edward Tufte}{}
\end{VF}

%\dictum[Edward Tufte]{The commonality between science and art is in trying to see profoundly---to develop strategies of seeing and showing.}

\index{geometries ('ggplot2')|see{plots, geometries}}
\index{geom@\texttt{geom}|see{plots, geometries}}
\index{functions!geom@\texttt{geom}|see{plots, geometries}}
\index{statistics ('ggplot2')|see{plots, statistics}}
\index{stat@\texttt{stat}|see{plots, statistics}}
\index{functions!stat@\texttt{stat}|see{plots, statistics}}
\index{scales ('ggplot2')|see{plots, scales}}
\index{scale@\texttt{scale}|see{plots, scales}}
\index{functions!scale@\texttt{scale}|see{plots, scales}}
\index{coordinates ('ggplot2')|see{plots, coordinates}}
\index{themes ('ggplot2')|see{plots, themes}}
\index{theme@\texttt{scale}|see{plots, themes}}
\index{function!theme@\texttt{scale}|see{plots, themes}}
\index{facets ('ggplot2')|see{plots, facets}}
\index{annotations ('ggplot2')|see{plots, annotations}}
\index{aesthetics ('ggplot2')|see{plots, aesthetics}}

\section{Aims of this chapter}

Three main plotting systems are available to \Rlang users: base \Rlang, package \pkgname{lattice} \autocite{Sarkar2008} and package \pkgname{ggplot2} \autocite{Wickham2016}, being the last one the most recent and currently most popular system available in \Rlang for plotting data. Even two different sets of graphics primitives are available in \Rlang, that in base \Rlang and a newer one in the \pkgname{grid} package \autocite{Murrell2011}.

In this chapter you will learn the concepts of the grammar of graphics, on which package \pkgname{ggplot2} is based. You will as well learn how to do many of the data plots that can be produced with package \pkgname{ggplot2}. We will focus only on the grammar of graphics, as it is currently the most used plotting approach in \Rlang. As a consequence of this popularity and its flexibility, many extensions to \pkgname{ggplot2} have been developed and deposited in public repositories. Several of these packages will be described in Chapter \ref{chap:R:more:ggplotting} starting on page \pageref{chap:R:more:ggplotting} and in Chapter \ref{chap:R:maps} starting on page \pageref{chap:R:maps}. As previous chapters, this chapter is intended to be read in whole.

This chapter focuses mainly on how to construct different types of graphical data displays using the grammar of graphics. We also discuss how to alter the ``graphical design'' of the plots produced, but in less depth, mostly leaving for the reader to try by herself/himself the different combinations of types of plots and themes and color palettes described. The book \citebooktitle{Burchell2016} \autocite{Burchell2016} has a strong focus on the control of how plots look, and can be a good source of worked out examples. For a cook book with a broader scope and detailed explanations consult \citebooktitle{Chang2013} \autocite{Chang2013}. The contents of the current chapter to some extent overlap with that of Chang's book, but using a different approach for presentation. Deeper explanations of technical aspects are available in the book \citebooktitle{Murrell2011} \autocite{Murrell2011}. Finally, the book \citebooktitle{Wickham2016} \autocite{Wickham2016} written by the developers of package \pkgname{ggplot2} is the main reference, and describes the grammar of graphics in more detail than we have space here for. In particular, the hands-on approach followed here makes this chapter a good complement to \citebooktitle{Wickham2016}.

\section{Packages used in this chapter}

<<>>=
citation(package = "ggplot2")
@

If the packages used in this chapter are not yet installed in your computer, you can install them with, as long as package \pkgname{learnrbook} is already installed.

<<eval=FALSE>>=
install.packages(learnrbook::pkgs_ch_ggplot)
@

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(learnrbook)
library(scales)
library(ggplot2)
library(ggrepel)
library(ggpmisc)
library(ggbeeswarm)
library(ggforce)
library(tikzDevice)
library(lubridate)
library(tidyverse)
@

We set a font of larger size than the default
<<>>=
theme_set(theme_grey(14))
@

<<echo=FALSE>>=
# set to TRUE to test non-executed code chunks and rendering of plots
eval_plots_all <- FALSE
@

\section{Introduction}

Being \Rlang extensible, in addition to the built-in plotting functions, there are several alternatives provided by packages. Of the general purpose ones, the most extensively used are \pkgname{Lattice} \autocite{Sarkar2008} and \ggplot \autocite{Wickham2016}. There are additional packages that add extra functionality to these packages, many of them available through CRAN.

In the examples in this chapter we describe the of use package \ggplot. We start with an introduction to the `grammar of graphics' and \ggplot. There is ample literature on the use of \ggplot, including the very good reference documentation at \url{http://docs.ggplot2.org/}. The book titled \citebooktitle{Wickham2016} \autocite{Wickham2016} is the authoritative reference, as it is authored by the developers of \ggplot. The book `R Graphics Cookbook' \autocite{Chang2013} is very useful as a reference as it contains many worked out examples. Some of the literature available at this time is for older versions of \ggplot but we here describe version 3.1.0, and highlight the most important incompatibilities that need to be taken into account when using versions of \ggplot earlier than 3.0.0. Consistent with the title of this book, we focus on the Grammar of Graphics, and describe it as a language. We use examples to demonstrate the features of the language and how they can be used.

\section{Grammar}

What separates \ggplot from base \Rlang and trellis/lattice plotting functions is the use of a grammar of graphics\index{grammar of graphics} (the reason behind `gg' in the name of the package). What is meant by grammar in this case is that plots are assembled piece by piece from different `nouns' and `verbs' \autocite{Cleveland1985}. Instead of using a single function with many arguments, plots are assembled by combining different elements with operators \code{+} and \verb|%+%|. Furthermore, the construction is mostly semantic-based and to a large extent how the plot looks when is printed, displayed or exported to a bitmap or vector-graphics file is controlled by themes.

We can think of plotting as representing the observations or data in a graphical language. We use the properties of graphical objects to represent different aspects of our data. An observation can consist in multiple values recorded. Say an observation of air temperature may be defined by a position in 3-dimensional space and a point in time, in addition to the temperature itself. An observation for the size and shape of a plant can consist in height, stem diameter, number of leaves, size of individual leaves, length of roots, fresh mass, dry mass, etc. If we are interested in the relationship between height and stem diameter, we may want to use cartesian coordinates, \emph{mapping} stem diameter to the $x$ dimension of the plot and the height to the $y$ direction. The observations could be represented on the plot by dots and/or joined by lines.

The grammar of graphics allows us to design plots by combining various elements in ways that are nearly orthogonal. In other words, the majority of the possible combinations of ``words'' yield valid plots as long as we assemble them respecting the rules of the grammar. This flexibility makes \ggplot extremely powerful as we can build plots and even types of plots which were not even considered while designing the \ggplot package.

When a plot is built the whole plot and its components are created as \Rlang objects that can be saved in the workspace or written to a file as objects. The graphical representation is generated when the object is printed, explicitly or automatically. The same ggplot object can be rendered into different bitmap and vector graphic formats for display or printing.

Even if we do not explicitly add them all, default elements may be used. The production of a rendered graphic with package \pkgname{ggplot2} can be represented as a flow of information:
\textsf{data $\to$ scale $\to$ statistic $\to$ aesthetic $\to$ geometry $\to$ coordinate $\to$ ggplot $\to$ theme $\to$ rendered graphic}

\subsection{Data}

The data to be plotted must be available as a \code{data.frame} or \code{tibble}, with data stored so that each row represents a single observation event, and the columns different values observed in that single event. In other words, as \emph{tidy data} as described in Chapter \ref{chap:R:data}. The variables to be plotted can be \code{numeric}, \code{factor}, \code{character}, and time or date stored as \code{POSIXct}.

\subsection{Mapping}

When we design a plot, we need to map data variables to aesthetics\index{plots!aesthetics} (or graphic `properties'). Most plots will have an $x$ dimension, which is considered an aesthetic, and a variable containing numbers mapped to it. The position on a 2D plot of say a point will be determined by $x$ and $y$ aesthetics, while in a 3D plot, three aesthetics need to be mapped $x$, $y$ and $z$. Many aesthetics are not related to coordinates, they are properties, like color, size, shape, line type or even rotation angle, which add an additional dimension on which to represent the values of variables and/or constants.

\subsection{Geometries}

\sloppy%
Geometries\index{plots!geometries} describe the graphics representation of the data: for example, \gggeom{geom\_point()}, plots a `point' or symbol for each observation, while \gggeom{geom\_line()}, draws line segments between successive observations. Some geometries rely by default on statistics, but most `geoms' default to the identity statistics. Each time a \emph{geometry} is used to add a graphical representation of data to a plot, we say that a new \emph{layer} has been added. The name \emph{layer} reflects the fact that each new layer added is plotted on top of the layers already present in the plot, or rather when a plot is printed the layers will be generated in the order they were added to the ggplot object.

\subsection{Statistics}

Statistics\index{plots!statistics} are `words' that represent calculation of summaries or some other operation on the values from the data, and these summary values can be plotted with a geometry. For example \ggstat{stat\_smooth()} fits a smoother, and \ggstat{stat\_summary()} applies a summary function. Statistics are applied automatically by group when data has been grouped by mapping additional aesthetics such as color to a factor. When \emph{statistics} are used for a computation, the returned value is passed directly to a \emph{geometry}, and consequently adding an \emph{statistics} also adds a layer to the plot.

\subsection{Scales}

Scales\index{plots!scales} give the relationship between data values and the aesthetic values to be actually plotted. Mapping a variable to the `color' aesthetic only tells that different values stored in the mapped variable will be represented by different colors. A scale, such as \ggscale{scale\_color\_continuous()} will determine which color in the plot corresponds to which value in the variable. The observations falling outside the limits of a scale are ignored rather than passed to the next step (statistics or geometries)---this can easily take place unintentionally when only summaries are included in a plot and a user does not pay attention to warning messages. Scales can also define transformations on the data, which are used to map data values to values to be plotted, while retaining the original values for tick labels.  Scales are used for continuous variables, such as numbers, and for categorical ones such as factors.

\subsection{Coordinate systems}

The most frequently used coordinate system\index{plots!coordinates} when plotting data is the cartesian system, which is the default for most \emph{geometries}. In the cartesian system, $x$ and $y$ are represented as distances on two orthogonal (at 90$^\circ$) axes. In the polar system of coordinates, angles around a central point are used instead of distances on a straight line. However, package \pkgname{ggtern} adds a ternary system of coordinates, to allow the extension of the grammar to allow the construction of ternary plots. Setting limits to a coordinate system changes the region of the plotting space visible in the plot, but does not discard observations. In other words, when using \emph{statistics}, observations located outside the coordinate limits---i.e.\ not visible in the rendered plot---, will still be included in computations.

\subsection{Themes}

How the plots look when displayed or printed can be altered by means of themes\index{plots!themes}. A plot can be saved without adding a theme and then printed or displayed using different themes. Also individual theme elements can be changed, and whole new themes defined. This adds a lot of flexibility and helps in the separation of the data representation aspects from those related to the graphical design.

\subsection{Building a plot}

We have described above the components of the grammar of graphics: aesthetics (\code{aes}) as for example color, geometric elements \code{geom\_\ldots} such as lines, and points, statistics \code{stat\_\ldots}, scales \code{scale\_\ldots}, \code{coordinate} systems and themes \code{theme\_\ldots}. In this section we will see how plots can assembled from these elements.

When we do not explicitly add these elements, default elements will be used, in some cases defaults that result in empty plots.

As the workings and use of the grammar are easier to show by example than to explain with words, we will show how to build plots of increasing complexity.
We start with the simplest possible plot, an empty plot. We use function \code{ggplot()} to create the skeleton for a plot.

<<ggplot-basics-01>>=
ggplot()
@

The plot above is of little use, without any data, so we next pass a data frame object, in this case \code{mtcars}---\code{mtcars} is a data set included in \Rlang; to learn more about this data set, type \code{help("mtcars")} at the \Rlang command prompt.

<<ggplot-basics-02>>=
ggplot(data = mtcars)
@

Once the data are available, we need to \emph{map} the quantities in the data onto graphical features in the plot, or \emph{aesthetics}. When plotting in two dimensions, we need to map variables in the data to at least the $x$ and $y$ aesthetics. This mapping can be seen in the chunk below by its effect on the plotting area ranges that now matches the range (plus a margin) of the mapped variables. The axis labels also reflect the names of the mapped variables, however, there is no graphical element yet displayed for the individual observations.

<<ggplot-basics-03>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg))
@

To make observations visible in the plot we need to add a suitable \emph{geometry} or \code{geom} to the plot. Here we display the observations as points using \gggeom{geom\_point()}

<<ggplot-basics-04>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point()
@

Although \emph{aesthetics} can be mapped to variables in the data, they can also be set to a constant, within a layer.

<<ggplot-basics-04a>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point(colour = "red", shape = "square")
@

While a geometry directly constructs a graphical representation of the observations in the data, a \emph{statistics} or \code{stat} ``sits'' in-between the data and a \code{geom}, applying some computation, usually but not always, to produce a statistical summary of the data. Here we add a fitted line using \code{stat\_smooth()} with its output added to the plot using \gggeom{geom\_line()} passed by name with \code{"line"} as argument to \code{stat\_smooth}. We fit a linear regression, using \code{lm()} passed as method.

<<ggplot-basics-05>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  stat_smooth(geom = "line", method = "lm")
@

We haven't added yet some of the elements of the grammar described above: \emph{scales}, \emph{coordinates} and \emph{themes}. The plot can anyway be rendered because these elements have defaults which are used when we do not set them explicitly. We next will see examples in which they are explicitly set. We start with a scale using a logarithmic transformation. This works like plotting by hand using graph paper with rulings spaced according to a logarithmic scale. Tick marks, continue being expressed in the original units, but statistics are applied to the transformed data. In other words, a transformed scale affects the values before they are passed to \emph{statistics}, and the linear regression will be fitted to \code{log10()} transformed $y$ values and the original $x$ values.

<<ggplot-basics-06>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  stat_smooth(geom = "line", method = "lm") +
  scale_y_log10()
@

The range limits of a scale can be set manually, instead of automatically as above. Scales limits function as a window into the data, observations outside the scale limits are discarded. When using \code{stats} the computations are only applied to observations that fall within the limits. These limits indirectly also alter the plotting area.

In contrast to \emph{statistics}, \emph{coordinates} function as a window into the plotting area, and do not affect which observations are used by \code{stats}. The coordinate system, as expected, is also determined by this grammar element---here we use cartesian coordinates which are the default, but with manually set $y$ limits.

<<ggplot-basics-07>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  stat_smooth(geom = "line", method = "lm") +
  coord_cartesian(ylim = c(15, 25))
@

Next example uses a coordinate system transformation. When the transformation is applied to the coordinate system, it affects only the plotting. The transformation is applied to the values returned by any \emph{statistics}. The straight line fitted is plotted on the transformed coordinates as a curve, because the fit was done to the untransformed data and the predicted values computed using this model and fitted parameters estimates.

<<ggplot-basics-08>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  stat_smooth(geom = "line", method = "lm") +
  coord_trans(y = "log10")
@

Themes affect the rendering of plots at the time of printing. A complete theme can override the default gray theme. The plot is the same, the observations are represented in the same way, the limits of the axes is the same and the text is the same. On the other hand how these elements are rendered is drastically different.

<<ggplot-basics-09>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  theme_classic()
@

We can also override the base font size. This affects the size of all text elements, as their size is defined relative to the base size. Here we add the same theme as used in the previous examples, but with a different base point size for text.

<<ggplot-basics-10>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  theme_classic(20)
@

The details of how to set axis labels, tick positions and tick labels will be discussed in depth in section \ref{sec:plot:scales}. Meanwhile, we will use function \code{labs()} which is a convenience function allowing to easily replace the \code{name} of scales and to set plot titles. For setting the names of the scales (used for labels) here we use \code{x} and \code{y}, the names of the \emph{aesthetics} to which we have mapped the two variables in \code{data}, \code{disp} and \code{mpg}.

<<ggplot-basics-11>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point() +
  labs(x = "Engine displacement (cubic inches)",
       y = "Fuel use efficiency (miles per gallon)",
       title = "Motor Trend Car Road Tests",
       subtitle = "Source: 1974 Motor Trend US magazine")
@

\begin{infobox}
As elsewhere in \Rlang, when a value is expected, either a value stored in a variable or an statement returning a suitable value can be passed as an argument to be mapped to an \emph{aesthetic}. In other words, the values to be plotted do not need to be stored in the data frame passed as argument to formal parameter \code{data} as a variable, they can also be computed from these variables. Here we plot miles-per-gallon, \code{mpg} on the engine displacement per cylinder by dividing \code{disp} by \code{cyl} within the call to \code{aes()}.

<<ggplot-basics-info-01>>=
ggplot(data = mtcars, aes(x = disp / cyl, y = mpg)) +
  geom_point()
@
\end{infobox}

Each of the elements of the grammar exemplified above have several different members, and many of the individual \emph{geometries} and \emph{statistics} accept arguments that can be used to modify their behaviour. There are also more \emph{aesthetics} than those shown above. Multiple data objects as well as multiple mappings can coexist within a single ggplot object.
Individual elements in a theme can be also modified and new complete themes created. We will describe them in the remaining sections of this chapter, but first we will see what are the consequences of \code{"gg"} objects being regular \Rlang objects, and of graphical rendering being a separate step from the creation of the plot object.

\subsection{Plots as \Rlang objects}

We can manipulate ggplot objects as other \Rlang objects, and also operate on them using the operators and methods defined for the \code{"gg"} class they belong to.
In the previous section the returned value was automatically printed when the statements were executed. Here we save the returned value, the ggplot, into a variable.

<<ggplot-objects-00>>=
p <- ggplot(data = mtcars,
       aes(x = disp, y = mpg)) +
  geom_point()
@

We can print the object, with an explicit or an implicit call to method \code{print()}.
<<ggplot-objects-01>>=
print(p)
@

\begin{warningbox}
  The separation of plot construction and rendering is possible, because \code{"gg"} objects are self contained. Most importantly a copy of the data object passed as argument is saved within the plot object. In the example above, \code{p} by itself could be saved to a file on disk and loaded into a clean session, or another computer, and rendered as long as package \ggplot and its dependencies are available.

  With \code{str()} we can explore the structure of any \Rlang object, including those of class \code{"gg"}. We use \code{max.level = 1} to reduce the length of output, but to see deeper into the nested list you can increase the value passed as argument to \code{max.level} or simply accept its default.

  <<ggplot-objects-warn-01, eval=eval_playground>>=
str(p, max.level = 1)
@
\end{warningbox}

When we used in the previous section operator \code{+} to assemble the plots we were operating on \Rlang objects. In the same way we can operate saved objects.

<<ggplot-objects-02>>=
p +
  stat_smooth(geom = "line", method = "lm")
@

\begin{playground}
  Reproduce the examples in the previous section, using \code{p} defined above as a basis instead of building each plot from scratch.
\end{playground}

\begin{infobox}
  In the examples above we have been adding elements one by one, using the \code{+} operator. It is also possible to add multiple components in one go using a list. This is useful, when we want to save sets of components in a variable so as to reuse them in multiple plots.

  <<ggplot-objects-info-01>>=
  my.layers <- list(
      stat_smooth(geom = "line", method = "lm"),
      scale_x_log10())
@

  <<ggplot-objects-info-02>>=
  p + my.layers
@

\end{infobox}

\section{Geometries}\label{sec:plot:geometries}
\index{plots!geometries|(}

Different geometries support different \emph{aesthetics}. While \gggeom{geom\_point()} supports \code{shape}, and \gggeom{geom\_line()} supports \code{linetype}, both support \code{x}, \code{y}, \code{colour} and \code{size}. In this section we will describe the different \code{geometries} available in package \ggplot and some examples for packages that extend \ggplot. The graphic output from most code examples will not be shown, with the expectation that readers will run them to see the plots.

Mainly for historical reasons, \emph{geometries} accept a \emph{statistic} as argument, in the same way as \emph{statistics} accept a \emph{geometry} as argument. In this section we will only describe \emph{geometries} which have as default \emph{statistic} \code{stat\_identity} which passes values directly as mapped. The \emph{geometries} that have other \emph{statistics} as default are described in section \ref{sec:plot:stat:summaries} together with the corresponding \emph{statistics}.

\subsection{Point}\label{sec:plot:geom:point}
\index{plots!point geometry|(}

As shown earlier in this chapter, \gggeom{geom\_point()}, can be used to add a layer with observations represented by ``points'' or symbols. Variable \code{cyl} describes the numbers of cylinders in the engines of the cars. It is a numeric variable, and when mapped to colour, a continuous colour scale is used to represent this variable.

\index{plots!scatter plot|(}The first examples build scatter plots, because numeric variables are mapped to both \code{x} and \code{y}.
Some scales, like those for \code{colour}, exist in two `flavours', one suitable for numeric variables (continuous) and another for factors (discrete).

<<scatter-01>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = cyl)) +
  geom_point()
@

If we convert \code{cyl} into a factor, a discrete colour scale is used instead of a continuous one.

<<scatter-02, eval=eval_plots_all>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point()
@

If we convert \code{cyl} into an ordered factor, a different discrete colour scale is used by default.

<<scatter-02a, eval=eval_plots_all>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = ordered(cyl))) +
  geom_point()
@

\begin{playground}
Try a different mapping: \code{disp} $\rightarrow$ \code{color}, \code{cyl} $\rightarrow$ \code{x}. Continue by using \code{help(mtcars)} and/or \code{names(mtcars)} to see what variables are available, and then try the combinations that trigger your curiosity.
\end{playground}

The mapping between data values and aesthetic values is controlled by scales. Different colour scales, and even palettes within a given scale, provide different mappings that can be used to the default scale.

<<scatter-03, eval=eval_plots_all>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point() +
  scale_color_brewer(type = "qual", palette = 2)
@

Neither the data, nor the aesthetics mappings or geometries are different than in earlier code; to alter how the plot looks we have changed only the scale and palette used for the color aesthetic. Conceptually it is still exactly the same plot we earlier created, except for the colours used. This is a very important point to understand, because it allows us to separate two different concerns: the semantic structure and the graphic design.

\begin{playground}
Try the different palettes available through the brewer scale. You can play directly with the palettes using function \code{brewer\_pal()} from package \pkgname{scales} together with \code{show\_col()}).
<<scatter-04, eval=eval_playground>>=
show_col(brewer_pal()(3))
show_col(brewer_pal(type = "qual", palette = 2, direction = 1)(3))
@
Once you have found a suitable palette for these data, redo the plot above with the chosen palette.
\end{playground}

When not relying on colors, the most common way of distinguishing groups of observations in scatter plots is to use the \code{shape} of the points as an \emph{aesthetic}. We need to change a single ``word'' in the code statement to achieve this different mapping.

<<scatter-10, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point()
@

We can use \code{scale\_shape\_manual} to choose each shape to be used. We set three ``open'' shapes that we will see later are very useful as they obey both \code{color} and \code{fill} \emph{aesthetics}.\label{chunk:filled:symbols}

<<scatter-11, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point() +
  scale_shape_manual(values = c(21, 22, 23))
@

It is also possible to use characters as shapes. The character is centred on the position of the observation.
<<scatter-12>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, shape = factor(cyl))) +
  geom_point(size = 2.5) +
  scale_shape_manual(values = c("4", "6", "8"), guide = FALSE)
@

\begin{infobox}
  One variable in the data can be mapped to more than one aesthetic allowing redundant aesthetics. This may seem wasteful, but it is extremely useful as it allows one to produce figures that even when produced in color, can still be read if reproduced as monochrome images.

<<scatter-14, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          color = factor(cyl))) +
  geom_point()
@
\end{infobox}

\index{plots!scatter plot|)}
\index{plots!dot plot|(}Dot plots are similar to scatter plots but a factor is mapped to either the \code{x} or \code{y} \emph{aesthetic}. Dot plots are prone to have overlapping observations, and one way of making these points visible is to make them partly transparent by setting a constant value smaller than one for the \code{alpha} \emph{aesthetic}.

<<scatter-12a>>=
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_point(alpha = 1/3)
@

Instead of making the points semitransparent, we can randomly displace them to avoid overlaps. This is called \emph{jitter}, can be added using \code{position\_jitter()} and the amount of jitter set with \code{width} as a fraction of the distance between adjacent factor levels in the plot.
<<scatter-13, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_point(position = position_jitter(width = 0.05))
@

\index{plots!dot plot|)}
\index{plots!bubble plot|(}We can create a ``bubble'' plot by mapping the \code{size} \emph{aesthetic} to a continuous variable. In this case, one has to think what is visually more meaningful. Although the radius of the shape is frequently mapped, due to how human perception works, mapping a variable to the area of the shape is more useful by being perceptually closer to a linear mapping. For this example we add a new variable to the plot. The weight of the car in tons and map it to the area of the points.

<<scatter-16>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size_area() +
  geom_point()
@

\begin{playground}
If we use a radius-based scale the ``impression'' is different.

<<scatter-17,eval=eval_playground>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          color = factor(cyl),
                          size = wt)) +
  scale_size() +
  geom_point()
@

Make the plot, look at it carefully. Check the numerical values of some of the weights, and assess if your perception of the plot matches the numbers behind it.
\end{playground}

\index{plots!bubble plot|)}

As a final example summarising the use of \gggeom{geom\_point()} we combine different \emph{aesthetics}, and \emph{scales} in the same scatter plot.

<<scatter-18>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          shape = factor(cyl),
                          fill = factor(cyl),
                          size = wt)) +
  geom_point(alpha = 0.33, color = "black") +
  scale_size_area() +
  scale_shape_manual(values = c(21, 22, 23))
@

\begin{playground}
Play with the code in the chunk above. Remove or change each of the mappings and the scale, display the new plot and compare it to the one above. Continue playing with the code until you are sure you understand what each individual element in the code statement creates or controls which graphical element in the plot itself.
\end{playground}
\index{plots!point geometry|(}

It is common to draw error bars together with points representing the data and \gggeom{geom\_pointrange()} achieves this based on the values mapped to the \code{x}, \code{y}, \code{ymin} and \code{ymax}, using \code{y} for the position of the point and \code{ymin} and \code{ymax} for the positions of the ends of the line segment representing a range. Two other \emph{geometries}, \gggeom{geom\_range()} and  \gggeom{geom\_errorbar} draw only a segment or a segment with capped ends. They are frequently used together with \emph{statistics} when summaries are calculated on-the-fly, but can also used directly when the data summaries are stored in a data frame passed as argument to \code{data} (Please, see example on page \pageref{exmpl:plot:errorbar:precalc}.)

\subsection{Rug}
\index{plots!rug marging|(}

Rarely rug-plots are used by themselves. Instead they are usually an addition to
scatter plots. An example of the use of \gggeom{geom\_rug()} follows. They make it easier to see the distribution
along the $x$- and $y$-axes.

We generate new fake data by random sampling from the normal distribution. We use \code{set.seed(1234)} to initialize the pseudo-random number generator so that
the same data are generated each time the code is run.

<<rug-plot-01>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, color = factor(cyl))) +
  geom_point() +
  geom_rug()
@
\index{plots!rug marging|)}

\subsection{Line and area}\label{sec:plot:line}

\index{plots!line geometry|(}
For line plots we use \gggeom{geom\_line()}. The \code{size} of a line is its thickness, and as we had \code{shape} for points, we have \code{linetype} for lines. In a line plot observations in successive rows of the data frame, or the subset corresponding to a group, are joined by straight lines. We use a different data set included in R, Orange, with data on the growth of five orange trees. See the help page for \code{Orange} for details.

<<line-plot-01>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line()
@

<<line-plot-02, eval=eval_plots_all>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, linetype = Tree)) +
  geom_line()
@

Instead of drawing a line joining the successive observations, we may want to draw a disconnected straight-line segment for each observation or row in the data. In this case we use \gggeom{geom\_segment()} which accepts \code{x}, \code{xend}, \code{y} and \code{yend} as mapped aesthetics. \gggeom{geom\_curve()} draws curved lines, and the curvature, control points, and angles can be controlled through additional \emph{aesthetics}. These two \emph{geometries} support arrow heads at their ends. Other \emph{geometries} useful for drawing lines or segments are \gggeom{geom\_path()}, which is similar to \gggeom{geom\_line()} but instead of joining observations according to \code{x} it joins them according to their order in the data, and \gggeom{geom\_spoke()} which is similar to \gggeom{geom\_segment()} but using a polar parametrization, based on \code{x}, \code{y} for origin, and \code{angle} and \code{radius} for the segment. The various other aesthetics that be used with \gggeom{geom\_line()} can be used with \gggeom{geom\_segment()} and \gggeom{geom\_curve()} as well. Finally, \gggeom{geom\_step()} used only vertical and horizontal lines to join the observations, creating a stepped line.

<<step-plot-01>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, linetype = Tree)) +
  geom_step()
@

While \gggeom{geom\_line()} draws a line joining observations, \gggeom{geom\_area()} supports filling the area bellow the drawn line drawn based on the \code{x} and \code{y}, respecting the \code{fill} \emph{aesthetic}. In contrast \gggeom{geom\_ribbon} draws two lines based on the \code{x}, \code{ymin} and \code{ymax} \emph{aesthetics}, with the space between the lines filled according to the \code{fill} \emph{aesthetic}. Finally, \gggeom{geom\_polygom} is similar to \gggeom{geom\_path()} but connects the extreme observations draw a closed polygon that supports \code{fill}.

Much of what was described above for \gggeom{geom\_point} can be adapted to line, ribbon, area and other geoms described in this section. In some cases, in may be useful to stack the different areas. In the next, contrived, example, we stack the growth of the different trees by using \code{position = "stacked"} instead of the default \code{position = "identity"}

<<area-plot-01l>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, fill = Tree)) +
  geom_area(position = "stack")
@

Finally three \emph{geometries} for drawing lines across the whole plotting area: \gggeom{geom\_hline}, \gggeom{geom\_vline} and \gggeom{geom\_abline}. The first two of the geometries draw horizontal and vertical lines, respectively, while the third one draws straight lines according to the \emph{aesthetics} \code{slope} and \code{intercept} determining the position.

\index{plots!line plot|)}

\subsection{Column}\label{sec:plot:col}
\index{plots!column plot|(}

\Rlang users not familiar yet with \ggplot are frequently surprised by the default behaviour of \gggeom{geom\_bar()} as it uses \ggstat{stat\_count()} to compute the value plotted, rather than plotting values as is (see section \ref{sec:plot:summaries} on page \pageref{sec:plot:summaries}). The default can be changed, but \gggeom{geom\_col()} is equivalent to \gggeom{geom\_bar()} used with \code{"identity"} as argument to parameter \code{stat}. The \emph{statistic} \ggstat{stat\_identity()} just echoes its input. In previous sections, as when plotting points and lines, this statistic was used by default. Starting from \ggplot ver. 2.2.1, a new \emph{geometry} is available, \gggeom{geom\_col()} which is the same as \gggeom{geom\_bar()} but with \ggstat{stat\_identity()} as default.

To create a figure in which the columns represent each a single value in \code{data} we will use \gggeom{geom\_col()}, after creating some artificial data. We will reuse the same data in variations of the figure.

<<col-plot-01>>=
set.seed(654321)
my.col.data <- data.frame(treatment = factor(rep(c("A", "B", "C"), 2)),
                          group = factor(rep(c("male", "female"), c(3, 3))),
                          measurement = rnorm(6) + c(5.5, 5, 7))
@

First we plot data for females only, using defaults for all \emph{aesthetics}.

<<col-plot-02>>=
ggplot(subset(my.col.data, group == "female"),
       aes(x = treatment, y = measurement)) +
   geom_col()
@

We play with \emph{aesthetics} to produce a plot with a semi-formal style---e.g.\ suitable for a science popularization article or book. See section \ref{sec:plot:scales} and section \ref{sec:plot:themes} for information on scales and themes, respectively. We set \code{width = 0.5} to make the bars narrower. Setting \code{color = "white"} overrides the default color of the lines bordering the bars.

<<col-plot-03>>=
ggplot(my.col.data, aes(x = treatment, y = measurement, fill = group)) +
     geom_col(color = "white", width = 0.5) +
     scale_fill_grey() + theme_dark()
@

We next use a formal style, and in addition put the bars side by side by setting \code{position = "dodge"} to override the default \code{position = "stack"}. Setting \code{color = NA} removes the lines bordering the bars.

<<col-plot-04>>=
ggplot(my.col.data, aes(x = treatment, y = measurement, fill = group)) +
     geom_col(color = NA, position = "dodge") +
     scale_fill_grey() + theme_classic()
@

\begin{playground}
Change the argument to \code{position}, or let the default be active, until you understand its effect on the figure.
\end{playground}

\begin{playground}
Use constants as arguments for \emph{aesthetics} or map variable \code{treatment} to one or more of the \emph{aesthetics} used by \gggeom{geom\_col()}, such as \code{colour}, \code{fill}, \code{linetype}, \code{size}, \code{alpha} and \code{width}.
\end{playground}

\begin{warningbox}
If you are using version 2.1.0 or earlier of \ggplot, you will need to create the plots using \gggeom{geom\_bar()} instead of \gggeom{geom\_col()}. The code for the first figure in this section would need to be edited as below---this code also gives the desired plot with later versions of \ggplot.

<<col-plot-warn-01, eval=eval_plots_all>>=
ggplot(subset(my.col.data, group == "female"),
       aes(x = treatment, y = measurement)) +
   geom_bar(stat = "identity")
@

All other examples making use of \gggeom{geom\_col()}  need to be similarly modified for versions of \ggplot lacking \gggeom{geom\_col()}.
\end{warningbox}

\index{plots!column plot|)}

\subsection{Tiles}\label{sec:tileplot}
\index{plots!tile plot|(}
We can draw square or rectangular tiles with \gggeom{geom\_tile()} producing tile plots or simple heat maps.
For the special case of heat maps with marginal cluster tress see section \ref{sec:plot:heatmap} on page \pageref{sec:plot:heatmap}.

We here generate 100 random draws from the $F$ distribution with degrees of freedom $\nu_1 = 5, \nu_2 = 20$.

<<tile-plot-01>>=
set.seed(1234)
randomf.df <- data.frame(z = rf(100, df1 = 5, df2 = 20),
                         x = rep(letters[1:10], 10),
                         y = LETTERS[rep(1:10, rep(10, 10))])
@

<<tile-plot-02>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile()
@

We can set \code{color = "grey50"} and \code{size = 1} to make the tile borders more visible as in the example below, or use a contrasting color, to better delineate the borders of the tiles. What to use will depend on whether the individual tiles add meaningful information. In cases like when rows of tiles correspond to individual genes and columns to discrete treatments, contrasting tile borders are preferable. In contrast, in the case when the tiles are an approximation to a continuous surface such as measurements on a regular spatial grid, it is best to suppress the tile borders.

<<tile-plot-03>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "grey50", size = 1.33)
@

\begin{playground}
Play with the arguments passed to parameters \code{color} and \code{size} in the example above, considering what features of the data are most clearly perceived in each of the plots you create.
\end{playground}

Any continuous fill scale can be used to control the appearance. Here we show a tile plot using a grey gradient.

<<tile-plot-04, eval=eval_plots_all>>=
ggplot(randomf.df, aes(x, y, fill = z)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "grey15", high = "grey85", na.value = "red")
@

In contrast to \gggeom{geom\_tile()} that draws tiles based on the position of the centre and the \code{height} and \code{width} of the tiles, \gggeom{geom\_rect()} draws rectangular tiles based on the position of the corners, \code{xmin}, \code{xmax}, \code{ymin} and \code{ymax}.

\index{plots!tile plot|)}

\subsection{Shape file}

\ggplot version 3.0.0 or later support the plotting of shape data similarly as in geographic information systems (GIS) through \gggeom{geom\_sf()}. This allows displaying data on maps and for example using different fill values for different regions.

\subsection{Text}\label{sec:plot:text}
\index{plots!text in|(}
\index{plots!maths in|(}
We can use \gggeom{geom\_text()} or \gggeom{geom\_label()} to add text labels to observations. For \gggeom{geom\_text()} and \gggeom{geom\_label()}, the aesthetic \code{label} provides the text to be plotted and the usual aesthetics \code{x} and \code{y} the location of the labels. As one would expect the \code{color} and \code{size} aesthetics can be also used for the text. In addition \code{angle} and \code{vjust} and \code{hjust} can be used to rotate the label, and adjust its position. The default value of 0.5 for both \code{hjust} and \code{vjust} centres the label positioning the centre of the text at the supplied \code{x} and \code{y} coordinates. `Vertical' and `horizontal' for justification refer to the text, not the plot. This is important when \code{angle} is different from zero. Values smaller than 0.5 shift the label left or down, and values larger than 0.5, right or up. A value of 1 or 0 sets the text so that its edge is at the supplied coordinate. Values outside the range $0\ldots 1$ shift the text even further away, however, still using units based on the length or height of the text string. In the case of \gggeom{geom\_label()} the text is enclosed in a box, which obeys the \code{fill} \emph{aesthetic} and takes additional parameters (described starting at page \pageref{start:plot:label}) allowing control on the shape and size of the box. However, it does not support rotation with \code{angle}.

<<text-plot-01>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          colour = factor(cyl),
                          size = wt,
                          label = cyl)) +
  scale_size() +
  geom_point() +
  geom_text(colour = "black", size = 3)
@

In the remaining examples, with output not shown, we use \gggeom{geom\_text} or \gggeom{geom\_label} together with \gggeom{geom\_point} as they are most frequently used together with this \emph{geometry}.

<<text-plot-02, eval=eval_plots_all>>=
my.data <-
  data.frame(x = 1:5,
             y = rep(2, 5),
             label = c("a", "b", "c", "d", "e"))

ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust = 1.5, size = 8) +
  geom_point()
@

\begin{playground}
Modify the examples above to use \gggeom{geom\_label()} instead of \gggeom{geom\_text()} using in addition the \code{fill} aesthetic.
\end{playground}

In the next example we select a different font family, using the same characters in the Roman alphabet.
We start by checking which fonts families \Rlang recognizes on our system for the PDF output device we use to render the figures in this book.

<<text-plot-03>>=
names(pdfFonts())
@

A sans-serif font, either \code{"Helvetica"} or \code{"Arial"} is the default, but we can change the default through parameter \code{family}. Some of the family names are \emph{generic} like \code{serif}, \code{sans} (sans-serif) and \code{mono} (mono-spaced), and others refer to actual font names. Some related fonts (e.g.\ from different designers or foundries) may also use variations of the same name. Base R does not support the use of system fonts in graphics output devices. However, add-on packages allow their use. The simplest to use is package \pkgname{showtext} described in \ref{sec:plot:fonts} on page \pageref{sec:plot:fonts}.

<<text-plot-04, eval=eval_plots_all>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_text(angle = 45, hjust = 1.5, size = 8, family = "serif") +
  geom_point()
@

\begin{playground}
In the examples above the character strings were all on the same length, containing a single character. Redo the plots above with longer character strings of various lengths mapped to the \code{label} \emph{aesthetic}. Do also play with justification of these labels.
\end{playground}

Plotting expressions (mathematical expressions) involves mapping to the \code{label} aesthetic character strings that can be parsed as expressions, and setting \code{parse = TRUE}. We here build the character strings using \Rfunction{paste()} but, of course, they could have also been entered one by one.

<<text-plot-05>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = paste("alpha[", 1:5, "]", sep = ""))
my.data$label
@

<<text-plot-06>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

Plotting maths and other alphabets using \Rlang expressions is discussed in section \ref{sec:plot:plotmath} on page \pageref{sec:plot:plotmath}.

In the examples above we plotted text and expressions present in the data frame passed as argument for \code{data}. It is also possible to build suitable labels on-the-fly within \code{aes} when setting the mapping for \code{label}. Here we use \gggeom{geom\_text()} and expressions for the example, but the same two approaches can be use to ``build'' character strings to be used directly without parsing.

<<text-plot-07, eval=eval_plots_all>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5))

ggplot(my.data, aes(x,
                    y,
                    label = paste("alpha[", x, "]", sep = ""))) +
  geom_text(hjust = -0.2, parse = TRUE, size = 6) +
  geom_point()
@

\begin{playground}
What are the advantages and disadvantages of each approach in relation to easy with which a script in which several figures using the same ``labels'' are produced, in relation to consistency across figures? In contrast, which approach would you prefer if different figures in the same script used different variations of labels constructed from the same variables in the data?
\end{playground}

As \gggeom{geom\_label()} obeys the same parameters as \gggeom{geom\_text()} except for \code{angle} we describe below only the additional parameters compared to \gggeom{geom\_text()}.\label{start:plot:label}

<<label-plot-01>>=
my.data <-
  data.frame(x = 1:5, y = rep(2, 5),
             label = letters[1:5])
ggplot(my.data, aes(x, y, label = label)) +
  geom_label(hjust = -0.2) +
  geom_point()
@

We may want to alter the default width of the border line or the color used to \code{fill} the rectangle, or to change the ``roundness'' of the corners. To suppress the border line use \code{label.size = 0}. Corner roundness is controlled by parameter \code{label.r} and the size of the margin around the text with \code{label.padding}.

<<label-plot-02, eval=eval_plots_all>>=
ggplot(my.data, aes(x, y, label = label)) +
  geom_label(hjust = -0.2, parse = TRUE, size = 6,
             label.size = 0L,
             label.r = unit(0, "lines"),
             label.padding = unit(0.15, "lines"),
             fill = "yellow", alpha = 0.5) +
  geom_point()
@

\begin{playground}
Play with the arguments to the different parameters and with the \emph{aesthetics} to get an idea of what can be done with them. For example, use thicker border lines and increase the padding so that a visually well balanced margin is retained. You may also try mapping the \code{fill} and \code{color} \emph{aesthetics} to factors in the data.
\end{playground}

Repulsive versions of \gggeom{geom\_text} and \gggeom{geom\_label}, \gggeom{geom\_text\_repel} and \gggeom{geom\_label\_repel},  are available in package \pkgname{ggrepel}. These \emph{geometries} avoid overlaps by automatically repositioning the text or labels. Please, read the package documentation for details of how to control the repulsion strength and direction, and the properties of the segments linking the labels to the position of their data coordinates.

<<repel-plot-01>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          colour = factor(cyl),
                          size = wt,
                          label = cyl)) +
  scale_size() +
  geom_point(alpha = 1/3) +
  geom_text_repel(colour = "black", size = 3,
                  min.segment.length = 0.1, point.padding = 0.2)
@

The plotting of tables by mapping a list of data frames to the \code{label} \emph{aesthetic} is possible with \gggeom{geom\_table} from package \pkgname{ggpmisc}. Positioning, justification and angle work as for \gggeom{geom\_text} and are applied to the whole table. Only \code{tibble} objects from \pkgname{tibble} can contain as variables lists of data frames, so this \emph{geometry} requires the use of \code{tibble} objects for data. The table is created as a 'grid' \code{grob} and added as usual to the \code{ggplot} object.

We first generate a \code{tibble} of summaries from the data and embed it in a \code{tibble}. We use the functions from the tidyverse described in Chapter \ref{chap:R:data}.

<<table-plot-01>>=
mtcars %>%
  group_by(cyl) %>%
  summarize("mean wt" = format(mean(wt), digits = 2),
            "mean disp" = format(mean(disp), digits = 0),
            "mean mpg" = format(mean(mpg), digits = 0)) -> my.table
table.tb <- tibble(x = 500, y = 35, tab = list(my.table))
@

<<table-plot-02>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          colour = factor(cyl),
                          size = wt,
                          label = cyl)) +
  scale_size() +
  geom_point() +
  geom_text(colour = "black", size = 3) +
  geom_table(data = table.tb,
             aes(x = x, y = y, label = tab),
             colour = "black", size = 3, hjust = 1, vjust = 1)
@

The \code{color} and \code{size} aesthetics control the text within each table as a whole.
It is also possible to rotate the table using \code{angle}. As with text labels, justification is interpreted in relation to table-text orientation. We set the \code{x = 0} in \code{data.tb} and then use \code{vjust = 1} to position the top of the
table at this coordinate value.

<<table-plot-03, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg,
                          colour = factor(cyl),
                          size = wt,
                          label = cyl)) +
  scale_size() +
  geom_point() +
  geom_text(colour = "black", size = 3) +
  geom_table(data = table.tb,
             aes(x = x, y = y, label = tab),
             colour = "black", size = 3,
             hjust = 1, vjust = 0, angle = 90)
@

Parsed text, using plotmath syntax is supported in the table, with fallback to plain text in case of parsing errors, on a cell by cell basis.
We end this section with a simple example, which even if not very useful demonstrates that \gggeom{geom\_table()} behaves like a ``normal'' ggplot geometry and that a table can be the only
data layer in a ggplot if desired. The addition of multiple tables with a single call to \gggeom{geom\_table()} by passing a \code{tibble} with multiple rows as argument is also possible.

<<table-plot-04, eval=eval_plots_all>>=
tb.pm <- tibble('x^0' = 1,
                'x^1' = 1:5,
                'x^2' = (1:5)^2,
                'x^3' = (1:5)^3)
data.tb <- tibble(x = 1, y = 1, tb = list(tb.pm))
ggplot(data.tb, aes(x, y, label = tb)) +
  geom_table(size = 7, parse = TRUE) +
  theme_void()
@

\begin{explainbox}
  This \emph{geometry} uses internally functions from package \pkgname{gridExtra} to build a graphical object for the table. The use of table themes was not yet supported by this geometry at the time of writing.
\end{explainbox}

\begin{warningbox}
You\index{plots!fonts} should be aware that \Rlang and \ggplot support the use of UNICODE\index{UNICODE}, such as UTF8\index{UTF8} character encodings in strings. If your editor or IDE supports their use, then you can type Greek letters and simple maths symbols directly, and they may show correctly in labels if a suitable font is loaded and an extended encoding like UTF8 in use by the operating system. Even if UTF8 is in use, text is not fully portable unless the same font is available\index{portability}, as even if the character positions are standardized for many languages, most UNICODE fonts support at most a small number of languages. In principle one can use this mechanism to have labels both using other alphabets and languages like Chinese with their numerous symbols mixed in the same figure. Furthermore, the support for fonts and consequently character sets in \Rlang is output-device dependent. The font encoding used by \Rlang by default depends on the default locale settings of the operating system, which can also lead to garbage printed to the console or wrong characters being plotted running the same code on a different computer from the one where a script was edited. Not all is lost, though, as \Rlang can be coerced to use system fonts and Google fonts with functions provided by packages \pkgname{showtext} and \pkgname{extrafont}. Encoding-related problems, specially in MS-Windows, are common.
\end{warningbox}

\index{plots!text in|)}
\index{plots!maths in|)}

\index{plots!geometries|)}

\section{Statistics}\label{sec:plot:statistics}
\index{plots!statistics|(}

Before learning about \ggplot \emph{statistics} it is important to understand how the mapping of factors to \emph{aesthetic} works. When a factor, for example is mapped, for example, to \code{colour} it creates a new grouping, with the observations matching a given level of the factor, corresponding to a group. Most \emph{statistics} operate on the data for each of these groups separately, returning a summary for each group, for example, the mean of the observations in a group.

\subsection{Functions}\label{sec:plot:function}
\index{plots!plotting functions|(}
\index{plots!statistics!function}
In addition to plotting data from a data frame with variables to map to $x$ and $y$ \emph{aesthetics}, it is possible to have only a variable mapped to $x$ and use \ggstat{stat\_function()} to compute the values to be mapped to $y$ using an \Rlang function. This avoids the need to generate data beforehand as even the number of data points to be generated can be also set when adding \code{geom\_function}. Any \Rlang function, user defined or not, can be used as long as it is vectorised, with the length of the returned vector equal to the length of the vector used as \code{x} argument.

We start with the Normal distribution function.

<<function-plot-01>>=
ggplot(data.frame(x = -3:3), aes(x = x)) +
  stat_function(fun = dnorm)
@

Using a list we can even pass by name additional arguments to a function.

<<function-plot-02, eval=eval_plots_all>>=
ggplot(data.frame(x = -3:3), aes(x = x)) +
  stat_function(fun = dnorm, args = list(mean = 1, sd = .5))
@

\begin{playground}
1) Edit the code above so as to plot in the same figure three curves, either for three different values for \code{mean} or for three different values for \code{sd}.

2) Edit the code above to use a different function, say \code{df}, the F distribution, adjusting the argument(s) passed through \code{args} accordingly.
\end{playground}

Of course, user-defined functions (not shown), and anonymous functions (below) can also be used.

<<function-plot-03, eval=eval_plots_all>>=
ggplot(data.frame(x = 0:1), aes(x = x)) +
  stat_function(fun = function(x, a, b){a + b * x^2},
                args = list(a = 1, b = 1.4))
@

\begin{playground}
Edit the code above to use a different function, such as $e^{x + k}$, adjusting the argument(s) passed through \code{args} accordingly. Do this by means of an anonymous function, and by means of an equivalent named function defined by your code.
\end{playground}

\index{plots!plotting functions|)}

\subsection{Summaries}\label{sec:plot:stat:summaries}
\index{plots!statistics|(}
\index{plots!statistics!summary}
The summaries discussed in this section can be superimposed on raw data plots, or plotted on their own. Beware, that if scale limits are manually set, the summaries will be calculated from the subset of observations within these limits. Scale limits can be altered when explicitly defining a scale or by means of functions \Rfunction{xlim()} and \Rfunction{ylim}. See the text box on \pageref{box:plot:coord:lims} for a way of constraining the viewport (the region visible in the plot) by changing coordinate limits while keeping the scale limits on a wider range of $x$ and $y$ values.

It is possible to summarize data on-the-fly when plotting. We describe in the same section the calculation of measures of central position and of variation, as \ggstat{stat\_summary()} allows them to be calculated in the same function call.

For the examples we will generate some normally distributed artificial data.

<<summary-plot-01>>=
fake.data <- data.frame(
  y = c(rnorm(10, mean = 2, sd = 0.5),
        rnorm(10, mean = 4, sd = 0.7)),
  group = factor(c(rep("A", 10), rep("B", 10)))
  )
@

We first use scatter plots for the examples, later we give some additional examples for bar plots.
We will reuse a ``base'' plot in a series of examples, so that the differences are easier to appreciate. We first add just the mean. In this case we need to pass as argument to \ggstat{stat\_summary()} the \code{geom} to use, as the default one, \gggeom{geom\_pointrange()}, expects data for plotting error bars in addition to the mean.

<<summary-plot-02>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "mean", geom = "point", color = "red", shape = "-", size = 10)
@

Then the median, by changing the argument passed to \code{fun.y}. For the next few examples we show only the call to \code{stat\_summary()}.

<<summary-plot-03, eval=eval_plots_all, echo=3>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.y = "median", geom = "point", colour = "red", shape = "-", size = 10)
@

We can add the mean and $p = 0.95$ confidence intervals assuming normality (using the $t$ distribution):

<<summary-plot-04, eval=eval_plots_all, echo=3>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_normal", colour = "red", size = 1, alpha = 0.7)
@

We can add the means and $p = 0.95$ confidence intervals not assuming normality (using the actual distribution of the data by bootstrapping):

<<summary-plot-05, eval=eval_plots_all, echo=3>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot", colour = "red", size = 1, alpha = 0.7)
@

If needed, we can display less restrictive confidence intervals, at $p = 0.90$ in this example, by means of \code{conf.int = 0.90} passed as a list to the underlying function being called.

<<summary-plot-06, eval=eval_plots_all, echo = 3:5>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_cl_boot",
               fun.args = list(conf.int = 0.90),
               colour = "red", size = 1, alpha = 0.7)
@

We can plot error bars corresponding to $\pm$s.e. (standard errors) with the function \Rfunction{"mean\_se"}.

<<summary-plot-07, eval=eval_plots_all, echo = 3:4>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_se",
               colour = "red", size = 1, alpha = 0.7)
@

\begin{warningbox}\label{box:plot:coord:lims}
\textbf{Scale- and coordinate limits are very different.}\index{limits!coordinate}\index{limits!scale} Scale limits restrict the data used, while coordinate limits restrict the data that are visible. For a scatter plot, the effect of either approach on the resulting plot are equivalent, as no calculations are involved, but when using \emph{statistics} to compute summaries, one should almost always rely on coordinate limits, to make sure that no data are excluded from the calculated summary. See section \ref{sec:plot:coord:limits} for details.
\end{warningbox}

Finally we can plot error bars showing $\pm$s.d. (standard deviation).

<<summary-plot-08, eval=eval_plots_all, echo = 3>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  geom_point(shape = 21) +
  stat_summary(fun.data = "mean_sdl", colour = "red", size = 1, alpha = 0.7)
@

We do not give an example here, but instead of using these functions (from package \Hmisc) it is possible to use user-defined functions. In addition as arguments to any function used, except for the first one containing the actual data, are supplied as a list through formal argument \code{fun.args}, there is a lot of flexibility with respect to what functions can be used.

Finally we plot the means in a scatter plot, with the observations superimposed and $p = 0.95$ confidence interval (the order in which the geoms are added is important: by having \gggeom{geom\_point()} last it is plotted on top of the bars. In this case we set fill, colour and alpha (transparency) to constants, but in more complex data sets mapping them to factors in the data set can be used to distinguish them. Adding \ggstat{stat\_summary()} twice allows us to plot the mean and the error bars using different colors.

<<summary-plot-09>>=
ggplot(data = fake.data, aes(y = y, x = group)) +
  stat_summary(fun.y = "mean", geom = "point",
               fill = "white", colour = "black") +
  stat_summary(fun.data = "mean_cl_boot",
               geom = "errorbar",
               width = 0.1, size = 1, colour = "red") +
  geom_point(size = 3, alpha = 0.3)
@

Similarly as with scatter plots, we can plot summaries as columns.
If we supply a different argument to \code{stat} we can for example plot the means or medians for a variable, for each \code{class} of car.

<<summary-plot-09a, eval=eval_plots_all>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

The ``reverse'' syntax is also valid, as we can add the \emph{statistics} to the plot object and pass the \emph{geometry} as an argument to it. In general in this book we avoid this alternative syntax for consistency.

<<summary-plot-10, eval=eval_plots_all>>=
ggplot(mpg, aes(class, hwy)) +
  geom_bar(stat = "summary", fun.y = mean)
@

And we can easily add error bars to the column plot. We use \code{size} to make the lines of the error bars thicker, and a value smaller than zero for \code{fatten} to make the point smaller. The default \emph{geometry} in \ggstat{stat\_summary()} is \gggeom{geom\_pointrange()}.

<<summary-plot-11>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(fun.data = "mean_se", size = 1,
               fatten = 0.5, color = "red")
@

Instead of making the point smaller, we can pass \code{"linerange"} as argument for \code{geom} to eliminate the point completely by use of \gggeom{geom\_linerange()}.

<<summary-plot-12, eval=eval_plots_all, echo=3:5>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "linerange",
               fun.data = "mean_se", size = 1,
               color = "red")
@

Passing \code{"errorbar"} to \code{geom} results in the use of \gggeom{geom\_errorbar()} resulting in traditional ``capped'' error bars. However, this type of error bars has been criticized as adding unnecessary clutter to plots \autocite{Tufte1983}. We use \code{width} to reduce the width of the cross lines at the ends of the bars.

<<summary-plot-13, eval=eval_plots_all, echo = 3:5>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean) +
  stat_summary(geom = "errorbar",
               fun.data = "mean_se", width = 0.1, size = 1,
               color = "red")
@

If we have ready calculated values for the summaries, we can still obtain the same plots. Here we calculate the summaries before plotting, and then redraw the plot immediately above.\label{exmpl:plot:errorbar:precalc}

<<summary-plot-14, eval=eval_plots_all>>=
mpg_g <- dplyr::group_by(mpg, class)
mpg_summ <- dplyr::summarise(mpg_g, hwy_mean = mean(hwy),
                                    hwy_se = sd(hwy) / sqrt(n()))

ggplot(mpg_summ, aes(x = class,
                     y = hwy_mean,
                     ymax = hwy_mean + hwy_se,
                     ymin = hwy_mean - hwy_se)) +
  geom_col() +
  geom_errorbar(width = 0.1, size = 1, color = "red")
@

\subsection{Smoothers and models}
\index{plots!smooth curves|(}
\index{plots!fitted curves|(}
\index{plots!statistics!smooth}
The \emph{statistic} \ggstat{stat\_smooth()} fits a smooth curve to observations in the case when the scales for $x$ and $y$ are continuous---the corresponding \emph{geometry} \gggeom{geom\_smooth()} uses this \emph{statistic}, and differs only in how arguments are passed to formal parameters. For the first example, we use \ggstat{stat\_smooth()} with the default smoother, a spline. The type of spline is automatically chosen based on the number of observations.

<<smooth-plot-01, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
       stat_smooth()
@

In most cases we will want to plot the observations as points together with the smoother. We can plot the observation on top of the smoother, as done here, or the smoother on top of the observations.

<<smooth-plot-02>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
  stat_smooth() +
  geom_point()
@

Instead of using the default spline, we can fit a different model. In this example we use a linear model as smoother, fitted by \Rfunction{lm()}.

<<smooth-plot-03, eval=eval_plots_all, echo = 2>>=
ggplot(data = mtcars, aes(x = disp, y = mpg)) +
  stat_smooth(method="lm") +
  geom_point()
@

These data are really grouped, so we map variable \code{cyl} to the \code{colour} \emph{aesthetic}. Now we get three groups of points with different colours but also three separate smooth lines.

<<smooth-plot-04>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, color = factor(cyl))) +
  stat_smooth(method = "lm") +
  geom_point()
@

To obtain a single smoother for the three groups, we need to set the mapping of the \code{color} \emph{aesthetic} to a constant within \ggstat{stat\_smooth}. This local value overrides the default for the whole plot set with \code{aes} just for this single \emph{statistic}. We use \code{"black"} but this could be replaced by any other color definition known to \Rlang.

<<smooth-plot-05, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, color = factor(cyl))) +
  stat_smooth(method = "lm", colour = "black") +
  geom_point()
@

Instead of using the default \code{formula} for a linear regression as smoother, we pass a different \code{formula} as argument. In this example we use a polynomial of order 2 fitted by \Rfunction{lm()}.

<<smooth-plot-06>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, color = factor(cyl))) +
  stat_smooth(method = "lm", formula = y ~ poly(x, 2), colour = "black") +
  geom_point()
@

It is possible to use other types of models, including GAM and GLM, as smoothers, but we will give only two simple examples of the use of \code{nls()} to fit a model non-linear in its parameters. In the first one we fit a Michaelis-Menten equation to reaction rate (\code{rate}) versus reactant concentration (\code{conc}). \code{Puromycin} is a data set included in the \Rlang distribution. Function \Rfunction{SSmicmen()}
is also from \Rlang, and is a \emph{self starting} implementation of Michaelis-Menten function. Thanks to this, even though the fit is done with an iterative algorithm, we do not need to explicitly provide starting values for them. We need to set \code{se = FALSE} because
standard errors are not supported by the \code{predict()} method for \code{nls} fitted models.

<<smooth-plot-07, eval=eval_plots_all>>=
ggplot(Puromycin, aes(conc, rate, colour = state)) +
  geom_point() +
  geom_smooth(method = "nls",
              formula =  y ~ SSmicmen(x, Vm, K),
              se = FALSE)
@

The self-starting models available in R are \code{SSasymp}, \code{SSasympOff}, \code{SSasympOrig}, \code{SSbiexp}, \code{SSfol}, \code{SSfpl}, \code{SSgompertz}, \code{SSlogis}, \code{SSmicmen}, and \code{SSweibull}. Function \code{selfStart} can be used to define new ones. All these functions can be used when fitting models with \Rfunction{nls} or \Rfunction{nlme}. Please, check the respective help pages for details.

In the second example we define the same model directly in the model formula, and provide the starting values explicitly. The names used for the parameters to be fitted can be chosen at will, within the restrictions of the \Rlang language, but of course the names used in \code{formula} and \code{start} must match each other.

<<smooth-plot-08, eval=eval_plots_all>>=
ggplot(Puromycin, aes(conc, rate, colour = state)) +
  geom_point() +
  geom_smooth(method = "nls",
              method.args = list(formula =  y ~ (Vmax * x) / (k + x),
                                 start = list(Vmax = 200, k = 0.05)),
              se = FALSE)
@

\begin{warningbox}
The different geoms and elements can be added in almost any order to a ggplot object, but they will be plotted in the order that they are added. The \code{alpha} (transparency) aesthetic can be mapped to a constant to make underlying layers visible, or \code{alpha} can be mapped to a data variable for example making the transparency of points in a plot depend on the number of observations used in its calculation.

<<smooth-plot-11, eval=eval_plots_all>>=
ggplot(data = mtcars, aes(x = disp, y = mpg, colour = factor(cyl))) +
  geom_smooth(colour = "black", alpha = 0.7) +
  geom_point() +
  theme_bw()
@
\end{warningbox}

In some cases it is desirable to annotate plots with fitted model equations or fitted parameters. One way of achieving this is by fitting the model and then extracting the parameters to manually construct text strings to use for text or label annotations. However, package \pkgname{ggpmisc} makes it possible to automate such annotations.

<<smooth-plot-12>>=
my.formula <- y ~ poly(x, 2)
ggplot(data = mtcars, aes(x = disp, y = mpg, color = factor(cyl))) +
  stat_smooth(method = "lm", formula = my.formula, colour = "black") +
  stat_poly_eq(formula = my.formula, aes(label = ..eq.label..),
               colour = "black", parse = TRUE, label.x.npc = 0.3) +
  geom_point()
@

This same package makes it possible to annotate plots with summary tables from a model fit.
<<smooth-plot-13>>=
my.formula <- y ~ poly(x, 2)
ggplot(data = mtcars, aes(x = disp, y = mpg, color = factor(cyl))) +
  stat_smooth(method = "lm", formula = my.formula, colour = "black") +
  stat_fit_tb(method = "lm",
              method.args = list(formula = my.formula),
              colour = "black",
              tb.vars = c(Parameter = "term",
                          Estimate = "estimate",
                          "s.e." = "std.error",
                          "italic(t)" = "statistic",
                          "italic(P)" = "p.value"),
              label.y.npc = "top", label.x.npc = "right",
              parse = TRUE) +
  geom_point()
@

Package \pkgname{ggpmisc} provides additional \emph{statistics} for the annotation of plots based on fitted models. Please see the package documentation for details.

\index{plots!smooth curves|)}
\index{plots!fitted curves|)}

\subsection{Frequencies and counts}\label{sec:histogram}
\index{plots!histograms|(}
\index{density plots|(}

A different type of summaries are frequencies and empirical density functions. These can be calculated in one or more dimensions. Sometimes instead of being calculated, we rely on the density of graphical elements to convey the density. For example, scatter plots using well chosen values for \code{alpha} can give a satisfactory impression of the density. Rug plots, described below work in a similar way. See sections ....

Histograms are defined by how the plotted values are calculated. Although they are most frequently plotted as bar plots, many bar plots are not histograms. Although rarely done in practice, a histogram could be plotted using a different \emph{geometry} and \code{stat\_bin} the \emph{statistic} used by default by \gggeom{geom\_histogram()}. This \emph{statistic} does binning of observations before computing frequencies, and is suitable for continuous $x$ scales. When a factor is mapped to \code{x}, \code{stat\_count} should be used, which is the default \code{stat} for \gggeom{geom\_bar()}. These two \emph{geometries} are described in this section about statistics, because they default to using statistics different from \code{stat\_identity()} and consequently summarize the data.

<<histogram-plot-00>>=
set.seed(12345)
my.data <-
data.frame(x = rnorm(200),
y = c(rnorm(100, -1, 1), rnorm(100, 1, 1)),
group = factor(rep(c("A", "B"), c(100, 100))) )
@

<<histogram-plot-01>>=
ggplot(my.data, aes(x)) +
  geom_histogram(bins = 15)
@

<<histogram-plot-02, eval=eval_plots_all>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "dodge")
@

<<histogram-plot-03, eval=eval_plots_all>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "stack")
@

<<histogram-plot-04, eval=eval_plots_all>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_histogram(bins = 15, position = "identity", alpha = 0.5)
@

The \emph{geometry} \gggeom{geom\_bin2d()} by default uses the \emph{statistic} \code{stat\_bin2d} which can be thought as a frequency histogram in two dimensions. The frequency for each rectangular tile is mapped onto a \code{fill} scale.

<<bin2d-plot-01>>=
ggplot(my.data, aes(x, y)) +
  geom_bin2d(bins = 8)
@

The \emph{geometry} \gggeom{geom\_hex()} is the equivalent of \gggeom{geom\_bin2d()} using hexagonal tiles instead of square tiles. By default uses the \emph{statistic} \ggstat{stat\_binhex()}. The frequency for each hexagon is mapped onto a \code{fill} scale.

<<hex-plot-01>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 8)
@
\index{plots!histograms|)}

\subsection{Density functions}\label{sec:plot:density}
\index{plots!density plot!1 dimension|(}
\index{plots!statistics!density}
Empirical density functions are the equivalent of a histogram, but are continuous and not calculated using bins. They can be calculated in 1 or 2 dimensions (2d), for $x$ or $x$ and $y$ respectively. As with histograms it is possible to use different \emph{geometries} to visualize them. Examples of the use of \gggeom{geom\_density()} to create 1D density plots follow.

<<density-plot-01>>=
ggplot(my.data, aes(y, colour = group)) +
  geom_density()
@

A semitransparent fill can be used instead of coloured lines.

<<density-plot-02, eval=eval_plots_all>>=
ggplot(my.data, aes(y, fill = group)) +
  geom_density(alpha = 0.5)
@
\index{plots!density plot!1 dimension|)}

\index{plots!density plot!2 dimensions|(}
\index{plots!statistics!density 2d}

Examples of the use of \gggeom{stat\_density\_2d()} to create 2D density plots follow. In the first example we use two \emph{geometries} which were earlier described, \code{geom\_point()} and \code{geom\_rug()} to plot the observations in the background. The \emph{statistic} computes and plots a two dimensional density ``map'' plotted using isolines. We map \code{group} to the \code{colour} \emph{aesthetic}.

<<density-plot-10>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  stat_density_2d()
@

In this case \gggeom{geom\_density\_2d()} is equivalent, and we can replace it in the last line in the chunk above.
<<density-plot-11, eval=eval_plots_all, echo=4>>=
ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  geom_rug() +
  geom_density_2d()
@

In the next example we plot the groups in separate panels, and use a \emph{geometry} supporting the \code{fill} \emph{aesthetic} and we map to it the variable \code{level}, computed by \code{stat\_density\_2d()}

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<density-plot-12>>=
ggplot(my.data, aes(x, y)) +
stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group)
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@
\index{plots!density plot!2 dimensions|)}

\subsection{Box and whiskers plots}\label{sec:boxplot}
\index{box plots|see{plots, box and whiskers plot}}
\index{plots!box and whiskers plot|(}

Box and whiskers plots, also very frequently called just boxplots, are also summaries that convey some of the characteristics of a distribution. They are calculated and plotted by means of \gggeom{geom\_boxplot()}. Although they can be calculated and plotted based on just a few observations, they are not useful unless each box plot is based in more than 10 to 15 observations.

<<bw-plot-01>>=
ggplot(my.data, aes(group, y)) +
  geom_boxplot()
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as color, and others specific to these type of visual representation.
\index{plots!box and whiskers plot|)}

\subsection{Violin plots}\label{sec:plot:violin}
\index{plots!violin plot|(}

Violin plots are a more recent development than box plots, and usable with relatively large numbers of observations. They could be thought as being a sort of hybrid between an empirical density function (see section \ref{sec:plot:density} on page \pageref{sec:plot:density}) and a box plot (see section \ref{sec:boxplot} on page \pageref{sec:boxplot}). As is the case with box plots, they are particularly useful when comparing distributions of related data, side by side. They can be created with  \gggeom{geom\_violin()} as shown in the examples below. They are most frequently used to compare empirical density distributions between groups, by plotting them side by side.

<<violin-plot-01, eval=eval_plots_all>>=
ggplot(my.data, aes(group, y)) +
  geom_violin()
@

<<violin-plot-02>>=
ggplot(my.data, aes(group, y, fill = group)) +
  geom_violin(alpha = 0.16) +
  geom_point(alpha = 0.33, size = rel(4),
             colour = "black", shape = 21)
@

As with other \emph{geometries} their appearance obeys both the usual \emph{aesthetics} such as colour, and others specific to these type of visual representation.

Other types of displays related to violin plots are beeswarm plots and sina plots, using categorical scatter plots can be produced with \emph{geometries} defined in packages \pkgname{ggbeeswarm} and \pkgname{ggforce}, respectively. Minimal examples are shown here. See the documentation of the packages for details about the many options in their use.

<<ggbeeswarm-plot-01>>=
ggplot(my.data, aes(group, y)) +
  geom_quasirandom()
@

<<sina-plot-01>>=
ggplot(my.data, aes(group, y)) +
  geom_sina()
@

\index{plots!violin plot|)}
\index{plots!statistics|)}

\section{Facets}
\index{plots!facets|(}
\index{plots!panels|see{plots, facets}}
Facets are a special kind of plots containing multiple panels in which the panels share some properties.
These sets of coordinated panels are a useful tool for visualizing complex data. These plots became popular through the \code{trellis} graphs in \langname{S}, and the \pkgname{lattice} package in \Rlang. The basic idea is to have row and/or columns of plots with common scales, all plots showing values for the same response variable. This is useful when there are multiple classification factors in a data set. Similarly looking plots but with free scales or with the same scale but a `floating' intercept are sometimes also useful. In \ggplot there are two possible types of facets: facets organized in a grid, and facets along a single `axis' but wrapped into several rows. These are produced by adding \Rfunction{facet\_grid()} or \Rfunction{facet\_wrap()} to a ggplot, respectively. In the examples below we use \gggeom{geom\_point()} but faceting can be used with any \Rclass{ggplot} object.

\begin{warningbox}
  The code underlying faceting has been rewritten in \ggplot version 2.2.0. All the examples given here are backwards compatible with versions 2.1.0. The new functionality is related to the writing of extensions or controlled through themes.
\end{warningbox}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

We create a single-panel plot that we will use through this section to demonstrate how the same plot changes as we add facets using different options. Only some plots are shown and you will need to run the code for the remaining examples to see the output.

<<facets-00>>=
p <- ggplot(data = mtcars, aes(mpg, wt)) + geom_point()
p
@

<<facets-01>>=
p + facet_grid(. ~ cyl)
@

<<facets-02, eval=eval_plots_all>>=
p + facet_grid(cyl ~ .)
@

<<facets-03, eval=eval_plots_all>>=
p + facet_grid(. ~ cyl, scales = "free")
@

<<facets-04, eval=eval_plots_all>>=
p + facet_grid(. ~ cyl, scales = "free", space = "free")
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<facets-05>>=
p + facet_grid(vs ~ am)
@

<<facets-06>>=
p + facet_grid(vs ~ am, margins = TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<facets-07, eval=eval_plots_all>>=
p + facet_grid(. ~ vs + am)
@

<<facets-08, eval=eval_plots_all>>=
p + facet_grid(. ~ vs + am, labeller = label_both)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_very_wide)
@

<<facets-09, eval=eval_plots_all>>=
p + facet_grid(. ~ vs + am, margins = TRUE)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<facets-10>>=
p + facet_grid(cyl ~ vs, labeller = label_both)
@

<<facets-11, eval=eval_plots_all>>=
mtcars$cyl12 <- factor(mtcars$cyl,
                       labels = c("alpha", "beta", "sqrt(x, y)"))
p1 <- ggplot(data = mtcars, aes(mpg, wt)) +
      geom_point() +
      facet_grid(. ~ cyl12, labeller = label_parsed)
@

Here we use as \code{labeller} function \Rfunction{label\_bquote()} with a special syntax that allows us to use an expression where replacement based on the facet (panel) data takes place. See section \ref{sec:plot:plotmath} for an example of the use of \code{bquote()}, the R function on which this labeller is built upon.

<<facets-12>>=
p + facet_grid(. ~ vs, labeller = label_bquote(cols = alpha ^ .(vs)))
@

\begin{infobox}
\sloppy
In versions of \ggplot before 2.0.0, \code{labeller} was not implemented for \Rfunction{facet\_wrap()}, it was only available for \Rfunction{facet\_grid()}.
\end{infobox}

A minimal example of a wrapped facet. In this case the number of levels is small, when they are more the row of plots will be wrapped into two or more continuation rows. When using \Rfunction{facet\_wrap()} there is only one dimension, so no `.' is needed before or after the tilde.

<<facets-13>>=
p + facet_wrap(~ cyl)
@

An example showing that even though faceting with \code{facet\_wrap()} is along a single, possibly wrapped, row, it is possible to produce facets based on more than one variable.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<facets-15, eval=eval_plots_all>>=
p + facet_wrap(~ vs + am, ncol=2)
@

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@
%In versions of \ggplot before 2.0.0, \code{labeller} was not implemented for
%\code{facet\_wrap()}, it was only available for \code{facet\_grid()}. In the current
%version it is implemented for both.
%
%<<echo=FALSE>>=
%opts_chunk$set(opts_fig_wide)
%@
%
%<<>>=
%p + facet_wrap(~ vs, labeller = label_bquote(alpha ^ .(vs)))
%@
\index{plots!facets|)}

\section{Scales}\label{sec:plot:scales}
\index{plots!scales|(}

Scales map data onto \emph{aesthetics}. There are different types of scales depending on the characteristics of the data being mapped: scales can be continuous or discrete. And of course, there are scales for different attributes of the plotted geometrical object, such as position (\code{x, y, z}), \code{size}, \code{colour}, \code{fill}, \code{alpha} or transparency, \code{angle}, justification, etc. This means that many properties of, for example, the symbols used in a plot can be either set by a constant, or mapped to data. The most direct mapping is \code{identity}, which means that the data is taken at its face value. In a numerical scale, say \ggscale{scale\_x\_continuous()}, this means that for example a `5' in the data is plotted at a position in the plot corresponding to the value `5' along the x-axis. A simple mapping could be a log10 transformation, that we can easily achieve with the pre-defined \code{scale\_x\_log10} in which case the position on the $x$-axis will be based on the logarithm of the original data. A continuous data variable can, be mapped to continuous scale either using an identity mapping or transformation, which for example could be useful if we want to map the value of a variable to the area of the symbol rather than its diameter.

Discrete scales work in a similar way. We can use \ggscale{scale\_colour\_identity()} and have in our data a variable with values that are valid colour names like "red" or "blue". However we can also map the \code{colour} aesthetic to a factor with levels like "control", and "treatment", an these levels will be mapped to colours from a palette or we can use \ggscale{scale\_colour\_manual()} to assign whatever colour we want to each level to be mapped. The same is true for other discrete manual scales like those for  \code{shape} and \code{linetype}. Remember that for example for colour, and `numbers' there are both discrete and continuous scales available. Mapping colour or fill to \code{NA} makes the mapped values invisible. The reverse, mapping \code{NA} values in the data to a specific colour or fill is also possible.



\sloppy
Advanced scale manipulation requires package \code{scales} to be loaded, although \ggplot (2.0.0 and later) re-export several functions from package \code{scales}. Some simple examples follow.

\begin{infobox}
\paragraph*{Convenience functions: Axis- and key labels, titles, subtitles and captions}\label{sec:plot:titles}\label{sec:plot:labs}
\index{plots!labels|(}
\index{plots!title|(}
\index{plots!subtitle|(}
\index{plots!caption|(}
Axis and key labels are given by the \code{name} of scales (see section \ref{sec:plot:scales}). Titles, subtitles and captions are added with function \Rfunction{ggtitle()} (see section \ref{sec:plot:title}).
Function \Rfunction{labs()} is a convenience function that saves typing when we use the default scales except for their names---the default name of a scale is the name of the variable or expression mapped to the corresponding \emph{aesthetic}. It accepts arguments named according to the names of the \emph{aesthetics}. In addition it accepts named arguments \code{title}, \code{subtitle} and \code{caption}. Al these can be character strings or \Rlang expressions (see section \ref{sec:plot:plotmath}).

<<axis-labels-01>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  labs(title = "Growth of orange trees",
       subtitle = "Starting from 1968-12-31",
       caption = "see Draper, N. R. and Smith, H. (1998)",
       x = "Time (d)",
       y = "Stem circumference (mm)",
       color = "Tree\nnumber")
@

There are in addition to \code{labs()} convenience functions for setting the axis labels, \Rfunction{xlab()} and \Rfunction{ylab()}. The code below can replace the call to \code{labs()} above.

<<axis-labels-02, eval=eval_plots_all, echo=6:10>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  expand_limits(y = 0) +
  xlab("Time (d)") +
  ylab("Stem circumference (mm)") +
  ggtitle("Growth of orange trees",
          subtitle = "Starting from 1968-12-31",
          caption = "see Draper, N. R. and Smith, H. (1998)")
@

\begin{playground}
Make an empty plot (\code{ggplot()}) and add to it as title an expression producing $y = b_0 + b_1 x + b_2 x^2$. (Hint: have a look at the examples for the use of expressions in \code{plotmath} demo in \Rlang by typing \code{demo(plotmath)} at the \Rlang console.
\end{playground}

Function \code{update\_labels} allows the replacement of labels in an existing plot. We first create a plot with one set of labels, and afterwards we replace them.

<<axis-labels-04, eval=eval_plots_all>>=
p <-
    ggplot(data = mtcars,
           aes(x = disp, y = hp, colour = factor(cyl),
               shape = factor(cyl))) +
      geom_point() +
      labs(x = "Engine displacement)",
           y = "Gross horsepower",
           colour = "Number of\ncylinders",
           shape = "Number of\ncylinders")
p
@

<<axis-labels-05, eval=eval_plots_all>>=
update_labels(p, list(x = "Cilindrada",
                      y = "Potencia bruta (caballos de fuerza)",
                      colour = "no. de\ncilindros",
                      shape = "no. de\ncilindros"))
@

\begin{warningbox}
Check!!
When setting or updating labels using either \Rfunction{labs()} or \Rfunction{update\_labels()} be aware that even though \code{color} and \code{colour} are synonyms for the same \emph{aesthetics}, the `name' used in the call to \Rfunction{aes()} must match the  `name' used when setting or updating the labels.
\end{warningbox}

The labels used in keys and axis tick-labels for factor levels can be changed through the different \emph{scales} as described in section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}.

\index{plots!caption|)}
\index{plots!subtitle|)}
\index{plots!title|)}
\index{plots!labels|)}
\end{infobox}


<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_medium)
@

We generate new fake data.

<<scales-01>>=
fake2.data <-
  data.frame(y = c(rnorm(20, mean = 20, sd = 5),
                   rnorm(20, mean = 40, sd = 10)),
             group = factor(c(rep("A", 20), rep("B", 20))),
             z = rnorm(40, mean = 12, sd = 6))
@

\subsection{Continuous scales}\label{sec:plot:scales:continuous}

\subsubsection{Limits}

\begin{infobox}
\paragraph*{Convenience functions: Scale limits} To\index{plots!scales!continuous!limits} change the limits of the $y$-scale, \Rfunction{ylim()} is a convenience function used for modification of the \code{lims} (limits) of the scale used by the $y$ aesthetic. We here exemplify the use of \Rfunction{ylim()} only, but \Rfunction{xlim()} can be used equivalently for the $x$ scale. Setting hard limits in \emph{scales} excludes all observations outside these boundaries not only from appearing on the plotting area, but also from any calculations done by \emph{statisitcs} (See section \ref{sec:plot:coord:limits} on page \pageref{sec:plot:coord:limits} on the use of limits to \emph{coordinates} to limit only the boundaries of the plotting area without excluding observations from the input to \emph{statistics}).

We can set both limits, minimum and maximum using \Rfunction{xlim()} or \Rfunction{ylim()} which accept two numeric values setting the high and low limit respectively. As elsewhere in \ggplot passing \code{NA} as argument for a limit keeps the existing limit.

<<scales-10>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + ylim(0, 100)
@

We can use \Rfunction{expand\_limits()} to expand the limits of a scale, setting a default minimum range, that will grow when needed to accommodate all observations in the data set. Of course here \code{x} and \code{y} refer to the \emph{aesthetics} and not to names of variables in \code{data}. The arguments to \code{x} and \code{y} are numeric vectors of length one or two each. In the next example we expand the limits to include the origin.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + expand_limits(y = 0, x = 0)
@
\end{infobox}

In addition to with these convenience functions for \code{x} and \code{y} aesthetics, limits can be set to constant values and/or the automatic expansion set through a call to most \emph{scale} functions.

We here set the upper limit to be expanded by adding a value of 10\% of the range of the scale.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(expand = expand_scale(add = c(0, 0.1)))
@

Here we instead use a multiplier to a similar effect as above.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(expand = expand_scale(mult = c(0, 0.1)))
@

Here we set hard limits, which will exclude observations from both the plot and from any calculations of summaries or smoothers.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(limits = c(0, 50))
@

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(limits = c(50, 100))
@

To set only one limit leaving the other free, we use \code{NA}.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(limits = c(50, NA))
@

In the case of scales, we cannot reverse their direction through the use of limits. We need instead to use a transformation as described in the next section.

We can also use \code{limits} with discrete scales, listing all or some of the levels of a factor that are to be included in the scale. This works even if the levels are defined in the factor but not present in a given data set, such as after subsetting.

\begin{playground}
Test what is the result if the first limit is larger than the second one. Is it the same as when setting these same values as limits with \code{ylim()} as shown above?

<<eval=FALSE>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(limits = c(100, 0))
@
\end{playground}

\subsubsection{Transformed scales}

The\index{plots!scales!continuous!transformations} default scale used by the \code{y} aesthetic uses \code{position = "identity"}, but there are predefined for transformed scales.

Although transformations can be passed as argument to \ggscale{scale\_x\_continuous()} and \ggscale{scale\_y\_continuous()}, there are predefined convenience scale functions for \code{log10}, \code{sqrt} and \code{reverse}.

\begin{warningbox}
  Similarly to the maths functions of R, the name of the scales are \ggscale{scale\_x\_log10()} and \ggscale{scale\_y\_log10()} rather than \ggscale{scale\_y\_log()} because in R the function \code{log} returns the natural or Neperian logarithm.
\end{warningbox}

We can use \ggscale{scale\_x\_reverse()} to reverse the direction of a continuous scale,

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() + scale_x_reverse()
@

Axis tick-labels display the original values before applying the transformation. The \code{"breaks"} need to be given in the original scale as well. We use \ggscale{scale\_y\_log10()} to apply a $\log_{10}$ transformation to the $y$ values.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_log10(breaks=c(10,20,50,100))
@

In contrast, transforming the data on-the-fly when mapping it to the $x$ \emph{aesthetic}, results in tick-labels expressed in the logarithm of the original data.

<<>>=
ggplot(fake2.data, aes(z, log10(y))) + geom_point()
@

We show here how to specify a transformation to a continuous scale, using a predefined ``transformation'' object.

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(trans = "reciprocal")
@

Natural logarithms are important in growth analysis as the slope against time gives the relative growth rate. We show this with the \code{Orange} data set.

<<>>=
ggplot(data = Orange,
       aes(x = age, y = circumference, color = Tree)) +
  geom_line() +
  geom_point() +
  scale_y_continuous(trans = "log", breaks = c(20, 50, 100, 200))
@

In section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} we define and use a transformation object.

\begin{warningbox}
When combining scale transformations and summaries, one should be aware of which data are used, transformed or not.
\end{warningbox}

\subsubsection{Tick labels}

Finally, when\index{plots!scales!continuous!tick labels} wanting to display tick labels for data available as fractions as percentages, we can use
\code{labels = scales::percent}.

<<>>=
ggplot(fake2.data, aes(z, y / max(y))) +
  geom_point() +
  scale_y_continuous(labels = scales::percent)
@

\sloppy
In the case of currency we can use \code{labels = scales::dollar}, and if we want to use commas to separate thousands, millions, and so on, we can use \code{labels = scales::comma}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::dollar)
@

When using breaks, we can just accept the default labels for the \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60))
@

We can also set tick labels manually, in parallel to the setting of \code{breaks}.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", "->", "60"))
@

Using an expression we obtain a Greek letter.

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(breaks = c(20, 40, 47, 60),
                     labels = c("20", "40", expression(alpha), "60"))
@

We can pass a function that accepts the breaks and returns labels to \code{labels}. Package \scales defines several formatters, or we can define our own. For \code{log10} scales

<<>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  scale_y_continuous(labels = scales::scientific_format())
@

\sloppy
Please, see section \ref{sec:plot:volcano} on page \pageref{sec:plot:volcano} for an example of the use of \code{scales::math\_format} together with a logarithmic transformation of the data.

\subsection{Time and date scales for $x$ and $y$}

\subsubsection{Limits}

Time\index{plots!scales!time!limits} and date scales are conceptually similar to continuous numeric scales, but use special data types and formatting for labels. We can set limits and breaks using constants as time or dates. These are most easily input with the functions in packages \pkgname{lubridate} or \pkgname{anytime}.

Please, see section \ref{sec:ggpmisc:trydf} on page \pageref{sec:ggpmisc:trydf} for examples.

\subsubsection{Axis labels}

By\index{plots!scales!time!axis labels} default the tick labels produced and their formatting is automatically selected based on the extent of the time data. For example, if we have all data collected within a single day, then the tick labels will show hours and minutes. If we plot data for several years, the labels will show the date portion of the time instant. The default is frequently good enough, but it is possible, as for numbers to use different formatter functions to generate the tick labels.

\subsection{Discrete scales for $x$ and $y$}

In\index{plots!scales!limits}\index{plots!scales!discrete} the case of ordered or unordered factors, the tick labels are by default the names of the factor levels. Consequently one roundabout way to obtaining the desired tick labels is to use them as factor levels. This approach is not recommended as in most cases the text of the desired tick labels may not be recognized as a valid name making the code using them difficult to type in scripts or at the command prompt. It is best to use simple mnemonic short names for factor levels and variables, and to set suitable labels when plotting, as we will show here.

\begin{explainbox}
When using factors, the ordering used for plotting levels is the one they have in the factor. When a factor is created, the default is for levels to be stored in alphabetical order. This default can be easily overridden at the time of creation, as well as the order modified at a later time.

<<>>=
default.fct <- factor(c("a", "c", "f", "f", "a", "d"))
levels(default.fct)
@

<<>>=
levels.fct <- factor(c("a", "c", "f", "f", "a", "d"),
                      levels = c("f", "a", "d", "c"))
levels(levels.fct)
@

Reorder can be used to change the order of the levels based on the values of a numeric variable. We will visit once again the \code{Orange} data set.

<<>>=
my1.Tree <- with(Orange,
                reorder(Tree, -circumference))
levels(Orange$Tree)
levels(my1.Tree)
@

Which is equivalent to reversing the order in this particular case.

<<>>=
my2.Tree <- with(Orange,
                factor(Tree,
                levels = rev(levels(Tree))))
levels(Orange$Tree)
levels(my2.Tree)
@

We restore the default ordering.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = sort(levels(Tree))))
levels(Orange$Tree)
levels(my3.Tree)
@

We can set the levels in any arbitrary order by explicitly listing the level names, not only at the time of creation but also later. Here we show that it is possible to not only reorder existing levels, but even to add a level for which there are no observations.

<<>>=
my3.Tree <- with(Orange,
                factor(Tree,
                levels = c("1", "2", "3", "4", "5", "9")))
levels(Orange$Tree)
levels(my3.Tree)
@

\end{explainbox}

We use here once again the \code{mpg} data set.

We order the columns in the plot based on \code{mpg\$hwy} by reordering \code{mpg\$class}. This approach makes sense if this ordering is needed for all plots. It is always bad to keep several versions of a single data set as it easily leads to mistakes and confusion.

<<>>=
my.mpg <- mpg
my.mpg$class <- with(my.mpg, reorder(factor(class), hwy))
ggplot(my.mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or the same on-the-fly, which is much better as the data remains unmodified..

<<>>=
ggplot(mpg, aes(reorder(factor(class), hwy), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Or ordering based on a different variable, \code{displ}.

<<>>=
ggplot(mpg, aes(reorder(factor(class), displ), hwy)) +
  stat_summary(geom = "col", fun.y = mean)
@

Alternatively we can use \ggscale{scale\_x\_discrete()} to reorder and select the columns without altering the data. If we use this approach to subset the data, then to avoid warnings we need to add \code{na.rm = TRUE}. We use the scale in this example to convert level names to uppercase. The complementary function of \Rfunction{toupper()} is \Rfunction{tolower()}.

<<>>=
ggplot(mpg, aes(class, hwy)) +
  stat_summary(geom = "col", fun.y = mean, na.rm = TRUE) +
  scale_x_discrete(limits = c("compact", "subcompact", "midsize"),
  labels = toupper)
@

\subsection{Size}

For\index{plots!scales!size} the \code{size} \emph{aesthetic} several scales are available, both discrete and continuous. They do not differ much from those already described above. \emph{Geometries} \gggeom{geom\_point()}, \gggeom{geom\_line()}, \gggeom{geom\_hline()}, \gggeom{geom\_vline()}, \gggeom{geom\_text()}, \gggeom{geom\_label()} obey \code{size} as expected. In the case of \gggeom{geom\_bar()}, \gggeom{geom\_col()}, \gggeom{geom\_area()} and all other geometric elements bordered by lines, \code{size} is obeyed by these border lines. In fact, other aesthetics natural for lines such as \code{linetype} also apply to these borders.

When using \code{size} scales, \code{breaks} and \code{labels} affect the key or \code{guide}. In scales that produce a key passing \code{guide = FALSE} removes the key corresponding to the scale.

\subsection{Color and fill}

Colour\index{scales!color}\index{scales!fill} and fill scales are similar, but they affect different elements of the plot. All visual elements in a plot obey the \code{color} \emph{aesthetic}, but only elements that have an inner region and a boundary, obey both \code{color} and \code{fill} \emph{aesthetics}. There are separate but equivalent sets of scales available for these two aesthetics. We will describe in more detail the \code{color} \emph{aesthetic} and give only some examples for \code{fill}. We will however, start by reviewing how colors are defined and used in R.

\subsubsection{Color definitions in R}\label{sec:plot:colors}
\index{colour|see{color}}
\index{color!definitions|(}
\index{color!using|(}
Colors can be specified in R not only through character strings with the names of previously defined colors, but also directly as strings describing the RGB components as hexadecimal numbers (on base 16) such as \code{"\#FFFFFF"} for white or \code{"\#000000"} for black, or \code{"\#FF0000"} for the brightest available pure red. The list of color names known to R can be obtained be entering \code{colors()} in the console.

Given the number of colors available, we may want to subset them based on their names. Function \code{colors()} returns a character vector. We can use \code{grep()} or \code{grepl()} to find indexes to the names containing a given character substring, in this example \code{"dark"}.

<<>>=
grep("dark",colors())
@

\begin{playground}
Replace \Rfunction{grep()} by \Rfunction{grepl()} in the example above. What is the difference in the returned value?
\end{playground}

Although the vector of indexes, or the logical vector, could be used to extract the subset of matching color names with code like,

<<>>=
colors()[grep("dark", colors())]
@

a simpler approach is available.

<<>>=
grep("dark", colors(), value = TRUE)
@

To retrieve the RGB values for a color definition we use

<<>>=
col2rgb("purple")
col2rgb("#FF0000")
@

Color definitions in R can contain a \emph{transparency} described by an \code{alpha} value, which by default is not returned.

<<>>=
col2rgb("purple", alpha = TRUE)
@

With function \Rfunction{rgb()} we can define new named or nameless colors.
<<>>=
rgb(1, 1, 0)
rgb(1, 1, 0, names = "my.color")
rgb(255, 255, 0, names = "my.color", maxColorValue = 255)
@

As described above colors can be defined in the RGB \emph{color space}, however, other color models such as HSV (hue, saturation, value) can be also used to define colours.

<<>>=
hsv(c(0,0.25,0.5,0.75,1), 0.5, 0.5)
@

The probably a more useful flavour of HSV colors are those returned by function \Rfunction{hcl()} for hue, chroma and luminance. While the ``value'' and ``saturation'' in HSV are based physical values, the ``chroma'' and ``luminance'' values in HCL are based on human visual perception. Colours with equal luminance will be as equally bright by average human being. In a scale based on different hues but equal chroma and luminance values, as used by package \ggplot, all colours are perceived as equally bright. The hues need to be expressed as angles in degrees, with values between zero and 360.

<<>>=
hcl(c(0,0.25,0.5,0.75,1) * 360)
@

It is also important to remember that humans can only distinguish a limited set of colours, and even smaller colour gamuts can be reproduced by screens and printers. Furthermore, variation from individual to individual exists in color perception, including different types of colour blindness. It is important to take this into account when using colour in illustrations.
\index{color!definitions|)}

\subsection{Continuous colour-related scales}
\index{plots!scales!color|(}
\index{plots!scales!fill|(}
\sloppy
Scales \ggscale{scale\_color\_continuous()}, \ggscale{scale\_color\_gradient()}, \ggscale{scale\_color\_gradient2()},  \ggscale{scale\_color\_gradientn()}, \ggscale{scale\_color\_date()} and \ggscale{scale\_color\_datetime()}, give a smooth continuous gradient between two or more colours. They are useful for numerical, date and datetime data. A corresponding set of \code{fill} scales is also available.

\subsection{Discrete colour-related scales}

\sloppy
Scales \ggscale{scale\_color\_discrete()}, \ggscale{scale\_color\_hue()}, \ggscale{scale\_color\_grey()} are useful for categorical data stored as factors.

\subsection{Identity scales}

In the case of identity scales the mapping is 1 to 1 to the data. For example, if we map the \code{color} or \code{fill} \emph{aesthetic} to a variable using \ggscale{scale\_color\_identity()} or \ggscale{scale\_fill\_identity()} the variable in the data frame passed as argument for \code{data} must already contain valid color definitions. In the case of mapping \code{alpha} the variable must contain numeric values in the rage 0 to 1.

We create a data frame containing a variable \code{colors} containing character strings interpretable as the names of color definitions known to R. We then use them directly in the plot.

<<>>=
df99 <- data.frame(x = 1:10, y = dnorm(10), colors = rep(c("red", "blue"), 5))

ggplot(df99, aes(x, y, color = colors)) +
  geom_point() +
  scale_color_identity()
@

\begin{playground}
How does the plot look, if the identity scale is deleted from the example above? Edit and re-run the example code.
\end{playground}

\begin{playground}
While using the identity scale, how would you need to change the code example above, to produce a plot with green and purple point?
\end{playground}
\index{plots!scales!fill|)}
\index{plots!scales!color|)}
\index{color!using|)}

\subsection{Position of axes}
\index{plots!axis position}

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_x_continuous(position = "top") +
  scale_y_continuous(position = "right")
@

\subsection{Secondary axes}
\index{plots!secondary axes}
<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ . ^-1, name = "1/y")
  )
@

<<>>=
ggplot(fake2.data, aes(z, y)) + geom_point() +
  scale_y_continuous(
    "y",
    sec.axis = sec_axis(~ ., name = "y", breaks = c(33.2, 55.4))
  )
@
\index{plot!scales|)}

\section{Adding annotations}
\index{plots!annotations}
Annotations use the data coordinates of the plot, but do not `inherit' data or aesthetics from the \Rclass{ggplot} object. They are added to a ggplot with \Rfunction{annotate()}. Annotations frequently make use \code{"text"} or \code{"label"} \emph{geometries} with character strings as data, possibly to be parsed as expressions. However, other \emph{geometries} can also be very useful. We start with a simple example with text.

<<annotate-01>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  annotate(geom = "text",
           label = "origin",
           x = 0, y = 0,
           color = "blue",
           size=4)
@

\begin{playground}
Play with the values of the arguments to \Rfunction{annotate()} to vary the position, size, color, font family, font face, rotation angle and justification of the annotation.
\end{playground}

We can add lines to mark the origin more precisely and effectively. With \ggplot 2.2.1 we cannot use \Rfunction{annotate()} with \code{geom = "vline"} or \code{geom = "hline"}, but we can achieve the same effect by directly adding layers with the \emph{geometries}, \gggeom{geom\_vline()} and/or  \gggeom{geom\_hline()}, to the plot.

<<annotate-02>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  geom_hline(yintercept = 0, color = "blue") +
  geom_vline(xintercept = 0, color = "blue")
@

\begin{playground}
Play with the values of the arguments to  \Rfunction{annotate} to vary the position and attributes of the lines. The vertical and horizontal line geometries have the same properties as other lines: linetype, color, size, etc.
\end{playground}

\begin{playground}
Modify the examples above to use the \code{line} \emph{geometry} for the annotations. Explore the help page for \gggeom{geom\_line()} and add arrows as annotations to the plot.
\end{playground}

In this third example, in addition to adding expressions as annotations, we also pass expressions as tick labels through the scale. Do notice that we use recycling for setting the breaks, as \code{c(0, 0.5, 1, 1.5, 2) * pi} is equivalent to \code{c(0, 0.5 * pi, pi, 1.5 * pi, 2 * pi}. Annotations are plotted at their own position, unrelated to any observation in the data, but using the same coordinates and units as for plotting the data.

<<annotate-03>>=
ggplot(data.frame(x = c(0, 2 * pi)), aes(x = x)) +
  stat_function(fun = sin) +
  scale_x_continuous(
    breaks = c(0, 0.5, 1, 1.5, 2) * pi,
    labels = c("0", expression(0.5~pi), expression(pi),
             expression(1.5~pi), expression(2~pi))) +
  labs(y = "sin(x)") +
  annotate(geom = "text",
           label = c("+", "-"),
           x = c(0.5, 1.5) * pi, y = c(0.5, -0.5),
           size = 20) +
  annotate(geom = "point",
           colour = "red",
           shape = 21,
           fill = "white",
           x = c(0, 1, 2) * pi, y = 0,
           size = 6)
@

\begin{playground}
Modify the plot above to show the cosine instead of the sine function, replacing \code{sin} with \code{cos}. This is easy, but the catch is that you will need to relocate the annotations.
\end{playground}

\section{Coordinates and circular plots}
\index{plots!circular|(}

In this section I include pie charts and wind-rose plots. Here we add a new "word" to the grammar of graphics, \textit{coordinates}, such as \ggcoordinate{coord\_polar()} in the next examples\index{coordinates!polar}\index{plots!coordinates!polar}. The default coordinate system for $x$ and $y$ \textit{aesthetics} is cartesian.

\subsection{Coordinate limits}\label{sec:plot:coord:limits}
\index{plots!coordinates!cartesian}
\index{plots!coordinates!setting limits}

The limits of set using \emph{scales}, such as \code{scale\_x\_continuous()} or \code{scale\_y\_continuous()}, and the convenience functions \code{xlim()} and \code{ylim()}, set boundaries to the data used by both \emph{geometries} and \emph{statistics} (See section \ref{sec:plot:scales:limits} on page \pageref{sec:plot:scales:limits}). When plotting individual observations this does not come as a surprise, but for \emph{statistics} it frequently does when we have only layers based on computed summaries in a given plot. For example plots using only \code{stat\_summary()} or \code{geom\_smooth()} can be easily and seriously distorted when setting limits manually excludes from computations individual observations that are not plotted on their own.

The limits in \emph{coordinates} work differently, they do not set boundaries to the data included. Instead, these limits only affect the plotting area. A simple example demonstrates this.

<<>>=
set.seed(12345)
fake3.data <- data.frame(x = 1:20, y = (1:20)^2 + rnorm(20))
p <- ggplot(fake3.data, aes(x, y)) +
       geom_point() +
       geom_smooth(method = "lm")
p
@

Uses all data, so the smooth curve is the same, but only part is visible.

<<>>=
p + coord_cartesian(xlim = c(1, 10))
@

The smooth line is fitted only to the data within limits.

<<>>=
p + xlim(1, 10)
@

Depending on the case coordinate limits or scale limits will be the correct ones to use. However, whenever there are calculations involved, and observations present outside the limits, only one of these two approaches will give the correct plot. One should think of scale limits as a kind of data subsetting and of coordinate limits as setting a zoomed window onto the plotting area.

\subsection{Pie charts}
\index{plots!pie charts|(}

Pie charts are more difficult to read: our brain is more comfortable at comparing
lengths than angles. If used, they should only be used to show composition, or
fractional components that add up to a total. In this case only if the number of
“pie slices” is small (rule of thumb: less than seven).

We make the equivalent of the first bar plot above. As we are still using \gggeom{geom\_bar()} the default is \code{stat\_count}. As earlier we use the brewer scale for nicer colors.

<<>>=
ggplot(data = mpg, aes(x = factor(1), fill = factor(class))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_brewer() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class")
@

Even with four slices pie charts can be difficult to read. Compare the following bar plot and pie chart.

<<>>=
ggplot(data = mpg, aes(x = factor(cyl), fill = factor(cyl))) +
  geom_bar(color = "black") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()

ggplot(data = mpg, aes(x = factor(1), fill = factor(cyl))) +
  geom_bar(width = 1, color = "black") +
  coord_polar(theta = "y") +
  scale_fill_grey() +
  scale_x_discrete(breaks = NULL) +
  labs(x = NULL, fill = "Vehicle class") +
  theme_bw()
@

An example comparing pie charts to bar plots is presented in section \ref{sec:plot:pie:bar} on page \pageref{sec:plot:pie:bar}.
\index{plots!pie charts|)}

\subsection{Wind-rose plots}
\index{plots!wind rose|(}
They can be plotted as histograms on polar coordinates, when the data is to be represented by frequencies or, as density plot. A bar plot or a line or points when the values are means calculated with a \emph{statistic} or a single observation is available per quadrat. It also possible to use summaries, or smoothers.

Some types of data are more naturally expressed on polar coordinates than on cartesian coordinates. The clearest example is wind direction, from which the name derives. In some cases of time series data with a strong periodic variation, polar coordinates can be used to highlight any phase shifts or changes in frequency. A more mundane application is to plot variation in a response variable through the day with a clock-face like representation of time-of-day.

We use for the next examples wind speed and direction data, measured once per minute during 24~h, from \pkgname{learnrbook}.
We first show a time series plot, using cartesian coordinates, which demonstrates the problem of using an arbitrary origin at the North for a variable that does not have a scale with true limits: early in the day the predominant direction is just slightly West of 0 degrees North and the cloud of observations gets artificially split. We can also observe a clear change in wind direction soon after solar noon.

<<wind-02>>=
ggplot(viikki_d29.dat, aes(solar_time, WindDir_D1_WVT))  +
geom_point() +
scale_x_datetime(date_labels = "%H:%M") +
labs(x = "Time of day (hh:mm)", y = "Wind direction (degrees)")
@

No such problem exists with wind speed, and we add a smooth line with \gggeom{geom\_smooth()}.

<<wind-03>>=
ggplot(viikki_d29.dat, aes(solar_time, WindSpd_S_WVT))  +
geom_point() +
# geom_smooth() +
scale_x_datetime(date_labels = "%H:%M") +
labs(x = "Time of day (hh:mm)", y = "Wind speed (m/s)")
@

Using a scatter plot with polar coordinates helps to some extent, but having time of day on the radial axis is rather unclear.

<<wind-04>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, solar_time))  +
  coord_polar() +
  geom_point() +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_datetime(date_labels = "%H:%M",
                   name = "Time of day (hh:mm)",
                   date_breaks = "6 hours",
                   date_minor_breaks = "3 hours",)
@

Most frequently, wind-rose plots use summaries, such as histograms or densities.
Next we plot a circular histogram of wind directions with 15 degrees-wide bins. We use \ggstat{stat\_bin()}.

<<wind-05>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT))  +
  coord_polar() +
  stat_bin(color = "black", fill = "grey50", binwidth = 15, geom = "bar") +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Frequency")
@

An equivalent plot, using an empirical density, created with \ggstat{stat\_density()}.

<<wind-06>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT))  +
  coord_polar() +
  stat_density(color = "black", fill = "grey50", size = 1, na.rm = TRUE) +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Density")
@

As final wind-rose plot examples we do a scatter plot of wind speeds versus wind direction and a two dimensional density plot. In both cases we use \Rfunction{facet\_wrap()} to have separate panel for AM and PM. In the scatter plot we set \code{alpha = 0.1} for better visualization of overlapping points.

<<wind-07>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, WindSpd_S_WVT)) +
  coord_polar() +
  geom_point(alpha = 0.1, shape = 16) +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Wind speed (m/s)") +
  facet_wrap(~factor(ifelse(hour(solar_time) < 12, "AM", "PM")))
@

<<wind-08>>=
ggplot(viikki_d29.dat, aes(WindDir_D1_WVT, WindSpd_S_WVT)) +
  coord_polar() +
  stat_density_2d() +
  scale_x_continuous(breaks = c(0, 90, 180, 270),
                     labels = c("N", "E", "S", "W"),
                     limits = c(0, 360),
                     expand = c(0, 0),
                     name = "Wind direction") +
  scale_y_continuous(name = "Wind speed (m/s)") +
  facet_wrap(~factor(ifelse(hour(solar_time) < 12, "AM", "PM")))
@

\index{plots!wind rose|)}
\index{plots!circular|)}


\section{Themes}\label{sec:plot:themes}
\index{plots!themes|(}
For ggplot2 themes are the equivalent of style sheets for text. They determine how the different elements of a plot are rendered when displayed, printed or saved to a file. They do not alter how the data themselves are displayed, but instead that of text-labels, titles, axes, grids, etc. are formatted. Package \ggplot includes several predefined themes, and some extension packages described in the next chapter define additional ones. In addition to switching between themes, the user can modify the format applied to individual elements, or define totally new themes.

\subsection{Predefined themes}
\index{plots!themes!predefined|(}
The theme used by default is \ggtheme{theme\_grey()}. Themes are defined as functions, with parameters. These parameters allow changing some ``base'' properties. The base size for text elements is given in points, and affects all text elements in a plot (except those produced by \emph{geometries}) as the size of them is by default defined relative to the base size. Another parameter, \code{base\_family}, allows the font family to be set.

Even the default \ggtheme{theme\_grey()} can come in handy because the first parameter to themes is the base point size.


<<themes-01>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  theme_grey(10)
@

<<themes-01a>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  theme_grey(15)
@

We can also set the base family.

<<themes-01b>>=
ggplot(fake2.data, aes(z, y)) +
  geom_point() +
  theme_grey(base_size = 15,
             base_family = "serif")
@

\begin{playground}
Change the code in the previous chunk to use the \code{"mono"} font family at size 8.
\end{playground}

\begin{playground}
Change the code in the previous chunk to use all the other predefined themes: \ggtheme{theme\_bw()}, \ggtheme{theme\_classic()}, \ggtheme{theme\_minimal()}, \ggtheme{theme\_linedraw()}, \ggtheme{theme\_light()}, \ggtheme{theme\_dark()} and \ggtheme{theme\_void()}.
\end{playground}

A frequent idiom is to create a ggplot without specifying a theme, and then adding the theme when printed.

<<themes-03>>=
p <- ggplot(fake2.data, aes(z, y)) +
       geom_point()
p + theme_bw()
@

\begin{playground}
Play by replacing in the last statement in the previous code chunk the theme used to print the saved ggplot object \code{p}. Do also try the effect of changing the base size and font family.
\end{playground}

It is also possible to set the default theme to be used by all subsequent plots rendered.

<<themes-04>>=
p
@

We save the current default theme, so as to be able to restore it. If there is no need to `go back' then saving can be skipped by not including the left hand side and the assignment operator in the first statement below.

<<themes-05>>=
old_theme <- theme_set(theme_bw(15))
p
@

<<themes-06>>=
theme_set(old_theme)
p
@
\index{plots!themes!predefined|)}

\subsection{Modifying a theme}
\index{plots!themes!modifying|(}
Sometimes we would just like to slightly tweak one of the predefined themes. This is also possible. We exemplify this by solving the frequent problem of overlapping $x$-axis tick labels with different approaches. We force this by setting the number ticks to a high value. Usually rotating the text of the labels solves the problem.

<<themes-11>>=
ggplot(fake2.data, aes(z + 100, y)) +
  geom_point() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
@

\begin{playground}
Play with the code above, modifying the values used for \code{angle}, \code{hjust} and \code{vjust}. (Angles are expressed in degrees, and justification with values between 0 and 1.
\end{playground}

\begin{warningbox}
When tick labels are rotated one usually needs to set both the horizontal and vertical justification as the default values are no longer suitable. This is due to the fact that justification settings are referenced to the text itself rather than to the plot, i.e.\ vertical justification of $x$-axis tick labels rotated 90 degrees sets their horizontal position with respect to the plot.
\end{warningbox}

Another possibility is to use a smaller font size. Within theme function \Rfunction{rel()} can be used to set size relative to the base size.

<<themes-12>>=
ggplot(fake2.data, aes(z + 100, y)) +
  geom_point() +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +
  theme(axis.text = element_text(color = "darkblue"),
        axis.text.x = element_text(size = rel(0.6)))
@

Themes definitions follow a hierarchy, allowing us to modify the formatting of groups of similar elements, as well as of individual elements. In the chunk above we modify the color of the tick labels in both axes, but changed the font size only for the $x$-axis.

\begin{playground}
Modify the example above, so that the tick labels on the $x$-axis are blue and those on the $y$-axis red, and the font size the same for both axes, but changed from the default.
\end{playground}

Formatting of all other text elements can be adjusted in a similar way.

The color of the background, and the properties of the grid lines and other lines can be adjusted thought theme elements. We next change the properties of the lines used for the axes, removing the lines on the top and right margins, and adding arrow heads to the axis lines. See chapter 9 in \citebooktitle{Wickham2016} \autocite{Wickham2016} for additional examples and \citebooktitle{Chang2013} \autocite{Chang2013} for more details.

\begin{warningbox}
If you use a saved theme, and want to modify some elements, then the saved theme should be added to the plot before adding \code{+ theme(...)} as otherwise the changes would be overwritten.
\end{warningbox}

It is also possible to modify the default theme used for rendering all subsequent plots.

<<themes-14>>=
p
@

As above, we save the current default theme, so as to be able to restore it.

<<themes-15>>=
old_theme <- theme_update(text = element_text(color = "red"))
p
@

<<themes-16>>=
theme_set(old_theme)
p
@
\index{plots!themes!modifying|)}

\subsection{Defining a new theme}
\index{plots!themes!creating|(}

Themes can be defined both from scratch, or by modifying existing saved themes, and saving the modified version. If we want to preserve the ability to change the base settings, we cannot use \code{theme()} to modify a saved theme and save the resulting theme. We need to create a new theme from scratch. However, unless you are writing a package, the first way of ``creating'' a new theme is enough, and documented in the vignette accompanying package \ggplot. We give an example below.

<<themes-21>>=
my_theme <- theme_bw() + theme(text = element_text(color = "red"))
@

The default theme remains unchanged.

<<themes-22>>=
p
@

But we can use the saved theme when desired.

<<themes-23>>=
p + my_theme
@

Be aware that our own \code{my\_theme} is not a function, and consequently we do not use parenthesis as with the saved themes included in package \ggplot.

\begin{playground}
It is always good to learn to recognize error messages. One way of doing this is by generating errors on purpose. So do add parentheses to the statement in the code chunk above.
\end{playground}

\begin{explainbox}
How to create a new theme with a behaviour similar to those part of package \ggplot is not documented, as it is usually the case with changes that involve programming. However, you should always remember that the source code is available. Usually typing the name of a function without the parentheses is enough to get a listing of its definition, or if this is not useful, then reading the source file in the package reveals how a function has been defined. We can then use it as a template for writing our own function.
\end{explainbox}

Looking at the definition of \ggtheme{theme\_minimal()} gives us enough information as to proceed to define our own modified theme as a function.

<<themes-31, tidy=TRUE, tidy.opts=list(width.cutoff=30)>>=
theme_minimal
@

Using \ggtheme{theme\_minimal()} as a model, we will proceed to define our own theme function. Argument \code{complete = TRUE} is essential as it affects the behaviour of the returned theme. A `complete' theme replaces any theme present in the ggplot object clearing all settings, while a theme that is not `complete' adds to the existing the new elements without clearing existing settings not being redefined. Saved themes like \ggtheme{theme\_grey()} are complete themes, while the themes objects returned by \Rfunction{theme()} are by default not complete.

<<themes-32>>=
my_theme <-
    function (base_size = 11, base_family = "") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(color = "red"), complete = TRUE)
    }
@

The default theme remains unchanged, as shown earlier. The saved theme is now a function, and accepts arguments. In this example we have kept the function parameters the same as used by the predefined themes---whenever it is possible we should avoid surprising users.

<<themes-33>>=
p + my_theme(base_family = "serif")
@

There is nothing to prevent us from defining a theme function with additional parameters. The example below is fully compatible with the one defined above thanks to the default argument for \code{text.color} but allows changing the color.

<<themes-32a>>=
my_theme <-
    function (base_size = 11, base_family = "", text.color = "red") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(color = text.color), complete = TRUE)
    }
@

<<themes-33a>>=
p + my_theme(text.color = "green")
@

\begin{playground}
Define a theme function that instead of \code{color} allows setting the \code{face} (regular, bold, italic) through a user-supplied argument.
\end{playground}

\begin{warningbox}
In the definition of \ggtheme{theme\_minimal()}, \code{\%+replace\%} is used so as to unset all the properties of each theme element, while \code{+} only replaces the properties explicitly given as argument to the \emph{element}-setting function.
\end{warningbox}

\begin{explainbox}
The function \ggtheme{theme\_minimal()} was a good model for the example above, however, it was not the first function I explored. I did list the definition of \ggtheme{theme\_gray()} first, but as this theme is defined from scratch, it was not the best starting point for our problem. Of course, if we had wanted to define a theme from scratch, then it would have been the `model' to use for defining it.
\end{explainbox}

Frequently one needs the same plots differently formatted, e.g.\ for overhead slides and for use in a printed article or book. In such a case, we may even want some elements like titles to be included only in the plots in overhead slides. One could create two different \Rclass{ggplot} objects, one for each occasion, but this can lead to inconsistencies if the code used to create the plot is updated. A better solution is to use themes, more generally, define themes for the different occasions according to one's taste and needs. A simple example is given in the next five code chunks.

<<themes-35>>=
theme_ovh <-
    function (base_size = 15, base_family = "") {
        theme_grey(base_size = base_size, base_family = base_family) +
            theme(text = element_text(face = "bold"), complete = TRUE)
    }

theme_prn <-
    function (base_size = 11, base_family = "serif") {
        theme_classic(base_size = base_size, base_family = base_family) +
            theme(plot.title = element_blank(),
                  plot.subtitle = element_blank(),
                  complete = TRUE)
    }
@

<<themes-36>>=
p1 <- p + ggtitle("A Title", subtitle = "with a subtitle")
@

<<themes-37>>=
p1
@

<<themes-38>>=
p1 + theme_ovh()
@

<<themes-39>>=
p1 + theme_prn()
@

\begin{playground}
Modify the two themes defined above, so as to suite your own tastes and needs, but first of all, just play around to get a feel of all the possibilities. The help page for function \Rfunction{theme()} describes and exemplifies the use of most if not all the valid theme elements.
\end{playground}
\index{plots!themes!creating|)}
\index{plots!themes|)}

\section[Using plotmath expressions]{Using \code{plotmath} expressions}\label{sec:plot:plotmath}
\index{plotmath}
\index{plots!math expressions|(}
In sections \ref{sec:plot:function} and \ref{sec:plot:text} we gave some simple examples of the use of R expressions in plot. The \code{plotmath} demo and help in R give all the details of using expressions in plots. Composing syntactically correct expressions can be challenging. Expressions are very useful but rather tricky to use because the syntax is unusual. Although expressions are here shown in the context of plotting, they are also used in other contexts in R code.% as described in section \ref{sec:??} on page \pageref{sec:??}.

When constructing a \Rclass{ggplot} object one can either use expressions explicitly, or supply them as character string labels, and tell \code{ggplot} to parse them. For titles, axis-labels, etc. (anything that is defined within \Rfunction{labs()}) the expressions have to be entered explicitly, or saved as such into a variable, and the variable supplied as argument.

When plotting expressions using \gggeom{geom\_text()} \emph{expression} arguments should be supplied as character strings and the optional argument \code{parse = TRUE} used to tell the \emph{geometry} to parse (``convert'') the text labels into expressions.

Finally in the case of facets, panel labels can also be expressions. They can be generated by \emph{labeller} functions to allow them to be dynamic.

Before giving examples using these different mechanisms to add maths to plots, I will describe the syntax used to write expressions. The most difficult thing to remember is how to connect the different parts of the expression. Tilde (\code{\textasciitilde}) adds space in between symbols. Asterisk (\code{*}) can be also used as a connector, and is needed usually when dealing with numbers. Using space is allowed in some situations, but not in others. For a long list of examples have a look a the output and code displayed by \code{demo(plotmath)} at the R command prompt.

<<eval=FALSE>>=
demo(plotmath)
@

We will use a couple of complex examples to show in each plot how to use expressions for different elements of a plot.

We first create a data frame, using \Rfunction{paste()} to assemble a vector of subscripted $\alpha$ values.
<<plotmath-01>>=
set.seed(54321) # make sure we always generate the same data
my.data <-
  data.frame(x = 1:5,
             y = rnorm(5),
             greek.label = paste("alpha[", 1:5, "]", sep = ""))
@

We also use a Greek $\alpha$ character, but with $i$ as subscript, instead of a number. The $y$-axis label uses a superscript for the units. The title is a rather complex expression. In these three cases, we explicitly use \Rfunction{expression()}.

We label each observation with a subscripted $alpha$, offset from the point position and rotated. We finally add an annotation with the same formula as used for the title but in red. Annotations are plotted ignoring the default aesthetics, but still make use of \emph{geometries}. We cannot pass expressions to \emph{geometries} by simply mapping them to the label aesthetic. Instead, we pass character strings that can be parsed into expressions. In simpler terms, a string, that is written using the syntax of expressions but not using the function \Rfunction{expression()}. We need to set \code{parse = TRUE} so that the strings instead of being plotted as is, are parsed into expressions at the time the plot is output. When using \gggeom{geom\_text()}, the argument passed to parameter \code{label} must be a character string. Consequently, expressions to be plotted through this \emph{geometry} need always to be parsed.

<<plotmath-02>>=
ggplot(my.data, aes(x, y, label = greek.label)) +
   geom_point() +
   geom_text(angle = 45, hjust = 1.2, parse = TRUE) +
   labs(x = expression(alpha[i]),
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label = "sqrt(alpha[1] + frac(beta, gamma))",
           y = 2.5, x = 3, size = 8, colour = "red", parse = TRUE) +
   expand_limits(y = c(-2, 4))
@

We can also use a character string stored in a variable, and use \Rfunction{parse()} both explicitly and implicitly by setting \code{parse = TRUE}.

<<plotmath-02a>>=
my_eq.char <- "sqrt(alpha[1] + frac(beta, gamma))"
ggplot(my.data, aes(x, y, label = greek.label)) +
   geom_point() +
   geom_text(angle = 45, hjust = 1.2, parse = TRUE) +
   labs(x = expression(alpha[i]),
        y = expression(Speed~~(m~s^{-1})),
        title = parse(text = my_eq.char)
        ) +
   annotate("text", label = my_eq.char,
           y = 2.5, x = 3, size = 8, colour = "red", parse = TRUE) +
   expand_limits(y = c(-2, 4))
@

The examples above are moderately complex, but do not use expressions for all the elements in a ggplot that accept them. The next example uses them for scale labels. In the cases of scales, there are alternative approaches. One approach is to use user-supplied expressions.

<<plotmath-03>>=
ggplot(my.data, aes(x,y,label = greek.label)) +
   geom_point() +
   geom_text(angle = 45, hjust = 1.2, parse = TRUE) +
   labs(x = NULL,
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label = "sqrt(alpha[1] + frac(beta, gamma))",
           y = 2.5, x = 3, size = 8, colour = "red", parse = TRUE) +
   scale_x_continuous(breaks = c(1,3,5),
                      labels = c(expression(alpha[1]),
                                 expression(alpha[3]),
                                 expression(alpha[5]))
                      ) +
   expand_limits(y = c(-2, 4))
@

As expression accepts multiple arguments separated by commas, the labels can be written more concisely using a single call to \Rfunction{expression()}.

<<plotmath-03a>>=
ggplot(my.data, aes(x, y, label = greek.label)) +
   geom_point() +
   geom_text(angle = 45, hjust = 1.2, parse = TRUE) +
   labs(x = NULL,
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label = "sqrt(alpha[1] + frac(beta, gamma))",
           y = 2.5, x = 3, size = 8, colour = "red", parse = TRUE) +
   scale_x_continuous(breaks = c(1,3,5),
                      labels = expression(alpha[1], alpha[3], alpha[5])
                      ) +
   expand_limits(y = c(-2, 4))
@

A different approach (no example shown) would be to use \Rfunction{parse()} explicitly for each individual label, something that might be needed if the tick labels need to be ``assembled'' programmatically instead of set as constants.

\begin{advplayground}
Instead of this being an exercise for you to write code, you will need to study the code shown below until you are sure understand how it works. It makes use of different things you have learn in the current and previous chapters.

Parsing multiple labels in a scale definition, after assembling them with \Rfunction{paste()}. We want to achieve more generality, looking ahead to a future function to be defined.

<<plotmath-04, eval=eval_playground>>=
labels.char <- paste("alpha[", as.character(c(1,3,5)), "]")
my_parse <- function(x, ...) {parse(text = x, ...)}
labels.xpr <- sapply(labels.char, my_parse)
@

This three lines of code return a vector of expressions that can be used in a scale definition. Before using them, we will make a function out of them.

<<plotmath-05, eval=eval_playground>>=
make_labels <- function(base_text = "alpha", idxs = 1:5, ...) {
    sapply(X = paste(base_text, "[", as.character(idxs), "]", sep = ""),
           FUN = function(x, ...) {parse(text = x, ...)},
           USE.NAMES = FALSE)
}
@

And now we can use the function in a plot.

<<plotmath-06, eval=eval_playground>>=
breaks <- c(1,3,5)
ggplot(my.data, aes(x, y, label = greek.label)) +
   geom_point() +
   geom_text(angle = 45, hjust = 1.2, parse = TRUE) +
   labs(x = NULL,
        y = expression(Speed~~(m~s^{-1})),
        title = expression(sqrt(alpha[1] + frac(beta, gamma)))
        ) +
   annotate("text", label = "sqrt(alpha[1] + frac(beta, gamma))",
           y = 2.5, x = 3, size = 8, colour = "red", parse = TRUE) +
   scale_x_continuous(breaks = breaks,
                      labels = make_labels("alpha", breaks)
                      ) +
   expand_limits(y = c(-2, 4))
@

As a final task, change the code above so that the labels are subscripted $\beta$s and breaks from 1 to 5 with step 1.

\end{advplayground}

\begin{explainbox}
\textbf{Differences between \Rfunction{parse()} and \Rfunction{expression()}}. Function \Rfunction{parse()} takes as argument a character string. This is very useful as the character string can be created programmatically. When using \code{expression()} this is not possible, except for substitution at execution time of the value of variables into the expression. See help pages for both functions.

Function \Rfunction{expression()} accepts its arguments without any delimiters. Function \Rfunction{parse()} takes a single character string as argument to be parsed, in which case quotation marks need to be \emph{escaped} (using \code{\backslash"} where a literal \code{"} is desired). We can, also in both cases embed a character string by means of one of the functions \Rfunction{plain()}, \Rfunction{italic()}, \Rfunction{bold()} or \Rfunction{bolditalic()} which also affect the font used. The argument to these functions needs sometimes to be a character string delimited by quotation marks.

When using \Rfunction{expression()}, bare quotation marks can be embedded,

<<expr-parse-box-01>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(expression(x[1]*"  test"))
@

while in the case of \Rfunction{parse()} they need to be \emph{escaped},

<<expr-parse-box-02>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(parse(text = "x[1]*\"  test\""))
@

and in some cases will need to be enclosed within a format function.

<<expr-parse-box-03>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(parse(text = "x[1]*italic(\"  test\")"))
@

We can compare the expressions returned by \Rfunction{expression()} and \Rfunction{parse()} as used above.

<<expr-parse-box-04>>=
expression(x[1]*"  test")
parse(text = "x[1]*\"  test\"")
@

A few additional remarks. If \Rfunction{expression()} is passed multiple arguments, \Rfunction{ggplot()} uses only the first one, in the case of axis labels, when a single character string is expected as argument.

<<expr-parse-box-05>>=
expression(x[1], "  test")
@

<<expr-parse-box-06>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(expression(x[1], "  test"))
@

Depending on the location within a expression, spaces maybe ignored, or even illegal. To juxtapose elements without adding space use \code{*}, to explicitly insert white space, use \code{\textasciitilde}. As shown above spaces are accepted within quoted text.

So the following alternatives can also be used.

<<expr-parse-box-07>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(parse(text = "x[1]~~~~\"test\""))
@

<<expr-parse-box-08>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(parse(text = "x[1]~~~~plain(test)"))
@

However, unquoted white space is discarded.

<<expr-parse-box-09>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  xlab(parse(text = "x[1]*plain(   test)"))
@

\end{explainbox}

Above we used paste to insert values stored in a variable, and this combined with \Rfunction{format()}, \Rfunction{sprintf()}, and \Rfunction{strftime()} gives already a lot of flexibility.

\begin{playground}
Study the examples below. If you are familiar with \langname{C} or \langname{C++} the last two functions will be already familiar to you.

<<sprintf-01, eval=eval_playground>>=
sprintf("%s: %.3g two values formatted and inserted", "test", 15234)
sprintf("log(%.3f) = %.3f", 5, log(5))
sprintf("log(%.3g) = %.3g", 5, log(5))
@

Write a function for the second statement in the chunk above. The function should take a single numeric argument through its only formal parameter, and produce equivalent output to the statement above. However, it should be usable with any numeric value.

Do look up the help pages for these three functions and play with them at the console. They are extremely useful.
\end{playground}

It is also possible to substitute the value of variables or, in fact, the result of evaluation, into a new expression, allowing on-the-fly construction of expressions. Such expressions are frequently used as labels in plots. This is achieved through use of \emph{quoting} and \emph{substitution}.

We use \Rfunction{bquote()} to substitute variables or expressions enclosed in \code{.( )} by their value. Be aware that the argument to \Rfunction{bquote()} needs to be written as an expression, in this example we need to use a tilde, \code{\textasciitilde}, to insert a space between words. Furthermore, if the expressions include variables, these will be searched for in the environment.

<<expr-bquote-01>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  labs(title = bquote(Time~zone: .(Sys.timezone())),
       subtitle = bquote(Date: .(as.character(today())))
       )
@

In the case of \Rfunction{substitute()} we supply what is to used for substitution through a named list.

<<expr-substitute-01>>=
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  labs(title = substitute(Time~zone: tz, list(tz = Sys.timezone())),
       subtitle = substitute(Date: date, list(date = as.character(today())))
       )
@

For example, substitution can be used to assemble an expression within a function based on the arguments passed. One case of interest is to retrieve the name of the object passed as an argument, from within a function.

<<expr-deparse-01>>=
deparse_test <- function(x) {
  print(deparse(substitute(x)))
}

a <- "saved in variable"

deparse_test("constant")
deparse_test(1 + 2)
deparse_test(a)
@

\index{plots!math expressions|)}

\section{Generating output files}
\index{devices!output|see{graphic output devices}}
\index{graphic output devices|(}
It is possible, when using \RStudio, to directly export the displayed plot to a file. However, if the file will have to be generated again at a later time, or a series of plots need to be produced with consistent format, it is best to include the commands to export the plot in the script.

In R,\index{plots!printing}\index{plots!saving}\index{plots!output to files} files are created by printing to different devices. Printing is directed to a currently open device. Some devices produce screen output, others files. Devices depend on drivers. There are both devices that or part of R, and devices that can be added through packages.

A very\index{plots!PDF output} simple example of PDF output (width and height in inches):

<<eval=FALSE>>=
fig1 <- ggplot(data.frame(x = -3:3), aes(x = x)) +
  stat_function(fun = dnorm)
pdf(file = "fig1.pdf", width = 8, height = 6)
print(fig1)
dev.off()
@

Encapsulated\index{plots!Postscript output} Postscript output (width and height in inches):

<<eval=FALSE>>=
postscript(file = "fig1.eps", width = 8, height = 6)
print(fig1)
dev.off()
@

There are Graphics devices for\index{plots!bitmap output} BMP, JPEG, PNG and TIFF format bitmap files. In this case the default units for width and height is pixels. For example we can generate TIFF output:

<<eval=FALSE>>=
tiff(file = "fig1.tiff", width = 1000, height = 800)
print(fig1)
dev.off()
@

\subsection{Using \LaTeX\ instead of plotmath}
\index{plots!using Latex@using \LaTeX|(}
\index{tikz output device|see{plots, using \LaTeX}}
To use \LaTeX\ syntax in plots we need to use a different \emph{software device} for output. It is called \code{Tikz} and defined in package \pkgname{tikzDevice}. This device generates output that can be interpreted by \LaTeX\ either as a self-contained file or as a file to be input into another \LaTeX\ source file. As the bulk of this handbook does not use this device, we will use it explicitly and input the files into this section. A \TeX\ distribution should be installed, with \LaTeX\ and several (\LaTeX) packages including \pkgname{tikz}.

\subsubsection{Fonts}

Font face selection, weight, size, maths, etc. are set with \LaTeX\ syntax. The main advantage of using \LaTeX\ is the consistency between the typesetting of the text body and figure labels and legends. For those familiar with \LaTeX\ not having to remember/learn the syntax of plotmath will a bonus.

We will revisit the example from the previous sections, but now using \LaTeX\ for the subscripted Greek $\alpha$ for labels instead of \code{plotmath}. In this example we use as subscripts numeric values from another variable in the same dataframe.
\index{plots!using Latex@using \LaTeX|)}
\index{graphic output devices|)}

\section{Building complex data displays}
\index{examples!modular plot construction|(}

In this section we do not refer to those aspects of the design of a plot that can be adjust through themes (see section \ref{sec:plot:themes} on page \pageref{sec:plot:themes}. Whenever this possibility exists, it is the best. Here we refer to aspects that are not really part of the graphical (''artistic'') design, but instead mappings, labels and similar data and metadata related aspects of plots. In many cases scales (see section \ref{sec:plot:scales} on page \pageref{sec:plot:scales}) also fall within the scope of the present section.

\subsection{Using the grammar of graphics for individual plots}\label{sec:plot:composition}

The grammar of graphics\index{grammar of graphics}\index{plots!layers} allows one to build and test plots incrementally. In daily use, it is best to start with a simple design for a plot, print this plot, checking that the output is as expected and the code error-free. Afterwards, one can map additional \emph{aesthetics} and \emph{geometries} and \emph{statistics} gradually. The final steps are then to add \emph{annotations} and the text or expressions used for titles, and axis and key labels.

\begin{playground}
  Build a graphically complex data plot of your interest, step by step. By step by step, I do not refer to using the grammar in the construction of the plot as earlier, but of taking advantage of this modularity to test intermediate version in an iterative design process, first by building up the complex plot in stages as a tool in debugging, and later using iteration in the processes of improving the graphic design of the plot and improving its readability and effectiveness.
\end{playground}

As in any type of script with instructions (for humans or computers), we should avoid unnecessary repetition, as repetition conspires against consistent results and is a major source of errors when the script needs to be modified. Not less important, a shorter script, if well written is easier to read.

One approach is to use user-defined functions\index{plots!consistent format using functions}. One can for example, write simple wrapper functions on top functions defined in \ggplot, for example, adding/changing the defaults mappings to ones suitable for our application. In the case of \Rfunction{ggplot()}, as it is defined as a generic function, if one's data is stored in objects of a user-defined class, instead of a wrapper we can use a specialization of the generic. Such a specialized methods is almost invisible to users (e.g.\ does not require a different syntax or adding a word to the grammar). At the other extreme of complexity compared to a wrapper function, we could write a function that encapsulates all the code needed to build a specific type of plot. Package \pkgname{ggspectra} uses both approaches.

The graphic style of plots is best adjusted by means of themes. Although themes can be also used as building blocks as described below in the together with layers and scales, in can be better to add them when plots are being rendered as we may want to use different themes when, for example, rendering the same plot on different devices such as a printer or screen.

As \Rclass{ggplot}\index{plots!reusing parts of} objects are composed using operator \code{+} to assemble together the different components, one can also store in a variable these components, or using a list, partial plots, which can be used to compose the final figure.

\subsection{Saving plot layers and scales in variables}

We can assign a ggplot object or a part of it to a variable, and then assemble a new plot from the different pieces.

<<>>=
myplot <- ggplot(data = mtcars,
                 aes(x = disp, y = mpg,
                 colour = factor(cyl))) +
          geom_point()

mylabs <- labs(x = "Engine displacement)",
               y = "Gross horsepower",
               colour = "Number of\ncylinders",
               shape = "Number of\ncylinders")
@

And now we can assemble the final plot by putting the saved ``blocks'' together. A \code{"gg"} object should always be on the left side of the \code{+} operator. We add layers or other elements to it.

<<>>=
myplot
myplot + mylabs + theme_bw(16)
myplot + mylabs + theme_bw(16) + ylim(0, NA)
@

We can also save intermediate results.

<<>>=
mylogplot <- myplot + scale_y_log10(limits=c(8,55))
mylogplot + mylabs + theme_bw(16)
@

\subsection{Saving plot layers and scales in variables in lists}

If the pieces to be put together do not include a \code{"gg"} object, we can group them
into a "list" object. When we later add the list to a \code{"gg"} object, the members of the list are added one by one to the plot.

<<>>=
myparts <- list(mylabs, theme_bw(16))
mylogplot + myparts
@

\begin{playground}
Revise the code you wrote for the ``playground'' exercise in section \ref{sec:plot:composition}, but this time, pre-building and saving groups of elements that you expect to be useful unchanged when composing a different plot of the same type, or a plot of a different type from the same data.
\end{playground}

\index{examples!modular plot construction|)}

\subsection{Using functions as building blocks}

When the blocks we assemble need to accept arguments when used, we have to define functions instead of saving constant blocks to variables either individually or grouped in lists. The functions we define, have to return either a \code{"gg"} object, a list of components or a single plot component. The simplest use is to alter some defaults in existing functions which return \code{"gg"} objects or layers. The ellipsis (\code{...}) allows passing named arguments to a nested function. In this case, every single passed by name to \code{bw\_ggplot()} will be copied as argument to the nested call the \code{ggplot()}. Be aware, that supplying arguments by position, is not possible, unless, one includes the parameters explicitly in the wrapper function.

<<>>=
bw_ggplot <- function(...) {
  ggplot(...) +
  theme_bw()
}
@

Which could be used as follows.

<<>>=
bw_ggplot(data = mtcars,
          aes(x = disp, y = mpg,
          colour = factor(cyl))) +
          geom_point()
@

We can also write a function that encompasses all the needed blocks. This can be used, for example, to define new specialized \code{plot()} methods for the generic function \code{plot()}. The example below would plot objects of a hypothetical class \code{"zzz"}, containing variables $x$ and $y$. To show a bit fancier use, we scale both variables to a mean of 1, and then we plot them on a coordinate system with a fixed ratio of 1 between $x$ and $y$ scales.

<<>>=
plot.zzz <- function(data, ...) {
  ggplot(data = data, aes(x / mean(x), y / mean(y), ...)) +
  geom_point() +
  coord_fixed() +
  labs(x = "scaled x", y = "scaled y", title = "Plot of a \"zzz\" object")
}
@

<<>>=
some_data <- data.frame(x = rnorm(20),
                        y = rnorm(20, 5, 3))
class(some_data) <- c("zzz", class(some_data))
plot(some_data)
@

\begin{explainbox}
Frequently, simpler program code can be written when null objects and null operations are available. The return value of adding \code{NULL} or \code{list()} to a \code{ggplot} object is a copy of the object. In both cases the rendered plot is the same as the one from the original object.

<<eval=FALSE>>=
# not run
myplot
myplot + NULL
myplot + list()
@

The code in the next chunk is valid, it returns a blank plot. This apparently useless plot, can be very useful when writing functions that return \Rclass{ggplot} objects or build them piece by piece in a loop.

<<>>=
ggplot()
@

It is also important to keep in mind that code in the next two chunks is valid. In other words, the default aesthetics mapping does not need to be defined within the call to function \code{ggplot()}, neither is a default mapping needed at all when a mapping is passed to each layer in the plot.

<<>>=
ggplot(mtcars) +
  aes(x = disp, y = mpg, colour = factor(cyl)) +
  geom_point()
@

or

<<>>=
ggplot() +
  geom_point(data = mtcars,
             aes(x = disp, y = mpg, colour = factor(cyl)))
@
\end{explainbox}

\subsection{Using the data pipes}

We can pass as data argument to \code{ggplot()} the value returned by a pipe, and as \code{data} is the first parameter, \code{ggplot()} can be connected to a pipe. The example below is equivalent to that in the previous section.

<<>>=
 mtcars %>%
  ggplot(aes(x = disp, y = mpg, colour = factor(cyl))) +
          geom_point()
@

Or if we want to modify the data on the fly, in this case converting miles per gallon into litres per 100~km.  As seen earlier calculations like this can be done within the call to \code{aes()} but using a pipe can result in easier to understand code.

<<>>=
 mtcars %>%
  mutate(L_100km = 270 / mpg) %>%
  ggplot(aes(x = disp, y = L_100km, colour = factor(cyl))) +
          geom_point()
@

Another way in which the flexibility of package \pkgname{ggplot2}'s implementation of the grammar of graphics can be exploited is by accessing and modifying the default data within a layer. The simplest example is plotting selected observations from the data in a certain layer, doing the selection on-the-fly. To make this code work, several of the packages comprising the \pkgname{tidyverse} need to be loaded. In this case we use a dot \code{.} to get access to the global default data for the plot.

<<>>=
ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = cyl)) +
  geom_point(colour = "blue") +
  geom_point(data = . %>% filter(cyl == 8), shape = 21, colour = "red", size = 3)
@

Instead of function \code{filter()} we can use any R function that returns a data frame or a \code{tibble}, or as shown below a \emph{pipe}. If we want to reuse the global aesthetic mappings, we should maintain the same column names.

<<>>=
p1 <-
ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl))) +
  geom_point() +
  geom_text(data = . %>% group_by(cyl) %>%
                   summarise(disp = mean(disp),
                   mpg = mean(mpg),
                   mpg_lab = format(mpg, digits = 1)),
            aes(label = mpg_lab))
p1
@

This is particularly useful when saving layers in a list or individually as a building block, as in such case we do not know what will be the data argument when our ``block'' is used. This is not equivalent to a \emph{statistic} as we are manipulating the data using the original variable names in the data frame passed as argument. Within a \emph{statistic} we access the data after they have been mapped to aesthetics, such as $x$, $y$, label, colour, etc.

<<>>=
means_text <-
  geom_text(data = . %>% group_by(cyl) %>%
                   summarise(disp = mean(disp),
                   mpg = mean(mpg),
                   mpg_lab = format(mpg, digits = 1)),
            aes(label = mpg_lab))

ggplot(data = mtcars,
       aes(x = disp, y = mpg, colour = factor(cyl))) +
       stat_smooth(colour = "black", method = "lm", formula = y ~ poly(x, 2)) +
       geom_point() +
       means_text
@

\section{Extended examples}
\index{plots!advanced examples|(}
In this section we first produce some publication-ready plots requiring the use of different combinations of what has been presented earlier in this chapter and then we recreate some well known plots, using versions from Wikipedia articles as models. Our objective here is to show, how by combining different terms and modifiers from the grammar of graphics we can build step by step very complex plots and/or annotate them with sophisticated labels. Here we do not use any packages extending \ggplot. Even more elaborate versions of these plots are presented in later chapters using \ggplot together with other packages.

\subsection{Heat maps}\label{sec:plot:heatmap}
\index{plots!advanced examples!heatmap plot|(}
Heat maps are 3D plots, with two axes with cartesian coordinates giving origin to rectangular tiles, with a third dimension represented by the \code{fill} of the tiles. They are used to describe deviations from a reference or controls condition, with for example, blue representing values below the reference and red above. A color gradient represents the size of the deviation. Simple heat maps can be produced directly with \ggplot functions and methods. Heat maps with similitude trees obtained through clustering require additional tools.

The main difference with a generic tile plot (See section \ref{sec:tileplot} on page \pageref{sec:tileplot}) is that the fill scale is centred on zero and the red to blue colours used for fill represent a ``temperature''. Nowadays, the name \emph{heatmap} is also used for tile plots using other color for fill, as long as they represent deviations from a central value.

\sloppy
To obtain a heat map, then we need to use as fill scale \ggscale{scale\_fill\_gradient2()}. In the first plot we use the default colors for the fill, and in second example we use different ones.

For the examples in this section we use artificial data to build a correlation matrix, which we convert into a data frame before plotting.

<<>>=
set.seed(123)
x <- matrix(rnorm(200), nrow = 20, ncol = 10)
y <- matrix(rnorm(200), nrow = 20, ncol = 10)
cor.mat <- cor(x,y)
cor.df <- data.frame(cor = as.vector(cor.mat),
           x = rep(letters[1:10], 10),
           y = LETTERS[rep(1:10, rep(10, 10))])
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2()
@

<<>>=
ggplot(cor.df, aes(x, y, fill = cor)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "darkred", mid = "yellow",
  high = "darkgreen")
@
\index{plots!advanced examples!heatmap plot|)}

\subsection{Quadrat plots}
\index{plots!advanced examples!quadrat plot|(}

A quadrat plot is usually a scatter plot, although sometimes lines are also used. The scales are symmetrical both for $x$ and $y$ and negative and positive ranges: the origin $x = 0, y = 0$ is at the geometrical center of the plot.

We generate an artificial data set with \code{y} values correlated to \code{x} values.

<<>>=
set.seed(4567)
x <- rnorm(200, sd = 1)
quadrat_data.df <- data.frame(x = x,
                              y = rnorm(200, sd = 0.5) + 0.5 * x)
@

Here we draw a simple quadrat plot, by adding two lines and using fixed coordinates with a 1:1 ratio between $x$ and $y$ scales.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_point() +
    coord_fixed(ratio = 1) +
    theme_bw()
@

We may want to add lines showing 1:1 slopes, make the axes limits symmetric, and make points semi-transparent to allow overlapping points to be visualized. We expand the limits with \Rfunction{expand\_limits()} rather that set them with \code{limits} or \Rfunction{xlim()} and \Rfunction{ylim()}, so that if there are observations in the data set outside our target limits, the limits will still include them. In other words, we set a minimum expanse for the limits of the axes, but allow them to \emph{grow} further if needed.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
    geom_abline(slope = -1, intercept = 0, color = "blue", linetype = "dashed") +
    geom_point(alpha = 0.5) +
    scale_color_identity(guide = FALSE) +
    scale_fill_identity(guide = FALSE) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@

It is also easy to add a linear regression line with its confidence band.

<<>>=
ggplot(data = quadrat_data.df, aes(x, y)) +
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    stat_smooth(method = "lm") +
    geom_point(alpha = 0.5) +
    coord_fixed(ratio = 1) +
    expand_limits(x = -3, y = -3) +
    expand_limits(x = +3, y = +3) +
    theme_bw()
@
\index{plots!advanced examples!quadrat plot|)}

\subsection{Volcano plots}\label{sec:plot:volcano}
\index{plots!advanced examples!volcano plot|(}

A volcano plot is just an elaborate version of a scatter plot, and can be created with \ggplot functions.
We here demonstrate how to create a volcano plot with tick labels in untransformed units, off-scale values drawn at the edge of the plotting region and highlighted with a different shape, and points color coded according to whether expression is significantly enhanced or depressed, or the evidence for the direction of the effect is inconclusive. We use a random sample of size 5000 from real data from an RNAseq experiment, included in package \pkgname{learnrbook}.

<<>>=
head(clean5000.df, 4)
@

First we create a no-frills volcano plot. This is just an ordinary scatter plot, with a certain way of transforming the $P$-values. We do this transformation on the fly when mapping the $y$ aesthetic with \code{y = -log10(PValue)}.

<<>>=
ggplot(data = clean5000.df,
         aes(x = logFC,
             y = -log10(PValue),
             color = factor(outcome))) +
    geom_point() +
    scale_color_manual(values = c("blue", "grey10", "red"), guide = FALSE)
@

Now we add quite many tweaks to the $x$ and $y$ scales. 1) we show tick labels in back-transformed units, at \emph{nice} round numbers. 2) We add publication-ready axis labels. 3) We restrict the limits of the $x$ and $y$ scales, but use \code{oob = scales::squish} so that instead of being dropped observations outside the range limits are plotted at the limit and highlighted with a a different \code{shape}. We also use the black and white \emph{theme} instead of the default one.

As we assume the reverse log transformation to be generally useful we define a function \Rfunction{reverselog\_trans()} for it. In the plot we use this function to set the transformation as part of the $y$-scale definition, so that we can directly map $P$-values to the $y$ \emph{aesthetic}.

<<>>=
reverselog_trans <- function(base = exp(1)) {
  trans <- function(x) -log(x, base)
  inv <- function(x) base^(-x)
  scales::trans_new(paste0("reverselog-", format(base)), trans, inv,
                    scales::log_breaks(base = base),
                    domain = c(1e-100, Inf))
}

ggplot(data = clean5000.df,
         aes(x = logFC,
             y = PValue,
             color = factor(outcome),
             shape = factor(ifelse(PValue <= 1e-40, "out", "in")))) +
    geom_vline(xintercept = c(log2(2/3), log2(3/2)), linetype = "dotted",
               color = "grey75") +
    geom_point() +
    scale_color_manual(values = c("blue", "grey80", "red"), guide = FALSE) +
    scale_x_continuous(breaks = c(log2(1e-2), log2(1e-1), log2(1/2),
                                  0, log2(2), log2(1e1), log2(1e2)),
                       labels = c("1/100", "1/10", "1/2", "1",
                                  "2", "10", "100"),
                       limits = c(log2(1e-2), log2(1e2)),
                       name = "Relative expression",
                       minor_breaks = NULL) +
    scale_y_continuous(trans = reverselog_trans(10),
                       breaks = c(1, 1e-3, 1e-10, 1e-20, 1e-30, 1e-40),
                       labels = scales::trans_format("log10",
                                                     scales::math_format(10^.x)),
                       limits = c(1, 1e-40), # axis is reversed!
                       name = expression(italic(P)-{value}),
                       oob = scales::squish,
                       minor_breaks = NULL) +
    scale_shape(guide = FALSE) +
    theme_bw()
@
\index{plots!advanced examples!volcano plot|)}

\subsection{Anscombe's regression examples}\label{sec:plot:anscombe}
\index{plots!advanced examples!Anscombe's linear regression plots|(}

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

This is another figure from Wikipedia \url{http://commons.wikimedia.org/wiki/File:Anscombe.svg?uselang=en-gb}.

This classical example form \citeauthor{Anscombe1973} (\citeyear{Anscombe1973}) demonstrates four very different data sets that yield exactly the same results when a linear regression model is fit to them, including $R^2 = 0.666$. It is usually presented as a warning about the need to check model fits beyond looking at $R^2$ and other parameter's estimates.

I will redraw the Wikipedia figure using \ggplot, but first I rearrange the original data.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol = 2)
my.anscombe <- data.frame(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

Once the data is in a data frame, plotting the observations plus the regression lines is easy.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~case, ncol = 2)
@

It is not much more difficult to make it look similar to the Wikipedia original.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape = 21, fill = "orange", size = 3) +
  geom_smooth(method = "lm", se = FALSE) +
  facet_wrap(~case, ncol = 2) +
  theme_bw(16)
@

Although I think that the confidence bands make the point of the example much clearer.

<<>>=
ggplot(my.anscombe, aes(x,y)) +
  geom_point(shape = 21, fill = "orange", size = 3) +
  geom_smooth(method = "lm") +
  facet_wrap(~case, ncol = 2) +
  theme_bw(16)
@
\index{plots!advanced examples!Anscombe's linear regression plots|)}

\subsection{Plotting color patches}
\index{plots!advanced examples!color patches|(}

For choosing colours when designing plots, or scales used in them, an indexed colour patch plot is usually very convenient (see section \ref{sec:plot:colors} on page \pageref{sec:plot:colors}. We can produce such a chart of colors with subsets of colors, or colours re-ordered compared to their position in the value returned by \Rfunction{colors()}. As the present chapter is on package \ggplot we use this package in this example. As this charts are likely to be needed frequently, I define here a function \Rfunction{ggcolorchart()}.

<<>>=
ggcolorchart <- function(colors,
                         ncol = NULL,
                         use.names = NULL,
                         text.size = 2) {
    # needed if the argument passed is subset with [ ]!
    force(colors)

    len.colors <- length(colors)
    # by default we attempt to use
    if (is.null(ncol)) {
      ncol <- max(trunc(sqrt(len.colors)), 1L)
    }
    # default for when to use color names
    if (is.null(use.names)) {
      use.names <- ncol < 8
    }
    # number of rows needed to fit all colors
    nrow <- len.colors %/% ncol
    if (len.colors %% ncol != 0) {
      nrow <- nrow + 1
    }
    # we extend the vector with NAs to match number of tiles
    if (len.colors < ncol*nrow) {
      colors[(len.colors + 1):(ncol*nrow)] <- NA
    }
    # we build a data frame
    colors.df <-
      data.frame(color = colors,
                 text.color =
                   ifelse(sapply(colors,
                                 function(x){mean(col2rgb(x))}) > 110,
                                 "black", "white"),
                 x = rep(1:ncol, nrow),
                 y = rep(nrow:1, rep(ncol, nrow)),
                 idx = ifelse(is.na(colors),
                              "",
                              format(1:(ncol * nrow), trim = TRUE)))
 # we build the plot
 p <- ggplot(colors.df, aes(x, y, fill = color))
 if (use.names) {
   p <- p + aes(label = ifelse(is.na(colors), "", colors))
 } else {
   p <- p + aes(label = format(idx, width = 3))
 }
 p <- p +
    geom_tile(color = "white") +
    scale_fill_identity() +
    geom_text(size = text.size, aes(color = text.color)) +
    scale_color_identity()
 p + theme_void()
}
@

\begin{playground}
After reading the use examples below, review the definition of the function, section by section, trying to understand what is the function of each section of the code. You can add print statements at different steps to look at the intermediate data values. Once you think you have grasped the purpose of a given statement, you can modify it in some way that modifies the output. For example, changing the defaults, for the shape of the tiles, e.g.\ so that the number of columns is about $1/3$ of the number of rows. Although you may never need exactly this function, studying its code will teach you some \emph{idioms} used by R programers. This function, in contrast to some other R code examples for plotting color tiles, does not contain any loop. It returns a \Rclass{ggplot} object, which be added to and/or modified.
\end{playground}

We first the predefined colors available in R.

<<>>=
ggcolorchart(colors()) +
  ggtitle("R colors",
          subtitle = "Labels give index or position in colors() vector")
@
\label{chunk:plot:color:tiles}

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

We subset those containing ``blue'' in the name, using the default number of columns.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), text.size = 3)
@

We reduce the number of columns and obtain rectangular tiles. The default for \code{use.names} depends on the number of tile columns, triggering automatically the change in labels.

<<>>=
ggcolorchart(grep("blue", colors(), value = TRUE), ncol = 4)
@

We demonstrate how perceived colors are affected by the hue, saturation and value in the HSV colour model.

<<>>=
ggcolorchart(hsv(1, (0:48)/48, 0.67), text.size = 3) +
  ggtitle("HSV saturation", "H = 1, S = 0..1, V = 0.67")
@

<<>>=
ggcolorchart(hsv(1, 1, (0:48)/48), text.size = 3) +
  ggtitle("HSV value", "H = 1, S = 1, V = 0..1")
@

<<>>=
ggcolorchart(hsv((0:48)/48, 1, 1), text.size = 3) +
  ggtitle("HSV hue", "H = 0..1, S = 1, V = 1")
@

We demonstrate how perceived colors are affected by the hue, chroma and luminance in the HCL colour model.

<<>>=
ggcolorchart(hcl((0:48)/48 * 360), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 85")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, l = 67), text.size = 3) +
  ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 35, l = 67")
@

<<>>=
ggcolorchart(hcl((0:48)/48 * 360, c = 67), text.size = 3) +
    ggtitle("CIE-LUV 'hcl' hue", "h = 0..360, c = 67, l = 85")
@

\begin{playground}
  The default order of the different colors in the vector returned by \Rfunction{colors()} results in a rather unappealing color tile plot (see page \pageref{chunk:plot:color:tiles}). Use functions \Rfunction{col2rgb()}, \Rfunction{rgb2hsv()} and \Rfunction{sort()} or \Rfunction{order()} to rearrange the tiles into a more pleasant arrangement, but still using for the labels the indexes to the positions of the colors in the original unsorted vector.
\end{playground}
\index{plots!advanced examples!color patches|)}

\subsection{Pie charts vs.\ bar plots example}\label{sec:plot:pie:bar}
\index{plots!advanced examples!pies vs. bar plots@plots!advanced examples!pies \emph{vs.}\ bar plots|(}

<<>>=
opts_chunk$set(opts_fig_wide)
@

There is an example figure widely used in Wikipedia to show how much easier it is to `read' bar plots than pie charts (\url{http://commons.wikimedia.org/wiki/File:Piecharts.svg?uselang=en-gb}).

Here is my \ggplot version of the same figure, using much simpler code and obtaining almost the same result.

<<>>=
example.data <-
  data.frame(values = c(17, 18, 20, 22, 23,
                        20, 20, 19, 21, 20,
                        23, 22, 20, 18, 17),
             examples= rep(c("A", "B", "C"), c(5,5,5)),
             cols = rep(c("red", "blue", "green", "yellow", "black"), 3)
  )

ggplot(example.data, aes(x = cols, y = values, fill = cols)) +
  geom_col(width = 1) +
  facet_grid(. ~ examples) +
  scale_fill_identity()
ggplot(example.data, aes(x = factor(1), y = values, fill = cols)) +
  geom_col(width = 1) +
  facet_grid(. ~ examples) +
  scale_fill_identity() +
  coord_polar(theta = "y")
@
\index{plots!advanced examples!pies vs. bar plots@plots!advanced examples!pies \emph{vs.}\ bar plots|)}
\index{plots!advanced examples|(}

<<eco=FALSE>>=
try(detach(package:tidyverse))
try(detach(package:lubridate))
try(detach(package:tikzDevice))
try(detach(package:ggplot2))
try(detach(package:scales))
try(detach(package:learnrbook))
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
knitter_diag()
R_diag()
other_diag()
@
