% !Rnw root = using-r.main.Rnw

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
@

\chapter[Extensions to ggplot]{Extensions to \ggplot}\label{chap:R:more:ggplotting}

\section{Packages used in this chapter}

For executing the examples listed in this chapter you need first to load the following packages from the library:

<<message=FALSE>>=
library(ggplot2)
library(viridis)
library(ggrepel)
library(ggpmisc)
library(xts)
library(MASS)
@

We set a font larger size than the default
<<>>=
theme_set(theme_grey(16))
@
<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
opts_knit$get()
search()
getwd()
@

\section[viridis]{\viridis}

Package \viridis defines color palettes and fill and color scales with colour selected based on human perception, with special consideration of visibility for those with different kinds of color blindness and well as in grey-scale reproduction.

<<viridis-00>>=
set.seed(56231)
my.data <-
  data.frame(x = rnorm(500),
             y = c(rnorm(250, -1, 1), rnorm(250, 1, 1)),
             group = factor(rep(c("A", "B"), c(250, 250))) )
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<viridis-01>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis()
@

<<viridis-02>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "magma")
@

<<viridis-03>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "inferno")
@

<<viridis-04>>=
ggplot(my.data, aes(x, y)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~group) +
  scale_fill_viridis(option = "plasma")
@

<<viridis-05>>=
ggplot(my.data, aes(x, y)) +
  geom_hex(bins = 6) +
  facet_wrap(~group) +
  scale_fill_viridis()
@

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

\section[ggpmisc]{\ggpmisc}

\sloppy
Package \ggpmisc is a package developed by myself as a result of questions from work mates and in Stackoverflow, or functionality that I have needed in my own research or for teaching. It provides new stats for everyday use: \code{stat\_peaks()}, \code{stat\_valleys()}, \code{stat\_poly\_eq()}, \code{stat\_fit\_glance()}, \code{stat\_fit\_deviations()}, and \code{stat\_fit\_augment()}. A function for converting time-series data to a data frame that can be easily plotted with `ggplot2'. It also provides some debugging tools that echo the data received as input: \code{stat\_debug\_group()}, \code{stat\_debug\_panel()}, and code{geom\_debug()}, and \code{geom\_null()} that does not plot its input.

\subsection{Plotting time-series}

Instead of creating a new statistics or geometry for plotting time series we provide a function that can be used to convert time series objects into data frames suitable for plotting with \ggplot. A single function \code{try\_data\_frame()} accepts time series objects saved with different packages as well as R's native \code{ts} objects. The \textit{magic} is done mainly by package \xts to which we add a very simple wrapper to obtain a data frame.

We exemplify this with some of the time series data included in R. In the first example we use the default format for time.

<<>>=
ggplot(try_data_frame(austres),
       aes(time, V.austres)) +
  geom_line()
@

In the second example we use years in numeric format for expressing `time'.

<<>>=
ggplot(try_data_frame(lynx, "year", as.numeric = TRUE),
       aes(x = time, y = V.lynx)) +
  geom_line()
@

Multivariate time series are also supported.

\subsection{Peaks and valleys}

Peaks and valleys are local (or global) maxima and minima. These stats return the $x$ and $y$ values at the peaks or valleys plus suitable labels, and default aesthetics that make easy their use with several different geoms, including \code{geom\_point}, \code{geom\_text}, \code{geom\_label}, \code{geom\_vline}, \code{geom\_hline} and \code{geom\_rug}, and also with geoms defined by package \ggrepel. Some examples follow.

There are many cases, for example in physics and chemistry, but also when plotting time-series data when we need to automatically locate and label local maxima (peaks) or local minima (valleys) in curves. The statistics presented here are useful only for dense data as they do not fit a peak function but instead simply search for the local maxima or minima in the observed data. However, they allow flexible generation of labels on both $x$ and $y$ peak or valley coordinates.

We use as example the same time series as above. In the next several examples we demonstrate some of this flexibility.

<<>>=
lynx.df <- data.frame(year = as.numeric(time(lynx)), lynx = as.matrix(lynx))
@

<<>>=
ggplot(lynx.df, aes(year, lynx)) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
               vjust = 1.5, x.label.fmt = "%4.0f") +
  ylim(-100, 7300)
@

<<>>=
ggplot(lynx.df, aes(year, lynx)) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             vjust = -0.5, x.label.fmt = "%4.0f") +
  ylim(NA, 7300)

@

<<>>=
ggplot(lynx.df, aes(year, lynx)) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue")
@

<<>>=
ggplot(lynx.df, aes(year, lynx)) + geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_peaks(geom = "text", colour = "red",
             hjust = -0.1, label.fmt = "%4.0f",
             angle = 90, size = rel(2),
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue") +
  stat_valleys(geom = "text", colour = "blue",
             hjust = -0.1, vjust = 1, label.fmt = "%4.0f",
             angle = 90, size = rel(2),
             aes(label = paste(..y.label..,
                               "skins in year", ..x.label..))) +
  ylim(NA, 10000)
@

Of course, if one finds use for it, the peaks and/or valleys can be plotted on their own. Here we plot an "envelope" using \code{geom\_line()}.

<<>>=
ggplot(lynx.df, aes(year, lynx)) +
  stat_peaks(geom = "line") + stat_valleys(geom = "line")
@

\subsection{Equations as labels in plots}

How to add a label with a polynomial equation including coefficient estimates from a model fit seems to be a frequently asked question in Stackoverflow. The parameter estimates are extracted automatically from a fit object corresponding to each \textit{group} or panel in a plot and other aesthetics for the group respected. An aesthetic is provided for this, and only this. Such a statistics needs to be used together with another geom or stat like geom smooth to add the fitted line. A different approach, discussed in Stackoverflow, is to write a statistics that does both the plotting of the polynomial and adds the equation label. Package \ggpmisc defines \code{stat\_poly\_eq()} using the first approach which follows the `rule' of using one function in the code for a single action. In this case there is a drawback that the users is responsible for ensuring that the model used for the label and the label are the same, and in addition that the same model is fitted twice to the data.

We first generate some artificial data.

<<>>=
set.seed(4321)
# generate artificial data
x <- 1:100
y <- (x + x^2 + x^3) +
  rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data <- data.frame(x, y,
                      group = c("A", "B"),
                      y2 = y * c(0.5,2))
@

\subsubsection{Linear models}

This section shows examples of linear models with one independent variables, including different polynomials.
We first give an example using default arguments.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(formula = formula, parse = TRUE)
@

\code{stat\_poly\_eq()} makes available five different labels in the returned data frame. $R^2$, $R_mathrm{adj}^2$, AIC, BIC and the polynomial equation. $R^2$ is used by default, but \code{aes()} can be used to select a different one.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..adj.rr.label..),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
  ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..AIC.label..),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

Within \code{aes()} it is possible to \textit{compute} new labels based on those returned plus ``arbitrary'' text. The supplied labels are meant to be \textit{parsed} into R expressions, so any text added should be valid for a string that will be parsed.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste(..eq.label..,
                                 ..adj.rr.label..,
                                 sep = "~~~~")),
               formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste("atop(", ..AIC.label.., ",",
                                       ..BIC.label.., ")",

                                       sep = "")),
               formula = formula, parse = TRUE)
@

Two examples of removing or changing the \textit{lhs} and/or the \textit{rhs} of the equation. (Be aware that the equals sign must be always enclosed in backticks in a string that will be parsed.)

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(hat(y))~`=`~",
formula = formula, parse = TRUE)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  labs(x = expression(italic(z)), y = expression(italic(h)) ) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(h)~`=`~",
               eq.x.rhs = "~italic(z)",
               formula = formula, parse = TRUE)
@

As any valid R expression can be used, Greek letters are also supported, as well as the inclusion in the label of variable transformations used in the model formula.

<<>>=
formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(my.data, aes(x, log10(y + 1e6))) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "plain(log)[10](italic(y)+10^6)~`=`~",
               formula = formula, parse = TRUE)
@

Example of a polynomial of fifth order.

<<>>=
formula <- y ~ poly(x, 5, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

Intercept forced to zero---line through the origin.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3) - 1
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE)
@

We give some additional examples to demonstrate how other components of the \code{ggplot}
object affect the behaviour of this statistic.

Facets work as expected either with fixed or free scales. Although bellow we
had to adjust the size of the font used for the equation.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), # size = 2.8,
               formula = formula, parse = TRUE) +
  facet_wrap(~group)
@

Grouping, in this example using colour aesthetic also works as expected.

<<echo=FALSE>>=
opts_chunk$set(opts_fig_narrow)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE) +
  theme_bw() +
  theme(legend.position = "top")
@

\subsubsection{Other types of models}

Another statistic, \texttt{stat\_fit\_glance()} allows lots of flexibility, but at the moment there is no equivalently flexible version of \texttt{stat\_smooth()}.

We give an example with a linear model, showing a P-value (a frequent request for which I do not find much use).

We use \texttt{geom\_debug()} to find out what values \texttt{stat\_glance()} returns for our linear model, and add labels with P-values for the fits.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_glance(aes(label = paste('italic(P)~`=`~', signif(..p.value.., 3)), sep = ""),
                  parse = TRUE,
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

We use \texttt{geom\_debug()} to find out what values \texttt{stat\_glance()} returns for our resistant linear model fitted with \texttt{MASS:rlm()}.

<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(method.args = list(formula = formula),
                  geom = "debug",
                  method = "rlm",
                  summary.fun = print,
                  summary.fun.args = list()) +
  theme_bw() +
  theme(legend.position = "top")
@

Using the information now at hand we create some labels.
<<>>=
formula <- y ~ x + I(x^2) + I(x^3)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "rlm", formula = formula) +
  stat_fit_glance(aes(label = paste('AIC~`=`~', signif(..AIC.., 3),
                      "~~", 'BIC~`=`~', signif(..BIC.., 3), sep = "")),
                  parse = TRUE,
                  method = "rlm",
                  method.args = list(formula = formula),
                  geom = "text") +
  theme_bw() +
  theme(legend.position = "top")
@

In a similar way one can generate labels for any fit supported by package 'broom'.

\subsection{Highlighting deviations from fitted line}

First an example using default arguments.

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula)
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula, color = "red",
                      arrow = arrow(length = unit(0.015, "npc"),
                                   ends = "both")) +
  geom_point()
@

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_fit_deviations(formula = formula) +
  geom_point()
@

\subsection{Plotting residuals from linear fit}

<<>>=
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y, colour = group)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = formula)
@

\subsection{Filtering observations based on local density}

Statistics \Rfunction{stat\_dens2d\_filter} works best with clouds of observations, so we generate some random data.

<<>>=
set.seed(1234)
nrow <- 200
my.2d.data <-
  data.frame(
    x = rnorm(nrow),
    y = rnorm(nrow) + rep(c(-1, +1), rep(nrow / 2, 2)),
    group = rep(c("A", "B"), rep(nrow / 2, 2))
   )
@

In most recipes in the section we use \Rfunction{stat\_dens2d\_filter} to highlight observations with the \code{color} aesthetic. Other aesthetics can also be used.

By default 1/10 of the observations are kept from regions of lowest density.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red")
@

Here we change the fraction to 1/3.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.fraction = 1/3)
@

We can also set a maximum number of observations to keep.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.number = 3)
@

We can also keep the observations from the densest areas instead of the from the sparsest.

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE)
@

<<>>=
ggplot(my.2d.data, aes(x, y)) +
  geom_point() +
  stat_dens2d_filter(color = "red",
                     keep.sparse = FALSE) +
  facet_grid(~group)
@

In addition to \Rfunction{stat\_dens2d\_filter} there is \Rfunction{stat\_dens2d\_filter\_g}. The difference is in that the first one computes the density on a plot-panel basis while the second one does it on a group basis. This makes a difference only when observations are grouped based on another aesthetic within each panel.

<<>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter(shape = 1, size = 3)
@

<<>>=
ggplot(my.2d.data, aes(x, y, color = group)) +
  geom_point() +
  stat_dens2d_filter_g(shape = 1, size = 3)
@


\subsection{Learning and/or debugging}

A very simple stat named \code{stat\_debug()} can save the work of adding print statements to the code of stats to get information about what data is being passed to the \code{compute\_group()} function. Because the code of this function is stored in a \code{ggproto} object, at the moment it is impossible to directly set breakpoints in it. This \code{stat\_debug()} may also help users diagnose problems with the mapping of aesthetics in their code or just get a better idea of how the internals of \ggplot work.

<<>>=
ggplot(lynx.df, aes(year, lynx)) + geom_line() +
  stat_debug_group()
@

<<>>=
lynx.df$century <- ifelse(lynx.df$year >= 1900, "XX", "XIX")
ggplot(lynx.df, aes(year, lynx, color = century)) +
  geom_line() +
  stat_debug_group()
@

By means of \code{geom\_debug} it is possible to "print" to the console the data returned by a ggplot statistic.

<<>>=
ggplot(lynx.df, aes(century, lynx)) +
  geom_blank() +
  stat_summary(fun.y = median,
               geom = "debug", summary.fun = head, summary.fun.args = list())
@

\section[ggrepel]{\ggrepel}

Package \ggrepel is under development by Kamil Slowikowski. It does a single
thing, relocates text labels so that they do not overlap. This is achieved through
two geometries that work similarly to those provided by \ggplot except for the
relocation. This is incredibly useful both when labeling peaks and valleys and when
labeling points in scatter-plots. This is a significant problem in bioinformatics
plots and in maps.

\subsection{New geoms}

Package \ggrepel provides two new geoms: \code{geom\_text\_repel} and \code{geom\_label\_repel}. They are used similarly to \code{geom\_text} and \code{geom\_label} but the text or labels ``repel'' each other so that they rarely overlap unless the plot is very crowded.

<<>>=
ggplot(lynx.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(geom = "label_repel", nudge_y = 500)
@

For the time being I reproduce here a couple of examples from the package
vignette.

<<>>=
opts_chunk$set(opts_fig_wide_square)
@

<<>>=
ggplot(mtcars, aes(wt, mpg)) +
  geom_point(color = 'red') +
  geom_text_repel(aes(label = rownames(mtcars)))
@

<<>>=
set.seed(42)
ggplot(mtcars) +
  geom_point(aes(wt, mpg), size = 5, color = 'grey') +
  geom_label_repel(
  aes(wt, mpg, fill = factor(cyl), label = rownames(mtcars)),
      fontface = 'bold', color = 'white',
      box.padding = unit(0.25, "lines"),
      point.padding = unit(0.5, "lines")) +
  theme(legend.position = "top")
@

<<>>=
set.seed(42)
ggplot(Orange, aes(age, circumference, color = Tree)) +
  geom_line() +
  coord_cartesian(xlim = c(min(Orange$age), max(Orange$age) + 90)) +
  geom_text_repel(data = subset(Orange, age == max(age)),
                  aes(label = paste("Tree", Tree)),
                  size = 6,
                  nudge_x = 45,
                  segment.color = NA) +
  theme(legend.position = "none") +
  labs(x = "Age (days)", y = "Circumference (mm)")
@

\section{Examples}

\subsection{Anscombe's example revisited}

To make the example self contained we repeat the code from chapter \ref{chap:plotting}.

<<>>=
# we rearrange the data
my.mat <- matrix(as.matrix(anscombe), ncol=2)
my.anscombe <- data.frame(x = my.mat[ , 1],
                          y = my.mat[ , 2],
                          case=factor(rep(1:4, rep(11,4))))
@

<<>>=
ggplot(my.anscombe, aes(x = x, y = y)) +
  geom_point(shape=21, fill="orange", size=3) +
  geom_smooth(method="lm") +
  stat_poly_eq(formula = y ~ x, parse = TRUE,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~"))) +
  facet_wrap(~case, ncol=2) +
  theme_bw(16)
@

\subsection{Volcano plots}


\subsection{Quadrat plots}

<<>>=
try(detach(package:ggpmisc))
try(detach(package:xts))
try(detach(package:ggrepel))
try(detach(package:ggplot2))
@

