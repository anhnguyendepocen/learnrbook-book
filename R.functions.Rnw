% !Rnw root = appendix.main.Rnw
<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
opts_knit$set(concordance=TRUE)
opts_knit$set(unnamed.chunk.label = 'functions-chunk')
@

\chapter{The R language: adding new ``words''}\label{chap:R:functions}

\begin{VF}
Computer Science is a science of abstraction---creating the right model for a problem and devising the appropriate mechanizable techniques to solve it.

\VA{Alfred V. Aho and Jeffrey D. Ullman}{Foundations of Computer Science}
\end{VF}

%\dictum[Alfred V. Aho, Jeffrey D. Ullman, \emph{Foundations of Computer Science}, Computer Science Press, 1992]{Computer Science is a science of abstraction---creating the right model for a problem and devising the appropriate mechanizable techniques to solve it.}\vskip2ex

\section{Aims of this chapter}

In earlier chapters we have only used base \Rlang features. In this chapter you will learn how to expand the range of features available. In the first part of the chapter I will focus on using existing packages and how they expand the functionality of \Rlang. In the second part you will learn how to define new functions and classes by yourself. We will not consider the important, but more advanced question of packaging functions and classes into new packages. The development of packages is thoroughly described in the book \citebooktitle{Wickham2015} \autocite{Wickham2015}.

\section{Packages}\label{sec:script:packages}

\subsection{Download, installation and use}

\index{packages!using}
In \langname{R} speak `library' is the location where `packages' are installed. Packages are sets of functions, and data, specific for some particular purpose, that can be loaded into an \Rlang session to make them available so that they can be used in the same way as built-in \Rlang functions and data. Function \Rfunction{library()} is used to load packages, already installed in the local \Rlang library, into the current session, while function \Rfunction{install.packages()} is used to install packages, either from a file, or directly from a repository in the internet into the local library. When using \RStudio it can be easiest to use \RStudio menues (which call \Rfunction{install.packages()} and \Rfunction{update.packages()}) to install and update packages.

<<packages-1>>=
library(graphics)
@

Currently there are many thousands of packages available. The most reliable source of packages is CRAN, as only packages that pass strict tests and are actively maintained are retained. In some cases you may need or want to install less stable code, and this is also possible. With package \pkgname{devtools} it is even possible to install packages directly from Github, Bitbucket and a few other repositories. These later installations are always installations from source (see below).

\Rpgrm packages can be installed either from source, or from already built `binaries'. Installing from sources, depending on the package, may require additional software to be available. Under \pgrmname{MS-Windows}, the needed shell, commands and compilers are not available as part of the operating system. Installing them is not difficult as they are available prepackaged in installers (you will need \pgrmname{RTools}, and \pgrmname{\hologo{MiKTeX}}). However, for this reason it is the norm to install packages from binary \texttt{.zip} files under \pgrmname{MS-Windows}. Under Linux most tools will be available, or very easy to install, so it is usual to install packages from sources. For \pgrmname{OS X} (Apple Mac) the situation is somewhere in-between. If the tools are available, packages can be very easily installed from sources from within \RStudio. However, binaries are for most packages also readily available.

The development of packages is beyond the scope of the current book, and very well explained in the book \citebooktitle{Wickham2015} \autocite{Wickham2015}. However, it is still worthwhile mentioning a few things about the development of \Rpgrm packages. Using \RStudio it is relatively easy to develop your own packages. Packages can be of very different sizes. Packages use a relatively rigid structure of folders for storing the different types of files, and there is a built-in help system, that one needs to use, so that the package documentation gets linked to the \Rlang help system when the package is loaded. In addition to \Rlang code, packages can call functions and routines written in \langname{C}, \langname{C++}, \langname{FORTRAN}, \langname{Java}, etc.\ but some kind of `glue' is needed, as function call conventions and \emph{name mangling} depend on the programming language, and in many cases also on the compiler used. At least for \langname{C++}, the \pkgname{Rcpp} \langname{R} package makes the ``gluing'' extremely easy. See Chapter \ref{chap:R:performance} starting on page \pageref{chap:R:performance} for more information on performance-related and other limitations of \pgrmname{R} and how to solve possible bottlenecks.

One good way of learning how \Rlang works, is by experimenting with it, and whenever using a certain function looking at its help, to check what are all the available options. How much documentation is included with packages varies a lot, but many packages include comprehensive user guides or examples as \emph{vignettes} in addition to the help pages for individual functions or data sets. It is not unusual to decide which package to use from a set of alternatives based on the available documentation. In the case of some packages adding many new capabilities, packages may be documented in depth in a whole book. Well known examples are \citebooktitle{Pinheiro2000} \autocite{Pinheiro2000}, \citebooktitle{Sarkar2008} \autocite{Sarkar2008} and \citebooktitle{Wickham2016} \autocite{Wickham2016}.

\begin{warningbox}
\textbf{Naming conflicts} When two objects with the same name are present in the search path used by \Rlang to match names to stored objects, conflicts can occur. Not all names belong to the same namespace, and consequently, in many situations different object with identical names can coexist in the \Rlang environment. It is important that you realize than in such cases all these objects remain within reach of our code, but that the one nearest to the top of the search path will be returned when a ``bare'' name is used. The name of the namespace can be prepended to that of the object separated by double colons (\code{::}). In recent versions of R, every package is required to use a namespace to isolate the names used, and even names used in base R are in their own name space. This greatly facilitates the resolution of naming conflicts once they are identified.

<<namespaces-00>>=
mean(1:5)
base::mean(1:5)
@

If the loaded packages and user-written code do not reuse the name ``mean'', the two statements above are identical. If \code{mean} is redefined in user code, or exported by a package that has been loaded, the first statement will refer to the redefinition, while the second statement will continue to refer to the definition in base R.

<<namespaces-01>>=
mean <- function(x) {
  "my own mean is a fake"
}
mean(1:5)
base::mean(1:5)
@

<<namespaces-02>>=
rm(mean) # cleanup
mean(1:5)
base::mean(1:5)
@

When using packages naming conflicts can rather easily occur among packages. On the other hand very few packages use names for objects, classes or functions that are already in use in base \Rlang, and when they do, these are mostly backwards compatible with the objects they \emph{hide}. In general it is bad practice to redefine names from base \Rlang as those names are part the language, and a change in the behaviour of the \Rlang language is unexpected by users. In addition, such redefinitions can make valid \Rlang language scripts invalid, or result in the return wrong results. In many other computer programming languages, such reuse of names is disallowed and enforced: \emph{reserved} names make at least some of such redefinitions illegal. \Rlang is more permissive, and this is sometimes useful, but only in exceptional cases such reuse of names can be considered as being within ``good coding practice''.

In production code it is best to use the namespace plus name notation for names not defined within the script itself. In many cases, using the double colon notation makes the code of a script easier to read, although at the cost of some verbosity.
\end{warningbox}

Only objects exported by a package are visible outside its own namespace and only if imported. Loading a package makes the exported objects available, but to access to them still needs prepending the names with the namespace. Attaching a package adds the objects exported by the package to the search paths so that they can be accessed without prepending the name of the namespace. As mentioned above, in case of naming conflicts hiding some objects we may need to use the namespace based notation for accessing the hidden objects. Most packages do not export all the functions and objects defined in their code, some are kept internal, in most cases because they may change or be removed in future versions. Package namespaces can be detached and also unloaded with function \Rfunction{detach()} using a slightly different notation for the argument to that we described for data frames in section \ref{sec:calc:df:with} on page \pageref{sec:calc:df:with}.

The statement below is an error unless package `graphics' is in the \Rlang search list.
<<namespaces-03>>=
detach("package:graphics")
@

\subsection{Finding suitable packages}

Due to the large number of contributed \Rlang packages it can sometimes be difficult to find a suitable package for a task at hand. It is good to first check if the necessary capability is already built into base \Rlang. Base \Rlang plus the recommended packages (installed when \Rlang is installed) cover a lot of ground. To analyse data using almost any of the more common statistical methods does not require the use of special packages. Sometimes, contributed packages duplicate and or extend the functionality in base \Rlang with advantage. When one considers the use of novel or specialized types of data analysis, the use of contributed packages can be unavoidable. Even in such cases, it is not unusual to have alternatives to chose from within the available contributed packages. As we will see in later chapters sometimes groups or suites of packages are designed to work well together.

\subsubsection{CRAN task views}

\url{https://cran.r-project.org/web/views/}

\subsubsection{Bioconductor workflows}

\url{https://www.bioconductor.org/packages/release/BiocViews.html#___Workflow}

\subsubsection{ROpenSci}

\url{https://ropensci.org/packages/}

\subsubsection{METACRAN, RDocumentation and other aggregators}

\url{https://www.r-pkg.org/}
\url{https://www.rdocumentation.org/}

\section{Functions and operators}\label{sec:script:functions}
\index{functions!defining new}

\emph{Abstraction} can be defined as separating the fundamental properties from the accidental ones. Say obtaining the mean from a given vector of numbers, is an actual operation. There can be many such operations on different numeric vectors, each one a specific case. When we describe an algorithm for computing the mean from any numeric vector we have created the abstraction of \emph{mean}. In the same way each time we separate operations from specific data we create a new abstraction. In this sense functions are abstractions of operations or actions, they are like ``verbs'' describing actions separately from actors.

The main role of functions is that by providing an abstraction allowing us to avoid repeating blocks of code (groups of statements) applying the same operations on different data. The reasons to avoid repetition of similar code statement are that 1) if the algorithm or implementation needs to be revised---e.g.\ to fix a bug or error---, it is best to make edits in a single place; 2) sooner or later pieces of repeated code can become different leading to inconsistencies and hard to track bugs; 3) abstraction and division of a problem into smaller chunks, greatly helps with keeping the code understandable to humans; 2) repetition makes the script file longer, and this makes debugging, commenting, etc. more tedious, and error prone.

How do we in practice avoid repeating bits of code? We write a function containing the statements that we would need to repeat, and then \emph{call} (``use'') the function in their place. We have been calling \Rlang functions or operators in most earlier examples in this book, what we will next tackle is how to define new functions.

New functions and operators are defined using function \Rfunction{function()}, and saved like any other object in \Rpgrm by assignment to a variable name. In the example below \code{x} and \code{y} are both formal parameters, or names used within the function for objects that will be supplied as \emph{arguments} when the function is called. One can think of parameter names as place-holders.

<<fun-00>>=
my.prod <- function(x, y){x * y}
my.prod(4, 3)
@

\begin{warningbox}
In base \Rlang, arguments\index{functions:arguments} to functions are passed by copy. This is something very important to remember. Whatever you do within a function to modify an argument, its value outside the function will remain (almost) always unchanged. (In other languages arguments can be also passed by reference, meaning that assignments to a formal parameter within the body of function are referenced to the argument and modify it. Such roundabout effects are frequently called side-effects of a call. It is possible to imitate such behaviour in \Rlang using some language trickery and consequently some packages such as \pkgname{data.table} do define functions that use passing of arguments by reference.)

<<fun-01>>=
my.change <- function(x){x <- NA}
a <- 1
my.change(a)
a
@

In general, any result that needs to be made available outside the function must be returned by the function---or explicitly assigned to an object in the enclosing environment (i.e., using \Roperator{<<-} or \Rfunction{assign()}) as a side-effect.

A function can only return a single object, so multiple results are produced they need to be ``grouped'' into a single object. In many cases lists are used to collect all the values to be returned into one object. For example, model fit functions like \code{lm()} discussed in section \ref{sec:stat:LM} on page \pageref{sec:stat:LM} return a complex list with heterogeneous named members.
\end{warningbox}

\begin{playground}
When function \Rfunction{return()} is called within a function, flow of execution within the function stops and the argument passed
to \Rfunction{return()} is the value returned by the function call. In contrast, if function \Rfunction{return()} is not explicitly
called, the value returned by the function call is that returned by the last statement \emph{executed} within the body of the function---i.e.\
the returned value is not necessarily that returned by the last statement according to its position in the body of the function.

\label{chunck:print:funs}
<<fun-02>>=
print.x.1 <- function(x){print(x)}
print.x.1("test")
print.x.2 <- function(x){print(x); return(x)}
print.x.2("test")
print.x.3 <- function(x){return(x); print(x)}
print.x.3("test")
print.x.4 <- function(x){return(); print(x)}
print.x.4("test")
print.x.5 <- function(x){x}
print.x.4("test")
@
\end{playground}

\subsection{Ordinary functions}

After the toy examples above we will define a small but useful function: a function for calculating the standard error of the mean from a numeric vector.

<<fun-1NN>>=
SEM <- function(x){sqrt(var(x) / length(x))}
a <- c(1, 2, 3, -5)
a.na <- c(a, NA)
SEM(x = a)
SEM(a)
SEM(a.na)
@

For example in \code{SEM(a)} we are calling function \Rfunction{SEM()} with \code{a} as argument.

The function we defined above may sometimes give a wrong answer because NAs will be counted by \code{length()}, so we need to remove NAs before calling \code{length()}.

<<fun-1-safe>>=
simple_SEM <- function(x) {
 sqrt(var(x, na.rm=TRUE)/length(na.omit(x)))
}
a <- c(1, 2, 3, -5)
a.na <- c(a, NA)
simple_SEM(x=a)
simple_SEM(a)
simple_SEM(a.na)
@

\Rlang does not have a function for standard error, so the function above would be generally useful. If we would like to make this function both safe, and consistent with other similar \Rlang functions, one could define it as follows, allowing the user to provide a second argument which is passed as an argument to \Rfunction{var()}:

<<fun-2>>=
SEM <- function(x, na.rm = FALSE){
  sqrt(var(x, na.rm = na.rm) / length(na.omit(x)))
}
SEM(a)
SEM(a.na)
SEM(a.na, TRUE)
SEM(x = a.na, na.rm = TRUE)
SEM(TRUE, a.na)
SEM(na.rm = TRUE, x = a.na)
@

In this example you can see that functions can have more than one parameter, and that parameters can have default values to be used if no
argument is explicitly supplied. In addition if names of the parameters are supplied arguments can be passed in any order.
If parameter names are not supplied arguments are matched to parameters based on their position. Once one parameter name is given, all
later arguments need also to be explicitly named.

%We can assign to a variable defined `outside' a function with operator \code{<<-} but the usual recommendation is to avoid its use. This type of effects of calling a function are frequently called `side-effects'.

\begin{advplayground}
Test the behaviour of functions \code{print.x.1()} and \code{print.x.5()}, as defined on page \pageref{chunck:print:funs}, at the command prompt, and in a script, by writing a script.
The behaviour of one of these functions will be different when the script is source than at the command prompt. Explain why.
\end{advplayground}

\begin{playground}
Define your own function to calculate the mean in a similar way as \Rfunction{SEM()} was defined above. Hint: function \Rfunction{sum()} could be of help.
\end{playground}

\begin{playground}
Create some additional vectors containing \code{NA}s or not. Use them to test functions \Rfunction{simple\_SEM()} and \Rfunction{SEM()} defined above, and then explain why \code{SEM()} returns always the correct value, even though ``\code{na.omit(x)}'' is non-conditionally (always) applied to \code{x} before calculating its length.
\end{playground}

Functions can enclose much more complex and larger compound statements as their body than those in the examples above. Within an expression a function name followed by parentheses is interpreted as a call to the function. The name of a function instead gives access to its definition.

We first print (implicitly) the definition of our function from earlier in this section.
<<fun-3>>=
SEM
@

Next we print the definition of \Rlang linear model fitting function \code{lm()}. (Use of \code{lm()} is described in section \ref{sec:stat:LM} on page \pageref{sec:stat:LM}.)
<<fun-4>>=
lm
@

As can be seen at the end of the listing this function written in the \Rlang language has been byte-compiled so that it executes faster.

\subsection{Operators}

Operators are functions that use a different syntax for being called. If their name is enclosed in back ticks they can be called as regular functions. Binary operators like \code{+} have two formal parameters, and unary operators like unary \code{-} have only one formal parameter.

<<oper-01>>=
1 / 2
`/`(1 , 2)
@

\begin{explainbox}
\textbf{Defining a new operator.} We will define a binary operator (taking two arguments) that subtracts from the numbers in a vector the mean of another vector. First we need a suitable name but we have less freedom as names of user defined operators must be enclosed in percent signs. We will use \code{\%-mean\%} and as with any \emph{special name} we need to enclose it in quotation marks for the assignment.

<<oper-EB01>>=
"%-mean%" <- function(e1, e2) {
  e1 - mean(e2)
}
@

We can then use our new operator in a example.

<<oper-EB02>>=
10:15 %-mean% 1:20
@

To print the definition we enclose its name of our operator in back ticks---i.e.\ we back quote the special name.

<<oper-EB03>>=
`%-mean%`
@

\end{explainbox}

\section{Objects, classes and methods}\label{sec:script:objects:classes:methods}

Classes are abstractions, but abstractions describing the shared properties of ``types'' or groups of similar objects. In this sense classes are abstractions of ``actors'', they are like ``nouns'' in natural language. What we obtain with classes is the possibility of defining multiple versions of functions (or \emph{methods}) sharing the same name but tailored to operate on objects of a given class.

We start with a quotation form \citebooktitle{Burns1998} \autocite[][, page 13]{Burns1998}.
\begin{quotation}
The idea of object-oriented programming is simple, but carries a lot of weight.
Here's the whole thing: if you told a group of people ``dress for work'', then
you would expect each to put on clothes appropriate for that individual's job.
Likewise it is possible for S[R] objects to get dressed appropriately depending on
what class of object they are.
\end{quotation}

We say that specific methods are \emph{dispatched} based on the class of the argument passed. This, together with the loose type checks of \Rlang allows writing code that functions as expected on different types of objects, e.g.\ character and numeric vectors.

\Rlang has good support for the object oriented programming paradigm, but as a system that has evolved over the years, currently \Rlang supports multiple approaches. The still most popular approach is called S3, and a more recent and powerful approach, with slower performance, is called S4. The general idea is that a name like ``plot'' can be used as a generic name, and that the specific version of \Rfunction{plot()} called depends on the arguments of the call. Using computing terms we could say that the \emph{generic} of \Rfunction{plot()} dispatches the original call to different specific versions of \Rfunction{plot()} based on the class of the arguments passed. S3 generic functions dispatch, by default, based only on the argument passed to a single parameter, the first one. S4 generic functions can dispatch the call based on the arguments passed to more than one parameter and the structure of the objects of a given class is known to the interpreter. In S3 functions the specializations of a generic are recognized/identified only by their name. And the class of an object by a character string stored as an attribute to the object.

We first explore one of the methods already available in \Rlang. The definition of \code{mean} shows that it is the generic for a method.

<<object-classes-00>>=
mean
@

We can find out which methods are available in the current search path using \Rfunction{methods()}.
<<object-classes-00a>>=
methods(mean)
@

The most basic approach to creation of an object of a new S3 class, is to pre-pend the current class attribute of the object (a character vector) with the name for a new class. This would normally take place within a constructor and the new class if defined within a package would need to be registered.

<<explain-object-classes-01>>=
a <- 123
class(a)
class(a) <- c("myclass", class(a))
class(a)
@

Now we create a print method specific to \code{"myclass"} objects. Internally we are using function \Rfunction{sprintf()} and for the format template to work we need to pass a \code{numeric} value as argument---i.e. obviously \Rfunction{sprintf()} does not ``know'' how to handle objects of the class we have just created!
<<explain-object-classes-02>>=
print.myclass <- function(x) {
    sprintf("[myclass] %.g4", as.numeric(x))
}
@

Once a specialized method exists for a class, it will be used for objects of this class.

<<explain-object-classes-03>>=
print(a)
print(as.numeric(a))
@

The S3 class system is ``lightweight'' in that it adds very little additional computation load, but it is rather fragile in that most of the responsibility about consistency and correctness of the design---e.g.\ not messing up dispatch by redefining functions or loading a package exporting functions with the same name, etc.-- is not checked by the R interpreter.

Defining a new S3 generic is also quite simple. A generic method and a default method need to be created.

<<explain-object-classes-04>>=
my_print <- function (x, ...) {
   UseMethod("my_print", x)
 }

my_print.default <- function(x, ...) {
   print(class(x))
   print(x, ...)
}
@

<<explain-object-classes-05>>=
my_print(123)
my_print("abc")
@

Up to now, \Rfunction{my\_print()}, has no specialization. We now write one for data frames.

<<explain-object-classes-06>>=
my_print.data.frame <- function(x, rows = 1:5, ...) {
   print(x[rows, ], ...)
   invisible(x)
}
@

We add the second statement so that the function returns invisibly the whole data frame, rather than the lines printed. We now do a quick test of the function.

<<explain-object-classes-07>>=
my_print(cars)
my_print(cars, 8:10)
# my_print(cars, TRUE) not run
b <- my_print(cars)
nrow(b) == nrow(x) # was the whole data frame returned?
@

\begin{playground}
1) What would be the most concise way of defining a \code{my\_print()} specialization for \code{matrix}? Write one, and test it.
2) How would you modify the code of your \code{my\_print.matrix()} so that also the columns to print can be selected?
\end{playground}

An\index{objects}\index{classes}\index{methods} in-depth discussion of object oriented programming in \Rlang is outside the scope of this book. Several books describe in detail the different class systems available and how to take best advantage of them when developing packages extending \Rlang. For the non-programmer user, a basic understanding can be useful, even if he or she do not intend to create new classes. This basic knowledge is what we intend to convey in this section. For an in-depth treatment of the subject please consult the recently published book \citebooktitle{Wickham2014} \autocite{Wickham2014}.

<<eval=eval_diag, include=eval_diag, echo=eval_diag, cache=FALSE>>=
knitter_diag()
R_diag()
other_diag()
@

