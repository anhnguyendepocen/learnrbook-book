\chapter{Plotting maps and images}\label{chap:R:maps}

\section[ggmap]{\pkgname{ggmap}}

<<>>=
library(ggplot2)
library(ggmap)
library(rgdal)
library(scatterpie)
library(imager)
@

<<>>=
citation(package = "ggmap")
citation(package = "rgdal")
@

Package \pkgname{ggmap}\index{plots!maps}\index{plots!geographical maps|see{plots, maps}} is an extension to package \pkgname{ggplot2} for plotting and retrieving map data. Package \pkgname{ggmap} makes it possible to plot data using normal \pkgname{ggplot2} syntax on top of a map. Maps can be easily retrieved from the internet through different services. Some of these services require the user to register and obtain a key for access. As Google Maps does not require such a key for normal resolution maps, we use this service in the examples.

\subsection{Google maps}

The first step is to fetch the desired map. One can fetch the maps base on any valid Google Maps search term, or by giving the coordinates at the center of the map. Although \code{zoom} defaults to "auto", frequently the best result is obtained by providing this argument. Valid values for \code{zoom} are integers in the range 1 to 20.


\begin{warningbox}

We will fetch maps from Google Maps\index{plots!maps!from Google Maps}. We have disabled the messages, to avoid repeated messages about Google's terms of use.

\begin{description}
\item[Google Maps API Terms of Service:] \url{http://developers.google.com/maps/terms}
\item[Information from URL:] \url{http://maps.googleapis.com/maps/api/geocode/json?address=Europe&sensor=false}
\item[Map from URL:] \url{http://maps.googleapis.com/maps/api/staticmap?center=Europe&zoom=3&size=%20640x640&scale=%202&maptype=terrain&sensor=false}
\end{description}

\end{warningbox}

We start by fetching and plotting a map of Europe of type  \code{satellite}\index{plots!satellite images!from Google}. We use the default extent \code{panel}, and also the extent \code{device} and \code{normal}. The \code{normal} plot includes axes showing the coordinates, while \code{device} does not show them, while \code{panel} shows axes but the map fits tightly into the drawing area:

<<ggmap-01, echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
cache.flag <- TRUE
@

<<ggmap-02, message=FALSE, cache=cache.flag>>=
Europe1 <- get_map("Europe", zoom = 3, maptype = "satellite")
ggmap(Europe1)
@

<<ggmap-02a, message=FALSE, cache=cache.flag>>=
ggmap(Europe1, extent = "device")
@

<<ggmap-02b, message=FALSE, cache=cache.flag>>=
ggmap(Europe1, extent = "normal")
@

To demonstrate the option to fetch a map in black and white instead of the default colour version, we use a map of Europe of type \code{terrain}.

<<ggmap-03, message=FALSE, cache=cache.flag>>=
Europe2 <- get_map("Europe", zoom = 3, maptype = "terrain")
ggmap(Europe2)
@

<<ggmap-03a, message=FALSE, cache=cache.flag>>=
Europe3 <-
  get_map("Europe", zoom = 3, maptype = "terrain", color = "bw")
ggmap(Europe3)
@

To demonstrate the difference between type \code{roadmap} and the default type \code{terrain}, we use the map of Finland. Note that we search for ``Oulu'' instead of ``Finland'' as Google Maps takes the position of the label ``Finland'' as the center of the map, and clips the northern part. By means of \code{zoom} we override the default automatic zooming onto the city of Oulu.


<<ggmap-04, message=FALSE, cache=cache.flag>>=
Finland1 <- get_map("Oulu", zoom = 5, maptype = "terrain")
ggmap(Finland1)
@

<<ggmap-04a, message=FALSE, cache=cache.flag>>=
Finland2 <- get_map("Oulu", zoom = 5, maptype = "roadmap")
ggmap(Finland2)
@

We can even search for a street address, and in this case with high zoom value, we can see the building where one of us works:

<<ggmap-05, message=FALSE, cache=cache.flag>>=
BIO3 <- get_map("Viikinkaari 1, 00790 Helsinki",
                zoom = 18,
                maptype = "satellite")
ggmap(BIO3)
@

\index{plots!maps!data overlay layer}
We will now show a simple example of plotting data on a map, first by explicitly giving the coordinates, and in the second example we show how to fetch from Google Maps coordinate values that can be then plotted. We use function \code{geocode}. In one example we use \code{geom\_point} and \code{geom\_text}, while in the second example we use \code{annotate}, but either approach could have been used for both plots:

<<ggmap-06, message=FALSE, cache=cache.flag>>=
viikki <- get_map("Viikki, 00790 Helsinki",
                  zoom = 15,
                  maptype = "satellite")

our_location <- data.frame(lat = c(60.225, 60.227),
                           lon = c(25.017, 25.018),
                           label = c("BIO3", "field"))
ggmap(viikki, extent = "normal") +
  geom_point(data = our_location, aes(y = lat, x = lon),
             size = 4, colour = "yellow") +
  geom_text(data = our_location, aes(y = lat, x = lon, label = label),
            hjust = -0.3, colour = "yellow") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))
@


<<ggmap-06a, message=FALSE, cache=cache.flag>>=
our_geocode <- geocode("Viikinkaari 1, 00790 Helsinki")
ggmap(viikki, extent = "normal") +
  annotate(geom = "point",
           y = our_geocode[ 1, "lat"], x = our_geocode[ 1, "lon"],
           size = 4, colour = "yellow") +
  annotate(geom = "text",
           y = our_geocode[ 1, "lat"], x = our_geocode[ 1, "lon"],
           label = "BIO3", hjust = -0.3, colour = "yellow")  +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))
@

\subsection{World map}
\index{plots!maps!shape files}
\index{plots!advanced examples!World map}
Using function \code{get\_map()} from package \pkgname{ggmap} for drawing a world map is not possible at the time of writing. In addition a worked out example of how to plot shape files, and how to download them from a repository is suitable as our final example. We also show how to change the map projection. The example is adapted from a blog post at \url{http://rpsychologist.com/working-with-shapefiles-projections-and-world-maps-in-ggplot}.

We start by downloading the map data archive files from \url{http://www.naturalearthdata.com}\index{plots!maps!from Natural Earth} which is available in different layers. We only use three of the available layers: `physical' which describes the coastlines and a grid and bounding box, and `cultural' which gives country borders. We save them in a folder with name `maps', which is expected to already exist. After downloading each file, we unzip it.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<ggmap-07, cache=cache.flag>>=
getwd()

oldwd <- setwd("./maps")

url_path <-
#  "http://www.naturalearthdata.com/download/110m/"
  "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/"

download.file(paste(url_path,
                    "physical/ne_110m_land.zip",
                    sep = ""), "ne_110m_land.zip")
unzip("ne_110m_land.zip")

download.file(paste(url_path,
                    "cultural/ne_110m_admin_0_countries.zip",
                    sep = ""), "ne_110m_admin_0_countries.zip")
unzip("ne_110m_admin_0_countries.zip")

download.file(paste(url_path,
                    "physical/ne_110m_graticules_all.zip",
                    sep = ""), "ne_110m_graticules_all.zip")
unzip("ne_110m_graticules_all.zip")

setwd(oldwd)
@

We list the layers that we have downloaded.

<<ggmap-08>>=
ogrListLayers(dsn = "./maps")
@

Next we read the layer for the coastline, and use \code{fortify} to convert it into a data frame. We also create a second version of the data using the Robinson projection.\index{plots!maps!projection}\index{plots!maps!Robinson projection}

<<ggmap-09>>=
wmap <- readOGR(dsn = "./maps", layer = "ne_110m_land")
wmap.data <- fortify(wmap)
wmap_robin <- spTransform(wmap, CRS("+proj=robin"))
wmap_robin.data <- fortify(wmap_robin)
@

We do the same for country borders,

<<ggmap-10>>=
countries <- readOGR("./maps", layer = "ne_110m_admin_0_countries")
countries.data <- fortify(countries)
countries_robin <- spTransform(countries, CRS("+init=ESRI:54030"))
countries_robin.data <- fortify(countries_robin)
@

and for the graticule at $15^\circ$ intervals, and the bounding box.

<<ggmap-11>>=
grat <- readOGR("./maps", layer = "ne_110m_graticules_15")
grat.data <- fortify(grat)
grat_robin <- spTransform(grat, CRS("+proj=robin"))
grat_robin.data <- fortify(grat_robin)

bbox <- readOGR("./maps", layer = "ne_110m_wgs84_bounding_box")
bbox.data <- fortify(bbox)
bbox_robin <- spTransform(bbox, CRS("+proj=robin"))
bbox_robin.data <- fortify(bbox_robin)
@

Now we plot the world map of the coastlines, on a longitude and latitude scale, as a \code{ggplot} using \code{geom\_polygon}.

<<ggmap-12>>=
ggplot(wmap.data, aes(long, lat, group = group)) +
  geom_polygon() +
  labs(title = "World map (longlat)") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_equal()
@

There is one noticeable problem in the map shown above: the Caspian sea is missing. We need to use aesthetic \code{fill} and a manual scale to correct this.

<<ggmap-13>>=
ggplot(wmap.data, aes(long, lat, group = group, fill = hole)) +
  geom_polygon() +
  labs(title = "World map (longlat)") +
  scale_fill_manual(values = c("#262626", "#e6e8ed"), guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_equal()
@

<<ggmap-14, echo=FALSE, eval=FALSE>>=
# does not work as expected
ggplot(wmap.data, aes(long, lat, group = group)) +
  geom_polygon() +
  labs(title = "World map (longlat)") +
  scale_fill_manual(values = c("#262626", "#e6e8ed"),
                    guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_map()
@

When plotting a map using a projection, many default elements of the \code{ggplot} theme need to be removed, as the data is no longer in units of degrees of latitude and longitude and axes and their labels are no longer meaningful.

<<ggmap-15>>=
theme_map_opts <-
  list(theme(panel.grid.minor = element_blank(),
             panel.grid.major = element_blank(),
             panel.background = element_blank(),
             plot.background = element_rect(fill="#e6e8ed"),
             panel.border = element_blank(),
             axis.line = element_blank(),
             axis.text.x = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks = element_blank(),
             axis.title.x = element_blank(),
             axis.title.y = element_blank()))
@

Next we plot all the layers using the Robinson projection. This is still a \code{ggplot} and consequently one can plot data on top of the map, being aware of the transformation of the scale needed to make the data location match locations in a map using a certain projection.

<<ggmap-16>>=
ggplot(bbox_robin.data, aes(long,lat, group = group)) +
  geom_polygon(fill = "white") +
  geom_polygon(data = countries_robin.data, aes(fill = hole)) +
  geom_path(data = countries_robin.data, color = "white", size = 0.3) +
  geom_path(data = grat_robin.data, linetype = "dashed", color = "grey50") +
  labs(title = "World map (Robinson)") +
  coord_equal() +
  theme_map_opts +
  scale_fill_manual(values = c("black", "white"),
                    guide = "none")
@

As a last example, a variation of the plot above in colour and using the predefined theme \texttt{void()} instead of our home-brewed theme settings.

<<ggmap-17>>=
ggplot(bbox_robin.data, aes(long,lat, group = group)) +
  geom_polygon(fill = "blue") +
  geom_polygon(data = countries_robin.data, aes(fill = hole)) +
  geom_path(data = countries_robin.data, color = "white", size = 0.3) +
  geom_path(data = grat_robin.data, linetype = "dashed", color = "grey75") +
  labs(title = "World map (Robinson)") +
  coord_equal() +
  theme_void() +
  scale_fill_manual(values = c("brown", "white"),
                    guide = "none")
@

\section[imager]{\pkgname{imager}}
\index{images!plotting}
\index{images!processing}
Functions in this package allow easy plotting and ``fast'' processing of images with R. It is based on the \pgrmname{CIimg} library. \pgrmname{CImg}, \url{http://cimg.eu}, is a simple, modern \langname{C++} library for image processing defined using \langname{C++} templates for flexibility and to achieve fast computations.

<<imager00>>=
citation(package = "imager")
@

\subsection[Using the package: 1st example]{Using the package: first example}

I will use as examples downsized cropped sections\footnote{A crop is used to make the code faster. I may replace it with a higher resolution image before the book is published.} from photographs of a \emph{Dahlia} flower.

The first example is a photograph taken in sunlight, with no filter on the camera objective---i.e.\ a \emph{normal} image.

We read the image from a TIFF file with luminance data encoded in 8 bits per channel, i.e.\ as values in the range from 0 to 255. The image is saved as an object of class \code{"cimg"} as defined in package \pkgname{imager}.

<<imager-01>>=
dahlia01.img <- load.image("data/dahlia-vis.tif")
class(dahlia01.img)
mode(dahlia01.img)
dahlia01.img
@

We exemplify first the use of the \code{plot()} method from package \pkgname{imager}.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<imager-01a>>=
plot(dahlia01.img)
@

\begin{playground}
Read a different image, preferably one you have captured yourself. Images are not only photographs, so for example, you may want to play with electrophoresis gels. Several different bitmap file formats are accepted, and the path to a file can also be an URL (see Chapter \ref{chap:R:data} for details). Which file formats can be read depends on other tools installed in the computer you are using, in particular, if \pgrmname{ImageMagick} is available, many different file formats can automatically recognized and decoded/uncompressed when read. When playing, use a rather small bitmap, e.g.\ one mega pixel or smaller, to get a fast response when plotting.
\end{playground}

Converting the image to gray scale is easy if it is an 8 bit per channel image.

<<imager-01b>>=
dahlia01g.img <- grayscale(dahlia01.img)
class(dahlia01g.img)
mode(dahlia01g.img)
dahlia01g.img
@

<<imager-01c>>=
plot(dahlia01g.img)
@

\begin{playground}
Convert to gray scale a different colour image, after reading it from a file.
\end{playground}

We can convert a gray scale image into a black and white image with binary values for each pixel.

<<imager-01d>>=
dahlia01t.img <- threshold(dahlia01g.img)
plot(dahlia01t.img)
@

\begin{playground}
Function \code{threshols()} has a parameter that allows to override the automatically chosen threshold value. Read the documentation of the function and play by passing different thresholds for the same image, and looking at the plotted result. As an additional task, try the behaviour of the default with different images, and by reading the documentation on how the default is chosen, try to make sense of how the different images were segmented using the default threshold.
\end{playground}

\subsection[Plotting with  `ggplot2': 1st example]{Plotting with \ggplot: first example}

Although a \code{plot()} method is provided for \code{"cimg"} objects, we convert the image into a data frame so as to be able to use the usual R functions to plot and operate on the data. For simplicity's sake we start with the gray scale image. The \code{as.data.frame()} method converts this image into a \emph{tidy} data frame with column \code{cc} identifying the three colour channels, and the luminance values in column \code{value}. We add a factor \code{channel} with `nice' labels and add a numeric variable \code{luminance} with the values re-encoded to be in the range zero to one.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<imager-02>>=
dahlia01g.df <- as.data.frame(dahlia01g.img)
names(dahlia01g.df)
@

Now we can use functions from package \pkgname{ggplot2} as usual to create plots. We start by plotting a histogram of the \code{value} column.

<<imager-03>>=
ggplot(dahlia01g.df, aes(value)) +
       geom_histogram(bins = 30)
@

And then we plot it as a raster image, mapping luminance to the \code{alpha} \emph{aesthetic} and setting \code{fill} to a constant \code{"black"}. Because the $y$-axis of the image is the reverse of the default expected by \code{aes()} we need to reverse the scale, and we change expansion to zero, as we want the raster to extend up to the edges of the plotting area. As coordinates of pixel locations are not needed, we use \code{theme\_void()} to remove $x$- and $y$-axis labels, and the background grid. We use \code{coord\_fixed()} accepting the default ratio between $x$ and $y$ scales equal to one, as the image has square pixels.

<<imager-04>>=
ggplot(dahlia01g.df,
       aes(x, y, alpha = 1 - value)) +
       geom_raster(fill = "black") +
       coord_fixed() +
       scale_alpha_identity() +
       scale_x_continuous(expand = c(0, 0)) +
       scale_y_continuous(expand = c(0, 0),
                          trans = scales::reverse_trans()) +
       theme_void()
@

\begin{playground}
Plotting a large raster is slow, even with \code{geom\_raster}. Package \pkgname{imager} provides a function \code{resize()} that can be used to expand (by interpoaltion) or reduce the size of the image. Try reducing the $x$ and $y$ dimensions of the bitmap to 50\%, 20\%, and 5\% of their original size, and plotting it. With how much size reductio does the image quality deteriorate enough to be noticed on the monitor or laptop screen you are using?
\end{playground}

After this first simple example, we handle the slightly more complicated case of working with the original RGB colour image. In this case, \code{as.data.frame()} method converts the image into a \emph{tidy} data frame with column \code{cc} identifying the three colour channels, and the luminance values in column \code{value}. We add a factor \code{channel} with `nice' labels and add a numeric variable \code{luminance} with the values re-encoded to be in the range zero to one.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<imager-05>>=
dahlia01.df <- as.data.frame(dahlia01.img)
names(dahlia01.df)
dahlia01.df <- plyr::mutate(dahlia01.df,
                            channel = factor(cc, labels = c('R','G','B')),
                            luminance = value)
names(dahlia01.df)
@

Now we can use functions from package \pkgname{ggplot2} as usual to create different plots. We start by plotting histograms for the different color channels.

<<imager-06>>=
ggplot(dahlia01.df,
       aes(luminance, fill = channel)) +
       geom_histogram(bins = 30, color = NA) +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       facet_wrap(~channel)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_very_wide)
@

We now plot each channel as a separate raster, mapping luminance to the \code{alpha} \emph{aesthetic} and map the colour corresponding to each channel as a uniform \code{fill}. As above, because the $y$-axis of the image is the reverse of the default expected by \code{aes()} we need to reverse the scale, and we change expansion to zero, as we want the raster to extend up to the edges of the plotting area. Also as above, we use \code{theme\_void()} to remove $x$- and $y$-axis labels, and the background grid. We use \code{coord\_fixed()} accepting the default ratio between $x$ and $y$ scales equal to one.

<<imager-07>>=
ggplot(dahlia01.df,
       aes(x, y, alpha = (255 - luminance) / 255, fill = channel)) +
       geom_raster() +
       facet_wrap(~channel) +
       coord_fixed() +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       scale_alpha_identity() +
       scale_x_continuous(expand = c(0, 0)) +
       scale_y_continuous(expand = c(0, 0),
                          trans = scales::reverse_trans()) +
       theme_void()
@

\begin{playground}
Change the code used to build the ggplot above so that 1) the panels are in a column instead of in a row, 2) the bitmap for each channel is shown as a grey scale rather than a single red, green or blue image, and consider if the relative darkness between the three channels ``feels'' different in the two figures, 3) add to the previous figure a fourth panel with the image converted to a single gray scale channel. Hint: the way to do it is combine the data into a single data frame.
\end{playground}

\subsection[Using the package: 2nd example]{Using the package: second example}

The second original is a photograph of the same flower taken in sunlight, but using a UV-A band-pass filter. I chose such an image because the different colour channels have very different luminance values even after applying the full strength of the corrections available in the raw conversion software, making it look almost monochromatic.

We read the image from a TIFF file with luminance data encoded in 8 bits per channel, i.e.\ as values in the range from 0 to 255. As above the image is saved as an object of class \code{"cimg"} as defined in package \pkgname{imager}.

<<imager-11>>=
dahlia02.img <- load.image("data/dahlia-uva.tif")
class(dahlia02.img)
mode(dahlia02.img)
dahlia02.img
@

We use as above the \code{plot()} method from package \pkgname{imager}.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<imager-11a>>=
plot(dahlia02.img)
@

Converting this image to gray scale is easy as it is an 8 bit per channel image\footnote{In the case of images with 16 bit data, one needs to re-scale the luminance values to avoid out-of-range errors.}.

<<imager-11b>>=
dahlia02g.img <- grayscale(dahlia02.img)
class(dahlia02g.img)
mode(dahlia02g.img)
dahlia02g.img
@

<<imager-11c>>=
plot(dahlia02g.img)
@

\subsection[Plotting with  `ggplot2': 2nd example]{Plotting with \ggplot: second example}

To be able to use package \pkgname{ggplot2} we convert the image into a data frame so as to be able to use the usual R functions to plot and operate on the data. The \code{as.data.frame()} method converts the image into a \emph{tidy} data frame with column \code{cc} identifying the three colour channels, and the luminance values in column \code{value}. We add a factor \code{channel} with `nice' labels and add a numeric variable \code{luminance} with the values re-encoded to be in the range zero to one.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<imager-12>>=
dahlia02.df <- as.data.frame(dahlia02.img)
names(dahlia01.df)
dahlia02.df <- plyr::mutate(dahlia02.df,
                            channel = factor(cc, labels = c('R','G','B')),
                            luminance = value)
names(dahlia01.df)
@

Now we can use functions from package \pkgname{ggplot2} as usual to create different plots. We start by plotting histograms for the different color channels.

<<imager-13>>=
ggplot(dahlia02.df,
       aes(luminance, fill = channel)) +
       geom_histogram(bins = 30, color = NA) +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       facet_wrap(~channel)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_very_wide)
@

We now plot each channel as a separate raster, mapping luminance to the \code{alpha} \emph{aesthetic} so as to be able to map the colour corresponding to each channel as a uniform \code{fill}. Because the $y$-axis of the image is the reverse of the default expected by \code{aes()} we need to reverse the scale, and we change expansion to zero, as we want the raster to extend up to the edges of the plotting area. As coordinates of pixel locations are not needed, we use \code{theme\_void()} to remove $x$- and $y$-axis labels, and the background grid. We use \code{coord\_fixed()} accepting the default ratio between $x$ and $y$ scales equal to one, as the image has square pixels.

<<imager-14>>=
ggplot(dahlia02.df,
       aes(x, y, alpha =  (255 - luminance) / 255, fill = channel)) +
       geom_raster() +
       facet_wrap(~channel) +
       coord_fixed() +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       scale_alpha_identity() +
       scale_x_continuous(expand = c(0, 0)) +
       scale_y_continuous(expand = c(0, 0),
                          trans = scales::reverse_trans()) +
       theme_void()
@

\subsection[Manipulating pixel data: 2nd example]{Manipulating pixel data: second example}

After seeing the histograms, we guess a value for a constants to use to improve the white balance in a very simplistic way.

<<imager-21>>=
dahlia03.img <- dahlia02.img
red <- R(dahlia03.img) - 25
R(dahlia03.img) <- ifelse(red < 0, 0, red)
G(dahlia03.img) <- G(dahlia03.img) + 50
blue <- B(dahlia03.img) - 25
B(dahlia03.img) <- ifelse(blue < 0, 0, blue)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_narrow_square)
@

<<imager-21a>>=
plot(dahlia03.img)
@

Another approach would be to equalize the histograms. We start with the gray scale image.

<<imager-31>>=
plot(as.cimg(ecdf(dahlia02g.img)(dahlia02g.img), dim = dim(dahlia02g.img)))
@

The line above is not that easy to understand. What is going on is that the call \code{ecdf(dahlia02g.img)} returns a \emph{function} built on the fly, and then with the additional set of parentheses we call it, and then pass the result to the \code{as.cimg()} method, and the object this method returns is passed as argument to the \code{plot()} method. It can be split as follows into four statements.

<<imager-32>>=
eq.f <- ecdf(dahlia02g.img)
equalized_dahlia02g <- eq.f(dahlia02g.img)
equalized_dahlia02g.img <- as.cimg(equalized_dahlia02g, dim = dim(dahlia02g.img))
plot(equalized_dahlia02g.img)
@

A third syntax, is to use the \code{\%>\%} pipe operator. This operator is not native to the R language, but is defined by a package. However, in recent times its use has become rather popular for data transformations. These is equivalent to the nested calls in the one-line statement above.

<<imager-32a>>=
ecdf(dahlia02g.img)(dahlia02g.img) %>%
    as.cimg(equalized_dahlia02g, dim = dim(dahlia02g.img)) %>%
    plot()
@

We can further check how the ECDF function looks like, by looking at its attributes and printing its definition.

<<imager-33>>=
class(eq.f)
mode(eq.f)
eq.f
@

\begin{playground}
Define a function that accepts as argument a \code{cimg} object, and returns an equalized image as a \code{cimg} object. Do the development in steps as follows.
\begin{description}
  \item[Easy] Implement for gray scale images.
  \item[Medium] Implement for colour images both as argument and return values.
  \item[Advanced, brute force approach] As Medium but use R package \pkgname{Rcpp} to implement the ``glue'' code calling functions in the \pgrmname{CImg} library in \langname{C++} so that the data is passed back and forth between \langname{R} and compiled \langname{C++} code only once. Hint: look at the source code of package \pkgname{imager}, and use this as example. Read the documentation for the \pgrmname{CImg} library and package \pkgname{Rcpp} and try to avoid as much as possible the use of interpreted R code (see also Chapter \ref{chap:R:performance}).
  \item[Advanced, efficient approach] As above but use profiling and bench marking tools to first find which parts of the \langname{R} and/or \langname{C++} code are limiting performance and worthwhile optimizing for execution speed (see also Chapter \ref{chap:R:performance}).
\end{description}
\end{playground}

In the example above we used the \code{as.data.frame()} method defined in package \pkgname{imager} to obtain a tidy data frame with the luminance values in a single column. For some operations it may be better to work directly on the \code{cimg} object, which is simply a multidimensional numeric array with some ``frosting on top''.

\begin{playground}
Study the code of functions \code{R()}, \code{G()} and \code{B()}. Study the code, so as to understand why one could call them \emph{wrappers} of R array extraction operators. Then study the assignment version of the same functions \code{R<-()}, \code{G<-()} and \code{B<-()}.

<<imager-41>>=
R
@

<<imager-42>>=
channel
@
\end{playground}

\subsection{Using bitmaps as data in R}

I end with some general considerations about manipulating bitmap data in R. The functions in package \pkgname{imager} convert the images that are read from files into R's numeric arrays, something that is very handy because it allows applying any of the maths operators and functions available in R to the raster data. The downside is that this is wasteful with respect to memory use as in most cases the original data has only 8 or at most 16 bit of resolution. This approach could also slow down some operations compared to calling the functions defined in the \pgrmname{CImg} library directly from \langname{C++}. For example plotting seems so slow as to cause problems. The \pgrmname{CImg} library itself is very flexible and can efficiently use memory (see \url{http://cimg.eu/}), however profiting for all its capabilities and flexibility in combination with functions defined in R is made difficult by the fact that R supports fewer types of numerical data than \langname{C++} and tends to convert results to a wider type quite frequently.

To better understand what this means in practice, we can explore how the image is stored.

<<imager-51>>=
dim(dahlia01.img)
dimnames(dahlia01.img)
attributes(dahlia01.img)
@

<<imager-52>>=
str(dahlia01.img)
@

<<imager-53>>=
is.integer(dahlia01.img)
is.double(dahlia01.img)
is.logical(dahlia01.img)
@

We use function \code{object.size()} defined in the base R package \pkgname{utils} to find out how much space in memory the \code{cimg} object \code{dahlia01.img} occupies, and then we divide this value by the number of pixels.

<<imager-54>>=
format(object.size(dahlia01.img), units = "MB")
nPix(dahlia01.img) * 1e-6 # MPix
object.size(dahlia01.img) %/% nPix(dahlia01.img)
width(dahlia01.img) * height(dahlia01.img) * 1e-6 # MPix
object.size(dahlia01.img) %/% (width(dahlia01.img) * height(dahlia01.img))
@

We can see above that function \code{nPix()} returns the number of pixels in the image times the number of colour channels, and that to obtain the actual number of pixels we should multiply width by height of the image. We used in these examples, small images by current standards, of only 0.64 MPix, that at their native colour depth of 8~bits per channel, have a size in memory of 1.92~MB. They were read from compressed TIFF files with a size of about 0.8 to 1.1~MB on disk. However, they occupy nearly 15~MB in memory, or 8 times the size required to represent the information they contain.

\begin{infobox}
Package \pkgname{imager} is a package containing many different functions wrapping functions from library \pgrmname{CImg}, the examples given here are only an introduction to the most basic of its capabilities. This library is written in \langname{C++} using templates, and can be instantiated at compile time for different types of pixel data. Consequently one cannot expect that calling these functions from R can be as fast as a good \langname{C++} implementation of the same operations with the same library. On the other hand, for relatively small images or small numbers of images, calling the library from R allows the use of R for computations on pixel data, which opens the door to the quick development and testing of pixel related statistical algorithms.
\end{infobox}

<<>>=
try(detach(package:imager))
try(detach(package:ggmap))
try(detach(package:rgdal))
@
