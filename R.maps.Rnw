\chapter{Plotting maps and images}\label{chap:R:maps}

\section[ggmap]{\pkgname{ggmap}}

<<>>=
library(ggplot2)
library(ggmap)
library(rgdal)
library(scatterpie)
library(imager)
@

<<>>=
citation(package = "ggmap")
citation(package = "rgdal")
@


Another\index{plots!maps}\index{plots!geographical maps|see{plots, maps}} extension to package \code{ggplot2} is package \code{ggmap}. Package \code{ggmap} makes it possible to plot data using normal \code{ggplot2} syntax on top of a map. Maps can be easily retrieved from the internet through different services. Some of these services require the user to register and obtain a key for access. As Google Maps do not require such a key for normal resolution maps, we use this service in the examples.

\subsection{Google maps}

The first step is to fetch the desired map. One can fetch the maps base on any valid Google Maps search term, or by giving the coordinates at the center of the map. Although \code{zoom} defaults to "auto", frequently the best result is obtained by providing this argument. Valid values for \code{zoom} are integers in the range 1 to 20.


\begin{warningbox}

We will fetch maps from Google Maps\index{plots!maps!from Google Maps}. We have disabled the messages, to avoid repeated messages about Google's terms of use.

\begin{description}
\item[Google Maps API Terms of Service:] \url{http://developers.google.com/maps/terms}
\item[Information from URL:] \url{http://maps.googleapis.com/maps/api/geocode/json?address=Europe&sensor=false}
\item[Map from URL:] \url{http://maps.googleapis.com/maps/api/staticmap?center=Europe&zoom=3&size=%20640x640&scale=%202&maptype=terrain&sensor=false}
\end{description}

\end{warningbox}

We start by fetching and plotting a map of Europe of type  \code{satellite}\index{plots!satellite images!from Google}. We use the default extent \code{panel}, and also the extent \code{device} and \code{normal}. The \code{normal} plot includes axes showing the coordinates, while \code{device} does not show them, while \code{panel} shows axes but the map fits tightly into the drawing area:

<<plot-maps-1, echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
cache.flag <- TRUE
@

<<plot-maps-2, message=FALSE, cache=cache.flag>>=
Europe1 <- get_map("Europe", zoom=3, maptype="satellite")
ggmap(Europe1)

ggmap(Europe1, extent = "device")

ggmap(Europe1, extent = "normal")

@

To demonstrate the option to fetch a map in black and white instead of the default colour version, we use a map of Europe of type \code{terrain}.

<<plot-maps-3, message=FALSE, cache=cache.flag>>=
Europe2 <- get_map("Europe", zoom=3,
                  maptype="terrain")
ggmap(Europe2)

Europe3 <- get_map("Europe", zoom=3,
                  maptype="terrain",
                  color="bw")
ggmap(Europe3)
@

To demonstrate the difference between type \code{roadmap} and the default type \code{terrain}, we use the map of Finland. Note that we search for ``Oulu'' instead of ``Finland'' as Google Maps takes the position of the label ``Finland'' as the center of the map, and clips the northern part. By means of \code{zoom} we override the default automatic zooming onto the city of Oulu.


<<plot-maps-4, message=FALSE, cache=cache.flag>>=
Finland1 <- get_map("Oulu", zoom=5, maptype="terrain")
ggmap(Finland1)

Finland2 <- get_map("Oulu", zoom=5, maptype="roadmap")
ggmap(Finland2)
@

We can even search for a street address, and in this case with high zoom value, we can see the building where one of us works:

<<plot-maps-5, message=FALSE, cache=cache.flag>>=
BIO3 <- get_map("Viikinkaari 1, 00790 Helsinki",
                zoom=18,
                maptype="satellite")
ggmap(BIO3)
@

\index{plots!maps!data overlay layer}
We will now show a simple example of plotting data on a map, first by explicitly giving the coordinates, and in the second example we show how to fetch from Google Maps coordinate values that can be then plotted. We use function \code{geocode}. In one example we use \code{geom\_point} and \code{geom\_text}, while in the second example we use \code{annotate}, but either approach could have been used for both plots:

<<plot-maps-6, message=FALSE, cache=cache.flag>>=
viikki <- get_map("Viikki, 00790 Helsinki",
                  zoom=15,
                  maptype="satellite")

our_location <- data.frame(lat=c(60.225, 60.227),
                           lon=c(25.017, 25.018),
                           label=c("BIO3", "field"))
ggmap(viikki, extent = "normal") +
  geom_point(data=our_location, aes(y=lat, x=lon),
             size=4, colour="yellow") +
  geom_text(data=our_location, aes(y=lat, x=lon, label=label),
            hjust=-0.3, colour="yellow")

our_geocode <- geocode("Viikinkaari 1, 00790 Helsinki")
ggmap(viikki, extent = "normal") +
  annotate(geom="point",
           y=our_geocode[ 1, "lat"], x=our_geocode[ 1, "lon"],
           size=4, colour="yellow") +
  annotate(geom="text",
           y=our_geocode[ 1, "lat"], x=our_geocode[ 1, "lon"],
           label="BIO3", hjust=-0.3, colour="yellow")
@

\subsection{World map}
\index{plots!maps!shape files}
\index{plots!advanced examples!World map}
Using \code{get\_map} from package \code{ggmap} for drawing a world map is not possible at the time of writing. In addition a worked out example of how to plot shape files, and how to download them from a repository is suitable as our final example. We also show how to change the map projection. The example is adapted from a blog post at \url{http://rpsychologist.com/working-with-shapefiles-projections-and-world-maps-in-ggplot}.

We start by downloading the map data archive files from \url{http://www.naturalearthdata.com}\index{plots!maps!from Natural Earth} which is available in different layers. We only use three of the available layers: `physical' which describes the coastlines and a grid and bounding box, and `cultural' which gives country borders. We save them in a folder with name `maps', which is expected to already exist. After downloading each file, we unzip it.

<<echo=FALSE, include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<plot-maps-7, cache=cache.flag>>=
getwd()

oldwd <- setwd("./maps")

url_path <-
#  "http://www.naturalearthdata.com/download/110m/"
  "http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/"

download.file(paste(url_path,
                    "physical/ne_110m_land.zip",
                    sep=""), "ne_110m_land.zip")
unzip("ne_110m_land.zip")

download.file(paste(url_path,
                    "cultural/ne_110m_admin_0_countries.zip",
                    sep=""), "ne_110m_admin_0_countries.zip")
unzip("ne_110m_admin_0_countries.zip")

download.file(paste(url_path,
                    "physical/ne_110m_graticules_all.zip",
                    sep=""), "ne_110m_graticules_all.zip")
unzip("ne_110m_graticules_all.zip")

setwd(oldwd)
@

We list the layers that we have downloaded.

<<>>=
ogrListLayers(dsn="./maps")
@

Next we read the layer for the coastline, and use \code{fortify} to convert it into a data frame. We also create a second version of the data using the Robinson projection.\index{plots!maps!projection}\index{plots!maps!Robinson projection}

<<>>=
wmap <- readOGR(dsn="./maps", layer="ne_110m_land")
wmap.data <- fortify(wmap)
wmap_robin <- spTransform(wmap, CRS("+proj=robin"))
wmap_robin.data <- fortify(wmap_robin)
@

We do the same for country borders,

<<>>=
countries <- readOGR("./maps", layer="ne_110m_admin_0_countries")
countries.data <- fortify(countries)
countries_robin <- spTransform(countries, CRS("+init=ESRI:54030"))
countries_robin.data <- fortify(countries_robin)
@

and for the graticule at $15^\circ$ intervals, and the bounding box.

<<>>=
grat <- readOGR("./maps", layer="ne_110m_graticules_15")
grat.data <- fortify(grat)
grat_robin <- spTransform(grat, CRS("+proj=robin"))
grat_robin.data <- fortify(grat_robin)

bbox <- readOGR("./maps", layer="ne_110m_wgs84_bounding_box")
bbox.data <- fortify(bbox)
bbox_robin <- spTransform(bbox, CRS("+proj=robin"))
bbox_robin.data <- fortify(bbox_robin)
@

Now we plot the world map of the coastlines, on a longitude and latitude scale, as a \code{ggplot} using \code{geom\_polygon}.

<<>>=
ggplot(wmap.data, aes(long,lat, group=group)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  coord_equal()
@

There is one noticeable problem in the map shown above: the Caspian sea is missing. We need to use aesthetic \code{fill} and a manual scale to correct this.

<<>>=
ggplot(wmap.data, aes(long,lat, group=group, fill=hole)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  scale_fill_manual(values=c("#262626", "#e6e8ed"),
                    guide="none") +
  coord_equal()
@


<<echo=FALSE, eval=FALSE>>=
# does not work as expected
ggplot(wmap.data, aes(long,lat, group=group)) +
  geom_polygon() +
  labs(title="World map (longlat)") +
  scale_fill_manual(values=c("#262626", "#e6e8ed"),
                    guide="none") +
  coord_map()
@

When plotting a map using a projection, many default elements of the \code{ggplot} theme need to be removed, as the data is no longer in units of degrees of latitude and longitude and axes and their labels are no longer meaningful.

<<>>=
theme_map_opts <-
  list(theme(panel.grid.minor = element_blank(),
             panel.grid.major = element_blank(),
             panel.background = element_blank(),
             plot.background = element_rect(fill="#e6e8ed"),
             panel.border = element_blank(),
             axis.line = element_blank(),
             axis.text.x = element_blank(),
             axis.text.y = element_blank(),
             axis.ticks = element_blank(),
             axis.title.x = element_blank(),
             axis.title.y = element_blank()))
@

Finally we plot all the layers using the Robinson projection. This is still a \code{ggplot} and consequently one can plot data on top of the map, being aware of the transformation of the scale needed to make the data location match locations in a map using a certain projection.

<<>>=
ggplot(bbox_robin.data, aes(long,lat, group=group)) +
  geom_polygon(fill="white") +
  geom_polygon(data=countries_robin.data,
               aes(long,lat, group=group,
                   fill=hole)) +
  geom_path(data=countries_robin.data,
            aes(long,lat, group=group, fill=hole),
            color="white",
            size=0.3) +
  geom_path(data=grat_robin.data,
            aes(long, lat, group=group, fill=NULL),
            linetype="dashed",
            color="grey50") +
  labs(title="World map (Robinson)") +
  coord_equal() +
  theme_map_opts +
  scale_fill_manual(values=c("black", "white"),
                    guide="none")
@

\section[scatterpie]{\pkgname{scatterpie}}
\index{plots!maps!pie-charts overlay}
Coming soon. I am not fond of pie charts, but displayed on top of maps they can sometimes be useful.

<<>>=
citation(package = "scatterpie")
@

\section[imager]{\pkgname{imager}}
\index{images!plotting}
\index{images!processing}
Functions in this package allows easy plotting and fast processing of images with R. It is based on the \pgrmname{CIimg} library. \pgrmname{CImg}, \url{http://cimg.eu}, is a simple, modern C++ library for image processing.

<<>>=
citation(package = "imager")
@

I will use as examples downsized cropped sections\footnote{A crop is used to make the code faster. I may replace it with a higher resolution image before the book is published.} from photographs of a \emph{Dahlia} flower. The first example is a photograph taken using a UV-A band-pass filter. I chose such an image because the different colour channels have very different luminance values even after applying in full the corrections available in the raw conversion software, making it look almost monochromatic.

We read the image from a TIFF file with luminance data encoded in 16 bits per channel, or values in the range from $2^0$ to $2^{16}$. The image is saved as an object of class \texttt{"cimg"} as defined in package \pkgname{imager}.

<<imager01>>=
dahlia01.img <- load.image("data/dahlia-uva.tif")
class(dahlia01.img)
dahlia01.img
@

We exemplify first the use of the \texttt{plot()} method from package \pkgname{imager}.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide_square)
@

<<imager01a>>=
plot(dahlia01.img)
@

Although a \texttt{plot()} method is provided for \texttt{"cimg"} objects, we convert the image into a data frame so as to be able to use the usual R functions to plot and operate on the data. The \texttt{as.data.frame()} method converts the image into a \emph{tidy} data frame with column \texttt{cc} identifying the three colour channels, and the luminance values in column \texttt{value}. We add a factor \texttt{channel} with `nice' labels and add a numeric variable \texttt{luminance} with the values re-encoded to be in the range zero to one.

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_wide)
@

<<imager02>>=
dahlia01.df <- as.data.frame(dahlia01.img)
names(dahlia01.df)
dahlia01.df <- plyr::mutate(dahlia01.df,
                            channel = factor(cc, labels = c('R','G','B')),
                            luminance = value / 2^16)
names(dahlia01.df)
@

Now we can use functions from package \pkgname{ggplot2} as usual to create different plots. We start by plotting histograms for the different color channels.

<<imager03>>=
ggplot(dahlia01.df,
       aes(luminance, fill = channel)) +
       geom_histogram(bins = 60, color = NA) +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       facet_wrap(~channel)
@

<<echo=FALSE,include=FALSE>>=
opts_chunk$set(opts_fig_very_wide)
@

We now plot each channel as a separate raster, mapping luminance to the \texttt{alpha} \emph{aesthetic} so as to be able to map the colour corresponding to each channel as a uniform \texttt{fill}. Because the $y$-axis of the image is the reverse of the default expected by \texttt{aes()} we need to reverse the scale, and we change expansion to zero, as we want the raster to extend up to the edges of the plotting area. As coordinates of pixel locations are not needed, we use \texttt{theme\_void()} to remove $x$- and $y$-axis labels, and the background grid. We use \texttt{coord\_fixed()} accepting the default ratio between $x$ and $y$ scales equal to one, as the image has square pixels.

<<imager04>>=
ggplot(dahlia01.df,
       aes(x, y, alpha = 1 - luminance, fill = channel)) +
       geom_raster() +
       facet_wrap(~channel) +
       coord_fixed() +
       scale_fill_manual(values = c('R' = "red", 'G' = "green", 'B' = "blue"),
                         guide = FALSE) +
       scale_alpha_identity() +
       scale_x_continuous(expand = c(0, 0)) +
       scale_y_continuous(expand = c(0, 0), 
                          trans = scales::reverse_trans()) +
       theme_void()
@


<<>>=
try(detach(package:imager))
try(detach(package:ggmap))
try(detach(package:rgdal))
@
